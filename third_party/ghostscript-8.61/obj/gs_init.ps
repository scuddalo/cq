% Copyright (C) 1989-2004 Artifex Software, Inc. All rights reserved.
% 
% This software is provided AS-IS with no warranty, either express or
% implied.
% 
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
% 
% For more information about licensing, please refer to
% http://www.ghostscript.com/licensing/. For information on
% commercial licensing, go to http://www.artifex.com/licensing/ or
% contact Artifex Software, Inc., 101 Lucas Valley Road #110,
% San Rafael, CA  94903, U.S.A., +1(415)492-9861.
861
dup revision ne{(gs: Interpreter revision \()print revision 10 string cvs print
(\) does not match gs_init.ps revision \()print 10 string cvs print(\).\n)print flush//null 1 .quit}if pop/userdict where
{pop userdict maxlength 0 eq}{true}ifelse
systemdict exch{dup/userdict
currentdict dup 200 .setmaxlength
.forceput}if begin
systemdict/.setglobal known{true .setglobal}{/.setglobal{pop}bind def/.currentglobal{false}bind def/.gcheck{pop false}bind def}
ifelse
systemdict/.languagelevel known not{/.languagelevel 1 def}if
true setpacking
<1a>cvn{}def
currentdict/DEBUG known/DEBUG exch def
mark/CCFONTDEBUG/CFFDEBUG/CMAPDEBUG/DOCIEDEBUG/EPSDEBUG/FAPIDEBUG/INITDEBUG/PDFDEBUG/PDFOPTDEBUG/PDFWRDEBUG/SETPDDEBUG/TTFDEBUG
/VGIFDEBUG/VJPGDEBUG/RESMPDEBUG
counttomark array astore exch pop{dup currentdict exch known DEBUG or def}forall
currentdict/PDFSTEP known/PDFSTEP exch def
PDFSTEP{/PDFDEBUG true def}if/VMDEBUG
INITDEBUG{{print mark
systemdict/level2dict known{.currentglobal dup false .setglobal vmstatus
true .setglobal vmstatus 3 -1 roll pop
6 -2 roll pop .setglobal}{vmstatus 3 -1 roll pop}ifelse usertime 16#fffff and counttomark{( )print(           )cvs print}
repeat pop( )print systemdict length(    )cvs print( )print countdictstack(  )cvs print
( <)print count(    )cvs print(>\n)print flush}}{{pop}}ifelse
def
currentdict/BATCH known/BATCH exch def
currentdict/DELAYBIND known/DELAYBIND exch def
currentdict/DISKFONTS known/DISKFONTS exch def
currentdict/DOINTERPOLATE .knownget{/INTERPOLATE exch def}if
currentdict/ESTACKPRINT known/ESTACKPRINT exch def
currentdict/FAKEFONTS known/FAKEFONTS exch def
currentdict/FIXEDMEDIA known/FIXEDMEDIA exch def
currentdict/FIXEDRESOLUTION known/FIXEDRESOLUTION exch def
currentdict/LOCALFONTS known/LOCALFONTS exch def
currentdict/JOBSERVER known/JOBSERVER exch def
currentdict/NOBIND known/NOBIND exch def/.bind/bind load def
NOBIND{/bind{}def}if
currentdict/NOCACHE known/NOCACHE exch def
currentdict/NOCCFONTS known/NOCCFONTS exch def
currentdict/NOCIE known/NOCIE exch def
currentdict/NOPSICC known/NOPSICC exch def
currentdict/NODISPLAY known not/DISPLAYING exch def
currentdict/NOFONTMAP known/NOFONTMAP exch def
currentdict/NOFONTPATH known/NOFONTPATH exch def
currentdict/NOGC known/NOGC exch def
currentdict/NOINTERPOLATE .knownget{/INTERPOLATE exch not def}if
currentdict/NOMEDIAATTRS known/NOMEDIAATTRS exch def
currentdict/NOOUTERSAVE known/NOOUTERSAVE exch def
currentdict/NOPAGEPROMPT known/NOPAGEPROMPT exch def
currentdict/NOPAUSE known/NOPAUSE exch def
currentdict/NOPLATFONTS known/NOPLATFONTS exch def
currentdict/NOPROMPT known/NOPROMPT exch def
currentdict/NOTRANSPARENCY known/NOTRANSPARENCY exch def
currentdict/DOPS known/DOPS exch def
currentdict/NOSUBSTDEVICECOLORS known/NOSUBSTDEVICECOLORS exch def
currentdict/ORIENT1 known not{/ORIENT1 true def}if
currentdict/OSTACKPRINT known/OSTACKPRINT exch def
currentdict/OUTPUTFILE known{/OutputFile/OUTPUTFILE load def
currentdict/OUTPUTFILE .undef}if
currentdict/QUIET known/QUIET exch def
currentdict/DELAYSAFER known{/DELAYSAFER true def/NOSAFER true def}if/SAFER currentdict/NOSAFER known{false}{
currentdict/SAFER known
currentdict/PARANOIDSAFER known or}ifelse def
currentdict/SHORTERRORS known/SHORTERRORS exch def
currentdict/STRICT known/STRICT exch def
currentdict/TTYPAUSE known/TTYPAUSE exch def
currentdict/WRITESYSTEMDICT known/WRITESYSTEMDICT exch def
currentdict/DEVICE known not{(GS_DEVICE)getenv{/DEVICE exch def}if}if(START)VMDEBUG(%stdin)(r)file pop(%stdout)(w)file pop
(%stderr)(w)file pop/.currentuserparams where{pop mark/MaxDictStack 500/MaxExecStack 5000/MaxOpStack 65414
.dicttomark .setuserparams}if/.skipeof{currentfile exch 1 exch .subfiledecode flushfile}.bind def
userdict begin/help{(Enter PostScript commands.  '(filename) run' runs a file, 'quit' exits.\n)print flush}.bind def
end
userdict/=string 256 string put/printgreeting{mark
product(Ghostscript)search{pop pop pop(This software comes with NO WARRANTY: see the file PUBLIC for details.\n)}{pop}ifelse
(\n)copyright(\)\n)revisiondate 10 mod revisiondate 10 idiv 10 mod(-)
revisiondate 100 idiv 10 mod revisiondate 1000 idiv 10 mod(-)revisiondate 10000 idiv( \()revision 10 mod
revision 100 mod 10 idiv(.)revision 100 idiv( )product
counttomark{(%stdout)(w)file exch 0 .writecvp}repeat pop}.bind def
QUIET not{printgreeting flush}if/obind{1 index exch .makeoperator}.bind def/odef{1 index exch .makeoperator def}.bind def
/.forcedef{1 .argindex pop
currentdict 3 1 roll .forceput}.bind odef/.systemvar{//systemdict exch get}.bind odef/.userdict{/userdict .systemvar}.bind odef
/.uservar{.userdict exch get}.bind odef
DELAYBIND NOBIND not and{.currentglobal false .setglobal
systemdict/.delaybind 1500 array .forceput
.setglobal
userdict/.delaycount 0 put/bind{/.delaybind .systemvar dup length 0 ne{.delaycount 2 index put
.userdict/.delaycount .delaycount 1 add put}{pop/.bind cvx exec}ifelse}.bind def}if
/hwsizedict mark/HWSize//null .dicttomark readonly def/copyscanlines{0 3 1 roll 3 index//hwsizedict .getdeviceparams
exch pop exch pop aload pop 3 2 roll
0 exch//null exch .getbitsrect exch pop}bind odef
currentdict/hwsizedict .undef/getdeviceprops{//null .getdeviceparams}bind odef/.putdeviceprops
{//null true counttomark 1 add 3 roll .putdeviceparams
dup type/booleantype ne{dup mark eq{/unknown/rangecheck}if
counttomark 4 add 1 roll cleartomark pop pop pop/.putdeviceprops .systemvar exch signalerror}if}bind odef
/.currentfilladjust{.currentfilladjust2 pop}bind odef/.setfilladjust{dup .setfilladjust2}bind odef
/.writecvs{0 .writecvp}bind odef/max{.max}bind def/min{.min}bind def/unread/.unread load def/.PurgeDict{{true
1 index{pop exch pop false exit}forall{exit}if
1 index exch undef}loop
pop}bind def
userdict/#copies 1 put([)cvn/mark load def(])cvn{counttomark array astore exch pop}odef/.beginpage{}odef/copypage{
.languagelevel 3 ge
dup{0}{1}ifelse .endpage .doneshowpage{.currentnumcopies 1 index .outputpage
(>>copypage, press <return> to continue<<\n).confirm
dup{erasepage}if}if pop
systemdict/..page_default_spaces .knownget{//.PurgeDict exec}if
.beginpage}odef/currentmatrix{dup type/arraytype ne{/currentmatrix load/typecheck signalerror}if
dup length 6 ne{/currentmatrix load/rangecheck signalerror}if
.currentmatrix 6 .argindex astore pop}odef/.currentnumcopies{#copies}odef/setcolorscreen where{pop/currentcolorscreen
{.currenthalftone{{60.0 exch 0.0 exch 3 copy 6 copy}{3 copy 6 copy}{}}exch get exec}odef}if/currentscreen{.currenthalftone
{{60.0 exch 0.0 exch}{}{12 3 roll 9{pop}repeat}}exch get exec}odef/.echo/echo load def
userdict/.echo.mode true put/echo{dup/.echo.mode exch store .echo}odef/.eexec_param_dict mark/eexec true/seed 55665
.dicttomark readonly def/eexec{dup//.eexec_param_dict//filterdict/eexecDecode get exec
cvx exch .currentresourcefile eq//systemdict begin{{exec}.execasresource}{exec}ifelse
currentdict//systemdict eq{end}if}odef/.endpage{2 ne}odef/erasepage{/currentcolor where
{pop currentcolor currentcolorspace{setcolorspace setcolor}}{/currentcmykcolor where{pop currentcmykcolor{setcmykcolor}}
{currentrgbcolor{setrgbcolor}}ifelse}ifelse
currentoverprint false setoverprint 1 setgray .fillpage setoverprint
exec}odef/executive{{prompt{(%statementedit)(r).systemvmfile}stopped{pop pop $error/errorname get/undefinedfilename eq
{.clearerror exit}if/handleerror .systemvar exec//null}if
cvx{.runexec}execute}loop}bind def/filter{//filterdict 1 .argindex .knownget{exch pop exec}
{/filter .systemvar/undefined signalerror}ifelse}odef/handleerror
JOBSERVER{{/.GShandleerror .systemvar .internalstopped pop}bind}{
{/errordict .systemvar/handleerror get .internalstopped pop}bind}ifelse def/identmatrix[1.0 0.0 0.0 1.0 0.0 0.0]readonly def
/identmatrix{dup type/arraytype ne{/identmatrix load/typecheck signalerror}if
dup length 6 ne{/identmatrix load/rangecheck signalerror}if
dup 0//identmatrix putinterval}odef/languagelevel 1 def/makeimagedevice{false makewordimagedevice}odef
/matrix{6 array identmatrix}odef/.promptmsg{(GS)print
count 0 ne{(<)print count =only}if(>)print flush}bind def/prompt{flush flushpage NOPROMPT not{.promptmsg}if}bind def
/pstack{0 1 count 3 sub{index ==}for}bind def/putdeviceprops{.putdeviceprops{erasepage}if}odef/quit{/quit load 0 .quit}odef
/run{dup type/filetype ne{(r).systemvmfile}if
cvx null{.runexec}.errorexec}odef/.runexec1{dup type/filetype ne{cvx exec}if
cvx//null 2 .stopped
dup//null ne{exec true}{pop false}ifelse}bind def/.runexec2{exch{.runexec}{dup type/filetype ne{cvx exec}if
closefile}ifelse}bind def/.runexec{cvlit/.runexec1 cvx 1 index/.runexec2 cvx 4 .execn}bind def/setdash{
0 .argindex type dup/integertype eq exch/realtype eq or not{/setdash .systemvar/typecheck signalerror}if
1 .argindex length 11 gt{/setdash .systemvar/limitcheck signalerror}if//setdash}odef/setdevice{.setdevice{mark{currenthalftone
dup type/dicttype eq{sethalftone}{pop}ifelse}stopped
cleartomark
erasepage}if}odef/setlinecap{dup 2 gt{/setlinecap .systemvar/rangecheck signalerror}if
.setlinecap}odef/setlinejoin{dup 2 gt{/setlinejoin .systemvar/rangecheck signalerror}if
.setlinejoin}odef/setmatrix{dup type/arraytype ne{dup type/packedarraytype ne{/setmatrix load/typecheck signalerror}if}if
dup length 6 ne{/setmatrix load/rangecheck signalerror}if
dup aload pop .setmatrix pop}odef/showpage{0 .endpage .doneshowpage{.currentnumcopies true .outputpage
(>>showpage, press <return> to continue<<\n).confirm
initgraphics
currentoverprint false setoverprint 1 setcolor
.fillpage
setoverprint 0 setcolor}{initgraphics}ifelse
systemdict/..page_default_spaces .knownget{//.PurgeDict exec}if
.beginpage}odef/stack{0 1 count 3 sub{index =}for}bind def/start{BATCH{//null 0 .quit}{executive}ifelse}def
/.internalstopped{//null 1 .stopped//null ne}bind def/store{1 .argindex where{2 index 2 index put pop pop}{def}ifelse}odef
/.typenames mark .typenames counttomark packedarray exch pop def/type{//.typenames .type}odef
currentdict/.typenames .undef/version(54.0)readonly def/.wheredict 10 dict def/.where/where load def/where{
//.wheredict 1 .argindex .knownget{exec}{.where}ifelse}odef/.makeinternaldict{.currentglobal true .setglobal
[/dup .systemvar 1183615869/eq .systemvar[/pop .systemvar//null]cvx
false .setglobal
dup 1 10 dict .forceput
true .setglobal[/internaldict/cvx .systemvar/invalidaccess/signalerror cvx]cvx/ifelse .systemvar]cvx executeonly
exch .setglobal}odef
systemdict/internaldict dup .makeinternaldict .makeoperator
.forceput/concatstrings{exch dup length 2 index length add string
dup dup 4 2 roll copy
length 4 -1 roll putinterval}bind def/copyarray{dup length array copy}bind def/.copydict
{dup 3 -1 roll{put dup}forall pop}bind def/copystring{dup length string copy}bind def/findlibfile{
.systemvmlibfile{dup .filename pop exch true}{false}ifelse}odef/.growdictlength{length 3 mul 2 idiv 1 add}bind def/.growdict
{dup .growdictlength .setmaxlength}bind def/.growput{2 index length 3 index maxlength eq
{3 copy pop known not{2 index .growdict}if}if
put}bind def/.localvmarray where{pop}{/.localvmarray{.currentglobal false .setglobal
exch array exch .setglobal}bind def}ifelse/.localvmdict where{pop}{/.localvmdict{.currentglobal false .setglobal
exch dict exch .setglobal}bind def}ifelse/.packtomark{counttomark packedarray exch pop}bind def/ppstack
{0 1 count 3 sub{index ===}for}bind def/runlibfile{findlibfile{exch pop/run .systemvar exec}{/undefinedfilename signalerror}
ifelse}bind def/selectdevice{finddevice setdevice .setdefaultscreen}bind def/signalerror
{/errordict .systemvar exch get exec}bind def/signaloperror{/errordict .systemvar exch get
.finderrorobject{3 -1 roll pop exch}if
exec}bind def/write=only{.writecvs}bind def/write={1 index exch write=only(\n)writestring}bind def
/=only{(%stdout)(w)file exch write=only}bind def/={=only(\n)print}bind def/=print/=only load def/==/= load def/copydevice{
false .copydevice2}odef/finddevice{/devicedict .systemvar exch get
dup 1 get//null eq{.currentglobal true .setglobal exch
dup dup 0 get copydevice 1 exch put
exch .setglobal}if 1 get}bind def/findprotodevice{/devicedict .systemvar exch get 0 get}bind def
userdict/.currentresourcefile//null put/.execasresource{/stopped .systemvar/.currentresourcefile .uservar
.userdict/.currentresourcefile 5 index cvlit put
2 .execn
.userdict/.currentresourcefile 3 -1 roll put{stop}if}bind def/.runresource{{/run .systemvar exec}.execasresource}bind def
/gsgetdeviceprop{2 copy mark exch//null .dicttomark .getdeviceparams
dup mark eq{pop dup/undefined signalerror}{5 1 roll pop pop pop pop}ifelse}bind def/gscurrentresolution
{currentdevice/HWResolution gsgetdeviceprop}bind def/gssetresolution{2 array astore mark exch/HWResolution exch
currentdevice copydevice putdeviceprops setdevice}bind def/shellarguments{/ARGUMENTS where{/ARGUMENTS get dup type/arraytype eq
{aload pop/ARGUMENTS//null store true}{pop false}ifelse}{false}ifelse}bind def/.confirm{DISPLAYING NOPAUSE not TTYPAUSE or and{
NOPAGEPROMPT NOPROMPT or{pop}{print flush}ifelse
.confirmread}{pop}ifelse}bind def/.confirmread{TTYPAUSE{(/dev/tty)(r)file dup read pop pop closefile}{.echo.mode false echo
(%stdin)(r)file dup read{dup(\n)0 get eq{pop pop}{unread}ifelse}{pop}ifelse echo}ifelse}bind def/.execute{
stopped $error/newerror get and{/handleerror .systemvar exec flush true}{false}ifelse}bind def/execute{.execute pop}odef
/execute0{.execute{/execute0 cvx 1 .quit}if}bind def/.runfile{{runlibfile}execute0}def/.runstdin{
{{(%stdin)(r)file cvx}.runexec}execute0}bind def/.runstring{0 0 .systemvmstring .systemvmSFD cvx{.runexec}execute0}bind def
/.runstringbegin{1 .systemvmarray dup 0/.needinput load put cvx
0 0 .systemvmstring .systemvmSFD cvx .runexec}bind def/runlibfile0{cvlit dup dup/.currentfilename exch def
{findlibfile not{stop}if}stopped{(Can't find \(or open\) initialization file )print
.currentfilename == flush/runlibfile0 cvx 1 .quit}if
exch pop cvx{stopped}0 get 3 -1 roll 2 array astore cvx exec/.currentfilename exch store
{(While reading )print .currentfilename print(:\n)print flush/handleerror .systemvar exec/runlibfile0 1 .quit}if}bind def
/.runlibfile/runlibfile load def/runlibfile/runlibfile0 load def/.unstoppederrorhandler{2 copy SHORTERRORS
{(%%[ Error: )print =only flush(; OffendingCommand: )print =only( ]%%)=}{(Unrecoverable error: )print =only flush
( in )print = flush
count 2 gt{(Operand stack:\n  )print
count 1 sub -1 2{(  )print index =only flush}for()= flush}if}ifelse
-1 0 1//ErrorNames length 1 sub{dup//ErrorNames exch get 3 index eq{not exch pop exit}{pop}ifelse}for exch pop .quit}bind def
/.errorhandler{1 .instopped{//null eq{pop pop stop}if}if(I)false .setdebug
$error/.inerror get 1 .instopped{pop}{pop true}ifelse{.unstoppederrorhandler}if
$error/globalmode .currentglobal false .setglobal put
$error/.inerror true put
$error/newerror true put
$error exch/errorname exch put
$error exch/command exch put
$error/errorinfo known not{$error/errorinfo//null put}if
$error/recordstacks get $error/errorname get/VMerror ne and{count array astore dup $error/ostack 4 -1 roll
countexecstack array execstack dup length 2 sub 0 exch getinterval
$error/estack 3 -1 roll
countdictstack array dictstack $error/dstack 3 -1 roll
put put put aload pop}{$error/dstack .undef
$error/estack .undef
$error/ostack .undef}ifelse
$error/position currentfile status{currentfile{fileposition}.internalstopped{pop//null}if}{
$error/command get dup type/filetype eq{{fileposition}.internalstopped{pop//null}if}{pop//null}ifelse}ifelse put
$error/globalmode get $error/.nosetlocal get and .setglobal
$error/.inerror false put
stop}bind def/.printerror{$error begin newerror{/command load errorname SHORTERRORS{(%%[ Error: )print =only flush
(; OffendingCommand: )print =only
errorinfo dup//null eq{pop}{(;\nErrorInfo:)print
dup type/arraytype eq{{( )print =only}forall}{( )print =only}ifelse}ifelse( ]%%)= flush}{(Error: )print ==only flush
( in )print ==only flush
errorinfo dup//null eq{pop}{(\nAdditional information: )print ==only flush}ifelse
.printerror_long}ifelse
.clearerror flush}{//JOBSERVER{/errordict .systemvar/handleerror get/.GShandleerror .systemvar ne}{false}ifelse
{/errordict .systemvar begin/handleerror load .internalstopped pop end}if}ifelse
end
flush}bind def/.printerror_long{{currentdict exch .knownget{4 1 roll/errordict .systemvar exch .knownget{exch pop exch pop exec
}{exch print exch
1 index not{()=}if{1 index{(\n    )}{(   )}ifelse print
dup type/dicttype eq{(--dict:)print
dup rcheck{dup length =only(/)print dup maxlength =only
dup wcheck not{((ro))print}if}if/gcheck where{pop gcheck{((G))}{((L))}ifelse print}{pop}ifelse(--)print}{
dup type/stringtype eq 2 index or{==only}{=only}ifelse}ifelse}forall
pop}ifelse}{pop pop pop}ifelse}(\nOperand stack:)OSTACKPRINT/.printostack/ostack 4 index exec
(\nExecution stack:)ESTACKPRINT/.printestack/estack 4 index exec(\nBacktrace:)true/.printbacktrace/backtrace 4 index exec
(\nDictionary stack:)false/.printdstack/dstack 4 index exec()=
pop
errorname/VMerror eq{(VM status:)print mark vmstatus
counttomark{( )print counttomark -1 roll dup =only}repeat
cleartomark()=}if
.languagelevel 2 ge{(Current allocation mode is )print
globalmode{(global\n)}{(local\n)}ifelse print}if
.oserrno dup 0 ne{(Last OS error: )print
errorname/VMerror ne{dup .oserrorstring{= pop}{=}ifelse}{=}ifelse}{pop}ifelse
position//null ne{(Current file position is )print position =}if}bind def/.clearerror{$error/newerror false put
$error/errorname//null put
$error/errorinfo//null put
0 .setoserrno}bind def
.currentglobal false .setglobal/$error 40 dict .forcedef
$error begin/newerror false def/recordstacks true def/binary false def/globalmode .currentglobal def/.inerror false def
/.nosetlocal true def/position//null def/errorinfo//null def
end/errordict ErrorNames length 3 add dict
.forcedef
.setglobal/gserrordict 5 dict def/.registererror{errordict exch .registererror2}bind def/.registererror2
{.currentglobal true .setglobal
3 1 roll
mark 1 index systemdict/.errorhandler get/exec load .packtomark cvx put
.setglobal}bind def
ErrorNames{dup .registererror/VMerror eq{exit}if}forall
errordict begin{/interrupt/timeout}{mark 1 index dup systemdict/.errorhandler get/exec load .packtomark cvx def}forall
/handleerror{/.printerror .systemvar exec}bind def
end
gserrordict/unknownerror errordict/unknownerror get put
errordict/unknownerror .undef/.GShandleerror errordict/handleerror get def/.dict 8 dict dup
begin def/.cvp{1 index exch 1 .writecvp}bind def/.p{1 index exch writestring}bind def/.p1{2 index exch writestring}bind def
/.p2{3 index exch writestring}bind def/.print{dup type .dict exch .knownget{exec}{.cvp}ifelse}bind def/arraytype{dup rcheck
{()exch dup xcheck{({).p2{exch .p1
1 index exch .print pop( )}forall(})}{([).p2{exch .p1
1 index exch .print pop( )}forall(])}ifelse exch pop .p}{.cvp}ifelse}bind def/packedarraytype/arraytype load def
{//.dict begin .print pop end}bind
end/write==only exch def/write=={1 index exch write==only(\n)writestring}bind def
/==only{(%stdout)(w)file exch write==only}bind def/=={==only(\n)print}bind def
/.dict/write==only load 0 get dup length 2 add dict .copydict dup
begin def/dicttype{dup rcheck{(<< ).p1{2 index 3 -1 roll .print pop( ).p1
1 index exch .print pop( ).p}forall(>>).p}{.cvp}ifelse}bind def/stringtype{1 index exch 2 .writecvp}bind def
{//.dict begin .print pop end}bind
end/write===only exch def/write==={1 index exch write===only(\n)writestring}bind def
/===only{(%stdout)(w)file exch write===only}bind def/==={===only(\n)print}bind def/.delayed_init_queue 10 dict def
/.schedule_init{//.delayed_init_queue 2 index known{(.delayed_init_queue priority conflict with )print 1 index =
/.schedule_init cvx/configurationerror signalerror}if//.delayed_init_queue 3 1 roll .growput}bind def/.execute_scheduled_inits{
{0//null//.delayed_init_queue{3 index 2 index lt{4 2 roll}if
pop pop}forall
exch//.delayed_init_queue exch undef
dup//null eq{pop exit}if
exec}loop}bind def(END PROCS)VMDEBUG/FontDirectory false .setglobal 100 dict true .setglobal
.forcedef/EncodingDirectory 16 dict def/.findencoding{//EncodingDirectory exch get exec}bind def/.defineencoding
{//EncodingDirectory 3 1 roll put}bind def/rootfont where{pop/findencoding{.findencoding}def}if/.registerencoding{pop pop
}bind odef
/StandardEncoding/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/space/exclam/quotedbl/numbersign
/dollar/percent/ampersand/quoteright/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash/zero/one/two/three
/four/five/six/seven/eight/nine/colon/semicolon/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W
/X/Y/Z/bracketleft/backslash/bracketright/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w
/x/y/z/braceleft/bar/braceright/asciitilde/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/exclamdown/cent/sterling/fraction/yen/florin/section
/currency/quotesingle/quotedblleft/guillemotleft/guilsinglleft/guilsinglright/fi/fl/.notdef/endash/dagger/daggerdbl
/periodcentered/.notdef/paragraph/bullet/quotesinglbase/quotedblbase/quotedblright/guillemotright
/ellipsis/perthousand/.notdef/questiondown/.notdef/grave/acute/circumflex/tilde/macron/breve/dotaccent
/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut/ogonek/caron/emdash/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/AE/.notdef/ordfeminine/.notdef/.notdef/.notdef/.notdef
/Lslash/Oslash/OE/ordmasculine/.notdef/.notdef/.notdef/.notdef/.notdef/ae/.notdef/.notdef/.notdef/dotlessi/.notdef/.notdef
/lslash/oslash/oe/germandbls/.notdef/.notdef/.notdef/.notdef
256
vmstatus exch pop exch pop
100000 ge{array astore readonly}{packedarray}ifelse
def
0 StandardEncoding .registerencoding/StandardEncoding StandardEncoding .defineencoding
/ISOLatin1Encoding
StandardEncoding 0 45 getinterval aload pop/minus
StandardEncoding 46 82 getinterval aload pop/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve/dotaccent
/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar/section
/dieresis/copyright/ordfeminine/guillemotleft/logicalnot/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine/guillemotright
/onequarter/onehalf/threequarters/questiondown/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis/Eth/Ntilde/Ograve/Oacute
/Ocircumflex/Otilde/Odieresis/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute/Thorn/germandbls
/agrave/aacute/acircumflex/atilde/adieresis/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis
/igrave/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex/otilde/odieresis/divide
/oslash/ugrave/uacute/ucircumflex/udieresis/yacute/thorn/ydieresis
256
vmstatus exch pop exch pop
100000 ge{array astore readonly}{packedarray}ifelse
def
1 ISOLatin1Encoding .registerencoding/ISOLatin1Encoding ISOLatin1Encoding .defineencoding
/SymbolEncoding{/SymbolEncoding .findencoding}bind def
/currentglobal where{pop currentglobal{setglobal}true setglobal}{{}}ifelse/SymbolEncoding
StandardEncoding 0 32 getinterval aload pop/space/exclam/universal/numbersign/existential/percent/ampersand/suchthat
/parenleft/parenright/asteriskmath/plus/comma/minus/period/slash/zero/one/two/three/four/five/six/seven
/eight/nine/colon/semicolon/less/equal/greater/question/congruent/Alpha/Beta/Chi/Delta/Epsilon/Phi/Gamma/Eta/Iota/theta1/Kappa
/Lambda/Mu/Nu/Omicron/Pi/Theta/Rho/Sigma/Tau/Upsilon/sigma1/Omega/Xi/Psi/Zeta/bracketleft
/therefore/bracketright/perpendicular/underscore/radicalex/alpha/beta/chi/delta/epsilon/phi/gamma/eta/iota/phi1/kappa
/lambda/mu/nu/omicron/pi/theta/rho/sigma/tau/upsilon/omega1/omega/xi/psi/zeta/braceleft/bar/braceright/similar/.notdef
StandardEncoding 0 32 getinterval aload pop/Euro/Upsilon1/minute/lessequal/fraction/infinity/florin/club
/diamond/heart/spade/arrowboth/arrowleft/arrowup/arrowright/arrowdown/degree/plusminus/second/greaterequal
/multiply/proportional/partialdiff/bullet/divide/notequal/equivalence/approxequal
/ellipsis/arrowvertex/arrowhorizex/carriagereturn/aleph/Ifraktur/Rfraktur/weierstrass
/circlemultiply/circleplus/emptyset/intersection/union/propersuperset/reflexsuperset/notsubset
/propersubset/reflexsubset/element/notelement/angle/gradient/registerserif/copyrightserif
/trademarkserif/product/radical/dotmath/logicalnot/logicaland/logicalor/arrowdblboth
/arrowdblleft/arrowdblup/arrowdblright/arrowdbldown/lozenge/angleleft/registersans/copyrightsans
/trademarksans/summation/parenlefttp/parenleftex/parenleftbt/bracketlefttp/bracketleftex/bracketleftbt
/bracelefttp/braceleftmid/braceleftbt/braceex/.notdef/angleright/integral/integraltp
/integralex/integralbt/parenrighttp/parenrightex/parenrightbt/bracketrighttp/bracketrightex/bracketrightbt
/bracerighttp/bracerightmid/bracerightbt/.notdef
256 packedarray .defineencoding
2 SymbolEncoding .registerencoding
exec
/DingbatsEncoding{/DingbatsEncoding .findencoding}bind def
/currentglobal where{pop currentglobal{setglobal}true setglobal}{{}}ifelse/DingbatsEncoding
StandardEncoding 0 32 getinterval aload pop/space/a1/a2/a202/a3/a4/a5/a119/a118/a117/a11/a12/a13/a14/a15/a16
/a105/a17/a18/a19/a20/a21/a22/a23/a24/a25/a26/a27/a28/a6/a7/a8/a9/a10/a29/a30/a31/a32/a33/a34/a35/a36/a37/a38/a39/a40/a41/a42
/a43/a44/a45/a46/a47/a48/a49/a50/a51/a52/a53/a54/a55/a56/a57/a58/a59/a60/a61/a62/a63/a64/a65/a66
/a67/a68/a69/a70/a71/a72/a73/a74/a203/a75/a204/a76/a77/a78/a79/a81/a82/a83/a84/a97/a98/a99/a100/.notdef
StandardEncoding 0 32 getinterval aload pop/.notdef/a101/a102/a103/a104/a106/a107/a108/a112/a111/a110/a109/a120/a121/a122/a123
/a124/a125/a126/a127/a128/a129/a130/a131/a132/a133/a134/a135/a136/a137/a138/a139/a140/a141/a142/a143/a144/a145/a146/a147
/a148/a149/a150/a151/a152/a153/a154/a155/a156/a157/a158/a159/a160/a161/a163/a164/a196/a165/a192/a166/a167/a168/a169/a170
/a171/a172/a173/a162/a174/a175/a176/a177/a178/a179/a193/a180/a199/a181/a200/a182/.notdef/a201/a183/a184/a197/a185/a194/a198
/a186/a195/a187/a188/a189/a190/a191/.notdef
256 packedarray .defineencoding
3 DingbatsEncoding .registerencoding
exec
(END FONTDIR/ENCS)VMDEBUG
errordict/rangecheck 2 copy get
errordict/rangecheck{pop stop}put
0{{dup .getdevice exch 1 add}loop}.internalstopped pop
1 add dict/devicedict 1 index def
begin{dup .devicename exch
dup wcheck{dup}{//null}ifelse 2 array astore def}repeat
end
put
.clearerror/devicenames devicedict{pop}forall devicedict length packedarray def/defaultdevice DISPLAYING
{systemdict/DEVICE .knownget{devicedict 1 index known not{(Unknown device: )print =
flush/defaultdevice cvx 1 .quit}if}{.getdefaultdevice .devicename}ifelse}{/nullpage}ifelse/.defaultdevicename 1 index def
finddevice
def
devicedict/Default devicedict .defaultdevicename get put(END DEVS)VMDEBUG
systemdict begin
.currentglobal false .setglobal/statusdict 89 dict .forcedef/serverdict 10 dict .forcedef
.setglobal
end/.setpagesize{/statusdict .systemvar begin .setpagesize end}bind def
userdict begin/11x17{792 1224//.setpagesize exec}bind def/a3{842 1191//.setpagesize exec}bind def
/a4{595 842//.setpagesize exec}bind def/a4small/a4 load def/ledger{1224 792//.setpagesize exec}bind def
/legal{612 1008//.setpagesize exec}bind def/letter{612 792//.setpagesize exec}bind def/lettersmall/letter load def
/note/letter load def
STRICT{(%END SIZES).skipeof}if/a0{2384 3370//.setpagesize exec}bind def/a1{1684 2384//.setpagesize exec}bind def
/a2{1191 1684//.setpagesize exec}bind def/a5{420 595//.setpagesize exec}bind def/a6{297 420//.setpagesize exec}bind def
/a7{210 297//.setpagesize exec}bind def/a8{148 210//.setpagesize exec}bind def/a9{105 148//.setpagesize exec}bind def
/a10{73 105//.setpagesize exec}bind def/isob0{2835 4008//.setpagesize exec}bind def/b0/isob0 load def
/isob1{2004 2835//.setpagesize exec}bind def/b1/isob1 load def/isob2{1417 2004//.setpagesize exec}bind def/b2/isob2 load def
/isob3{1001 1417//.setpagesize exec}bind def/b3/isob3 load def/isob4{709 1001//.setpagesize exec}bind def/b4/isob4 load def
/isob5{499 709//.setpagesize exec}bind def/b5/isob5 load def/isob6{354 499//.setpagesize exec}bind def/b6/isob6 load def
/jisb0{2920 4127//.setpagesize exec}bind def/jisb1{2064 2920//.setpagesize exec}bind def
/jisb2{1460 2064//.setpagesize exec}bind def/jisb3{1032 1460//.setpagesize exec}bind def
/jisb4{729 1032//.setpagesize exec}bind def/jisb5{516 729//.setpagesize exec}bind def/jisb6{363 516//.setpagesize exec}bind def
/c0{2599 3677//.setpagesize exec}bind def/c1{1837 2599//.setpagesize exec}bind def/c2{1298 1837//.setpagesize exec}bind def
/c3{918 1298//.setpagesize exec}bind def/c4{649 918//.setpagesize exec}bind def/c5{459 649//.setpagesize exec}bind def
/c6{323 459//.setpagesize exec}bind def/archE{2592 3456//.setpagesize exec}bind def/archD{1728 2592//.setpagesize exec}bind def
/archC{1296 1728//.setpagesize exec}bind def/archB{864 1296//.setpagesize exec}bind def
/archA{648 864//.setpagesize exec}bind def/flsa{612 936//.setpagesize exec}bind def/flse{612 936//.setpagesize exec}bind def
/halfletter{396 612//.setpagesize exec}bind def/pa4{595 792//.setpagesize exec}bind def
%END SIZES
end
currentdict/.setpagesize .undef
statusdict begin/.pagetypenames[/letter/note/legal/lettersmall/11x17/ledger/a4small/a3/a4
STRICT{(%END SIZES).skipeof}if/a0/a1/a2/a5/a6/a7/a8/a9/a10/archA/archB/archC/archD/archE/b0/b1/b2/b3/b4/b5/b6
/c0/c1/c2/c3/c4/c5/c6/flsa/flse/halfletter/isob0/isob1/isob2/isob3/isob4/isob5/isob6/jisb0/jisb1/jisb2/jisb3/jisb4/jisb5/jisb6
/pa4
%END SIZES
]cvlit readonly def/ramsize 4194304 def/hardwareiomode 0 def/sethardwareiomode{pop}bind def/softwareiomode 0 def
/setsoftwareiomode{pop}bind def/dosysstart false def/setdosysstart{pop}bind def/allowjobreset true def
/setallowjobreset{pop}bind def/defaultpaperfamily 0 def/setdefaultpaperfamily{pop}bind def/defaultpapertray 0 def
/setdefaultpapertray{pop}bind def/defaulttrayswitch false def/setdefaulttrayswitch{pop}bind def
/11x17tray{/11x17 .uservar exec}bind def/a3tray{/a3 .uservar exec}bind def/a4tray{/a4 .uservar exec}bind def
/a5tray{/a5 .uservar exec}bind def/a6tray{/a6 .uservar exec}bind def/b4tray{/b4 .uservar exec}bind def
/b5tray{/b5 .uservar exec}bind def/flsatray{/flsa .uservar exec}bind def/flsetray{/flse .uservar exec}bind def
/halflettertray{/halfletter .uservar exec}bind def/ledgertray{/ledger .uservar exec}bind def
/legaltray{/legal .uservar exec}bind def/lettertray{/letter .uservar exec}bind def/paperfamily 0 def/papertray 1 def
/setpapertray{statusdict exch/papertray exch put}bind def/trayswitch false def/appletalktype(LaserWriter)def
/checkpassword{statusdict begin .password eq end}bind def/defaulttimeouts{statusdict begin .timeouts aload pop end}bind def
/diskonline{false(%disk*%){pop not exit}8192 string/IODevice resourceforall}bind def/diskstatus{10240 2097152}bind odef
/eescratch{pop 0}bind def/idlefonts{statusdict begin mark .idlefonts aload pop end}bind def/jobname()def/manualfeed false def
/manualfeedtimeout 60 def/margins{statusdict begin .topmargin .leftmargin end}bind def/pagecount{4711}bind def
/pagestackorder{false}bind def/pagetype 0 def/prefeed false def/printererror{pop pop}bind def
/printername{statusdict/.printername get exch copy}bind def/processcolors/processcolors load def/product product def
/revision revision def/sccbatch{pop 9600 0}bind def/sccinteractive{pop 9600 0}bind def
/setdefaulttimeouts{statusdict begin .timeouts astore pop end}bind def
/setdostartpage{statusdict exch/dostartpage exch put}bind def
/setduplexmode{mark/Duplex 3 -1 roll currentdevice putdeviceprops}bind def/seteescratch{pop pop}bind def
/setidlefonts{]statusdict exch/.idlefonts exch put}bind def/setjobtimeout{statusdict exch/jobtimeout exch put}bind def
/setmargins{statusdict begin/.leftmargin exch def/.topmargin exch def
end}bind def/pagemargin{0}bind def/pageparams{currentdevice 1 dict dup/.MediaSize dup put .getdeviceparams
exch pop exch pop aload pop 0 ORIENT1{1}{0}ifelse}bind def/setpage{ORIENT1{1}{0}ifelse ne{exch}if
statusdict/.setpagesize get exec}bind def/setpagemargin{pop}bind def/setpageparams{exch pop ORIENT1{1}{0}ifelse ne{exch}if
statusdict/.setpagesize get exec}bind def/setpagetype{statusdict begin
dup .pagetypenames 0 2 getinterval exch get//systemdict/userdict get exch get cvx exec/pagetype exch def
end}bind def/setpassword{exch checkpassword{statusdict exch/.password exch put true}{pop false}ifelse}bind def/setprintername
{dup length string copy statusdict exch/.printername exch put}bind def/setresolution
{mark/HWResolution[4 -1 roll dup]currentdevice putdeviceprops pop
initmatrix erasepage}bind def/setsccbatch{pop pop pop}bind def/setsccinteractive{pop pop pop}bind def/settumble{pop}bind def
/waittimeout 300 def/.setpagesize{mark/HWSize[4 index 4 index matrix defaultmatrix dtransform
abs ceiling cvi exch abs ceiling cvi exch]currentdevice putdeviceprops pop pop pop
initmatrix initclip erasepage}bind def/.password 0 def/.timeouts[0 60 30]def
true setdostartpage
mark setidlefonts
0 setjobtimeout
0 0 setmargins
product setprintername
end
systemdict begin
.currentglobal true .setglobal/devformat true def/devforall{exch{1 index currentdevparams
/Type .knownget{/FileSystem eq}{false}ifelse{exec}{pop pop}ifelse}/exec load 3 packedarray cvx exch
(*)3 1 roll/IODevice resourceforall}odef/devstatus{dup length 5 ge{dup 0 5 getinterval(%disk)eq{dup/IODevice resourcestatus{
pop pop dup currentdevparams
dup/Searchable get
exch dup/Writeable get
exch dup/HasNames get
exch dup/Mounted get
exch dup/Removable get
exch dup/SearchOrder get
exch dup/Free get
exch/LogicalSize get
9 -1 roll pop true}{pop false}ifelse}{pop false}ifelse}{pop false}ifelse}odef
.setglobal end
serverdict begin/execjob{}bind def/exitserver{clear stop}bind def/exitserver{0 ne{clear cleardictstack}if}bind def
/setrealdevice{}bind def
end
(END STATD)VMDEBUG
/defaultfontname/Courier def/defaultfontmap(Fontmap)def/defaultfontmap_content 50 dict
1 dict begin/;{2 index 3 1 roll .growput}bind def
/URWBookmanL-DemiBold(b018015l.pfb);/URWBookmanL-DemiBoldItal(b018035l.pfb);/URWBookmanL-Ligh(b018012l.pfb);
/URWBookmanL-LighItal(b018032l.pfb);/NimbusMonL-Regu(n022003l.pfb);/NimbusMonL-ReguObli(n022023l.pfb);
/NimbusMonL-Bold(n022004l.pfb);/NimbusMonL-BoldObli(n022024l.pfb);/URWGothicL-Book(a010013l.pfb);
/URWGothicL-BookObli(a010033l.pfb);/URWGothicL-Demi(a010015l.pfb);/URWGothicL-DemiObli(a010035l.pfb);
/NimbusSanL-Regu(n019003l.pfb);/NimbusSanL-ReguItal(n019023l.pfb);/NimbusSanL-Bold(n019004l.pfb);
/NimbusSanL-BoldItal(n019024l.pfb);/NimbusSanL-ReguCond(n019043l.pfb);/NimbusSanL-ReguCondItal(n019063l.pfb);
/NimbusSanL-BoldCond(n019044l.pfb);/NimbusSanL-BoldCondItal(n019064l.pfb);/URWPalladioL-Roma(p052003l.pfb);
/URWPalladioL-Ital(p052023l.pfb);/URWPalladioL-Bold(p052004l.pfb);/URWPalladioL-BoldItal(p052024l.pfb);
/CenturySchL-Roma(c059013l.pfb);/CenturySchL-Ital(c059033l.pfb);/CenturySchL-Bold(c059016l.pfb);
/CenturySchL-BoldItal(c059036l.pfb);/NimbusRomNo9L-Regu(n021003l.pfb);/NimbusRomNo9L-ReguItal(n021023l.pfb);
/NimbusRomNo9L-Medi(n021004l.pfb);/NimbusRomNo9L-MediItal(n021024l.pfb);/StandardSymL(s050000l.pfb);
/URWChanceryL-MediItal(z003034l.pfb);/Dingbats(d050000l.pfb);/Bookman-Demi/URWBookmanL-DemiBold	;
/Bookman-DemiItalic/URWBookmanL-DemiBoldItal	;/Bookman-Light/URWBookmanL-Ligh	;/Bookman-LightItalic/URWBookmanL-LighItal	;
/Courier/NimbusMonL-Regu	;/Courier-Oblique/NimbusMonL-ReguObli	;/Courier-Bold/NimbusMonL-Bold	;
/Courier-BoldOblique/NimbusMonL-BoldObli	;/AvantGarde-Book/URWGothicL-Book	;/AvantGarde-BookOblique/URWGothicL-BookObli	;
/AvantGarde-Demi/URWGothicL-Demi	;/AvantGarde-DemiOblique/URWGothicL-DemiObli	;/Helvetica/NimbusSanL-Regu	;
/Helvetica-Oblique/NimbusSanL-ReguItal	;/Helvetica-Bold/NimbusSanL-Bold	;/Helvetica-BoldOblique/NimbusSanL-BoldItal	;
/Helvetica-Narrow/NimbusSanL-ReguCond	;/Helvetica-Narrow-Oblique/NimbusSanL-ReguCondItal	;
/Helvetica-Narrow-Bold/NimbusSanL-BoldCond	;/Helvetica-Narrow-BoldOblique/NimbusSanL-BoldCondItal	;
/Palatino-Roman/URWPalladioL-Roma	;/Palatino-Italic/URWPalladioL-Ital	;/Palatino-Bold/URWPalladioL-Bold	;
/Palatino-BoldItalic/URWPalladioL-BoldItal	;/NewCenturySchlbk-Roman/CenturySchL-Roma	;
/NewCenturySchlbk-Italic/CenturySchL-Ital	;/NewCenturySchlbk-Bold/CenturySchL-Bold	;
/NewCenturySchlbk-BoldItalic/CenturySchL-BoldItal	;/Times-Roman/NimbusRomNo9L-Regu	;/Times-Italic/NimbusRomNo9L-ReguItal	;
/Times-Bold/NimbusRomNo9L-Medi	;/Times-BoldItalic/NimbusRomNo9L-MediItal	;/Symbol/StandardSymL	;
/ZapfChancery-MediumItalic/URWChanceryL-MediItal	;/ZapfDingbats/Dingbats	;/CharterBT-Roman(bchr.pfa);
/CharterBT-Italic(bchri.pfa);/CharterBT-Bold(bchb.pfa);/CharterBT-BoldItalic(bchbi.pfa);/Charter-Roman/CharterBT-Roman	;
/Charter-Italic/CharterBT-Italic	;/Charter-Bold/CharterBT-Bold	;/Charter-BoldItalic/CharterBT-BoldItalic	;
/Utopia-Regular(putr.pfa);/Utopia-Italic(putri.pfa);/Utopia-Bold(putb.pfa);/Utopia-BoldItalic(putbi.pfa);
/URWAntiquaT-RegularCondensed(u003043t.gsf);/URWGroteskT-Bold(u004006t.gsf);/Calligraphic-Hiragana(fhirw.gsf);
/Calligraphic-Katakana(fkarw.gsf);/Shareware-Cyrillic-Regular(fcyr.gsf);/Shareware-Cyrillic-Italic(fcyri.gsf);
/Cyrillic/Cyrillic-Regular	;/Cyrillic-Regular/Shareware-Cyrillic-Regular	;/Cyrillic-Italic/Shareware-Cyrillic-Italic	;
/Hershey-Gothic-English(hrger.pfa);/Hershey-Gothic-German(hrgrr.pfa);/Hershey-Gothic-Italian(hritr.pfa);
/Hershey-Plain-Duplex(hrpld.pfa);/Hershey-Plain-Duplex-Italic(hrpldi.pfa);/Hershey-Plain-Triplex(hrplt.pfa);
/Hershey-Plain-Triplex-Italic(hrplti.pfa);/Hershey-Script-Complex(hrscc.pfa);/Hershey-Script-Simplex(hrscs.pfa);
/Hershey-Gothic-English-Bold(hrgerb.gsf);/Hershey-Gothic-English-Oblique(hrgero.gsf);
/Hershey-Gothic-English-SemiBold(hrgerd.gsf);/Hershey-Gothic-German-Bold(hrgrrb.gsf);
/Hershey-Gothic-German-Oblique(hrgrro.gsf);/Hershey-Gothic-Italian-Bold(hritrb.gsf);
/Hershey-Gothic-Italian-Oblique(hritro.gsf);/Hershey-Plain-Duplex-Bold(hrpldb.gsf);
/Hershey-Plain-Duplex-Bold-Italic(hrpldbi.gsf);/Hershey-Plain-Triplex-Bold(hrpltb.gsf);
/Hershey-Plain-Triplex-Bold-Italic(hrpltbi.gsf);/Hershey-Script-Complex-Bold(hrsccb.gsf);
/Hershey-Script-Complex-Oblique(hrscco.gsf);/Hershey-Script-Simplex-Bold(hrscsb.gsf);
/Hershey-Script-Simplex-Oblique(hrscso.gsf);/Hershey-Greek-Complex(hrgkc.gsf);/Hershey-Greek-Simplex(hrgks.gsf);
/Hershey-Plain(hrplr.gsf);/Hershey-Plain-Simplex(hrpls.gsf);/Hershey-Plain-Bold(hrplrb.gsf);
/Hershey-Plain-Bold-Oblique(hrplrbo.gsf);/Hershey-Plain-Oblique(hrplro.gsf);/Hershey-Plain-Simplex-Bold(hrplsb.gsf);
/Hershey-Plain-Simplex-Bold-Oblique(hrplsbo.gsf);/Hershey-Plain-Simplex-Oblique(hrplso.gsf);/Hershey-Symbol(hrsyr.gsf);
/Arial/ArialMT	;/Arial,Bold/Arial-BoldMT	;/Arial,Italic/Arial-ItalicMT	;/Arial,BoldItalic/Arial-BoldItalicMT	;
/TimesNewRoman/TimesNewRomanPSMT	;/TimesNewRoman,Bold/TimesNewRomanPS-BoldMT	;/TimesNewRoman,Italic/TimesNewRomanPS-ItalicMT	;
/TimesNewRoman,BoldItalic/TimesNewRomanPS-BoldItalicMT	;
end def/AladdinEnterprisesXUID 107 def/SUBSTFONT where{pop/defaultfontname/SUBSTFONT load def}if/.FontDirectory
{/FontDirectory .systemvar}.bind odef/FontFileDirectory 10 dict def/.fonttempstring 8192 string def/.pathlist
{{dup length 0 eq{pop exit}if
.filenamelistseparator search not{exit}if
exch pop exch}loop}bind def
userdict/Fontmap .FontDirectory maxlength dict put/.loadFontmap{50 dict exch .readFontmap{.definefontmap}forall}bind def
/.readFontmap{{dup token not{closefile exit}if
dup(\032)eq{pop closefile exit}if
1 index token not{(Fontmap entry for )print dup =only( has no associated file or alias name!  Giving up.)= flush
{.readFontmap}0 get 1 .quit}if
dup type dup/stringtype eq exch/nametype eq or not{(Fontmap entry for )print 1 index =only
( has an invalid file or alias name!  Giving up.)= flush{.readFontmap}0 get 1 .quit}if
1 index type/stringtype eq
1 index type/nametype eq and 1 index xcheck and
1 index/run eq 2 index/.runlibfile eq or and{pop findlibfile{exch pop}{file}ifelse
2 index exch .readFontmap pop}{{2 index token not{(Fontmap entry for )print 1 index =only
( ends prematurely!  Giving up.)= flush{.loadFontmap}0 get 1 .quit}if
dup/; eq{pop 3 index 3 1 roll .growput exit}if
pop}loop}ifelse}loop}bind def/.definefontmap{1 index 100 string cvs
dup length 0 gt{0 get 0 eq 1 index type/nametype ne and{1 index 100 string cvs dup length 2 div cvi string true exch
0 1 2 index length 1 sub{dup 4 index exch 2 mul get 0 ne{pop pop false exch
exit}if
dup 4 index exch 2 mul 1 add get 2 index 3 1 roll put}for
exch{DEBUG{(\nAdding alias for: )print 1 index ==only( as: )print dup == flush}if
cvn exch cvn .definefontmap}{pop pop}ifelse}if}{pop}ifelse
.currentglobal 3 1 roll true .setglobal
dup type/stringtype eq{dup .gcheck not{dup length string copy}if}if
Fontmap 3 -1 roll 2 copy .knownget{mark exch aload pop counttomark 4 add -1 roll
2 copy eq{cleartomark pop pop}{]readonly .growput}ifelse}{mark 4 -1 roll]readonly .growput}ifelse .setglobal}bind def
/.findfontvalue{exch dup read{2 copy unread 16#80 eq{dup(xxxxxx)readstring pop pop}if{dup{token}stopped{pop false exit}if
not{false exit}if
dup/eexec eq{pop false exit}if
dup/Subrs eq{pop false exit}if
dup/CharStrings eq{pop false exit}if
dup 3 index eq{xcheck not{dup token exit}if}{pop}ifelse}loop
dup{4}{3}ifelse -2 roll closefile pop}{closefile pop false}ifelse}bind def/.findfontname{/FontName .findfontvalue}bind def
NOFONTPATH{/FONTPATH()def}if/FONTPATH where{pop}{/FONTPATH(GS_FONTPATH)getenv not{()}if def}ifelse
FONTPATH length 0 eq{(%END FONTPATH).skipeof}if/FONTPATH[FONTPATH .pathlist]def/.lowerstring{0 1 2 index length 1 sub
{2 copy get dup 65 ge exch 90 le and{2 copy 2 copy get 32 add put}if pop}for}bind def/.splitfilename{readonly{
(/)search{true}{(\\)search}ifelse{pop pop}{exit}ifelse}loop
dup{(.)search{pop pop}{exit}ifelse}loop
2 copy eq{pop()}{exch dup length 2 index length 1 add sub 0 exch getinterval exch}ifelse}bind def/.scanfontdict 1 dict def
/.scanfontbegin{currentglobal true setglobal
.scanfontdict dup maxlength Fontmap length 2 add .max .setmaxlength
Fontmap{exch pop{dup type/stringtype eq{.splitfilename pop .fonttempstring copy .lowerstring cvn
.scanfontdict exch true put}{pop}ifelse}forall}forall
setglobal}bind def/.scanfontskip mark/afm true/bat true/c true/cmd true/com true/dir true/dll true/doc true/drv true/exe true
/fon true/fot true/h true/o true/obj true/pfm true/pss true/txt true
.dicttomark def/.scan1fontstring 8192 string def/.scanfontheaders[(%!PS-Adobe*)(%!FontType*)(%%BeginFont:*)]def
0 .scanfontheaders{length .max}forall 6 add/.scan1fontfirst exch string def/.scanfontdir{currentglobal exch true setglobal
QUIET not{(Scanning )print dup print( for fonts...)print flush}if[1 index](*).generate_dir_list_templates
0 0 0 4 -1 roll{exch 1 add exch
dup .splitfilename .fonttempstring copy .lowerstring
.scanfontskip exch known exch .scanfontdict exch known or{pop}{3 -1 roll 1 add 3 1 roll
dup(r){file}.internalstopped{pop pop null()}{dup .scan1fontfirst{readstring}.internalstopped{pop pop()}{pop}ifelse}ifelse
dup(\200\001????*).stringmatch{dup length 6 sub 6 exch getinterval}if
false .scanfontheaders{2 index exch .stringmatch or}forall exch pop{dup 0 setfileposition .findfontname{dup Fontmap exch known
{pop pop}{exch copystring exch
DEBUG{( )print dup =only flush}if
1 index .definefontmap
.splitfilename pop true .scanfontdict 3 1 roll .growput
3 -1 roll 1 add 3 1 roll}ifelse}{pop}ifelse}{dup null eq{pop}{closefile}ifelse pop}ifelse}ifelse}
.scan1fontstring filenameforall
QUIET{pop pop pop}{( )print =only( files, )print =only( scanned, )print
=only( new fonts.)= flush}ifelse
pop
setglobal}bind def
%END FONTPATH
/.setnativefontmapbuilt{systemdict exch/.nativefontmapbuilt exch .forceput}.bind executeonly def
false .setnativefontmapbuilt/.buildnativefontmap{QUIET not{(Querying operating system for font files...\n)print flush}if
.getnativefonts dup{exch{dup 1 get(r){file}stopped{pop pop pop}{.findfontname
not{dup 0 get}if
1 index exch 0 exch dup type/nametype ne{cvn}if put
aload pop .definefontmap}ifelse}forall}if
true .setnativefontmapbuilt}bind def/buildfontdict 20 dict def
buildfontdict 3/.buildfont3 cvx put/.buildfont0 where{pop buildfontdict 0/.buildfont0 cvx put}if/.growfontdict{
dup maxlength 1 index length sub 2 lt{dup dup wcheck{.growdict}{.growdictlength dict .copydict}ifelse}
{dup wcheck not{dup maxlength dict .copydict}if}ifelse}bind def/.completefont{{NOPLATFONTS{.growfontdict dup/ExactSize 0 put}{
dup/Encoding .knownget{dup length 65 ge{64 get
dup/congruent eq{SymbolEncoding pop}if/a9 eq{DingbatsEncoding pop}if}{pop}ifelse}if}ifelse
dup/OrigFont known not{dup dup/OrigFont exch .growput}if
true exch
dup/CIDFontType known{/.buildcidfont where{pop exch not exch}if}if
exch{dup/FontType get//buildfontdict exch get}{{.buildcidfont}}ifelse}stopped{$error/command get/invalidfont signalerror}if
exec{DISKFONTS{FontFileDirectory 2 index known{dup/FontFile FontFileDirectory 4 index get .growput}if}if
systemdict/ProvideUnicode .knownget not{false}if{/FontEmulationProcs/ProcSet findresource/ProvideUnicodeDecoding get exec}if
readonly}stopped{$error/command get/invalidfont signalerror}if}bind def/definefont{dup rcheck not{
/definefont cvx/invalidaccess signalerror}if/definefont cvx{.completefont}.errorexec
.currentglobal{//systemdict/LocalFontDirectory .knownget{2 index 2 index{.growput}//superexec}if}if
dup .FontDirectory 4 -2 roll{.growput}//superexec
currentfile .currentresourcefile eq{dup .registerfont}if
readonly}odef/.aliasfont{.currentglobal 3 1 roll dup .gcheck .setglobal
dup length 2 add dict
dup 3 -1 roll{1 index/FID eq{pop pop}{put dup}ifelse}forall
2 index dup type/stringtype eq exch .gcheck or 1 index .gcheck not or{pop
1 index dup type/stringtype eq{cvn}if
1 index/FontName get defaultfontname ne{2 copy/FontName exch put}if
1 index exch/.Alias exch put
dup dup/OrigFont exch .growput/definefont .systemvar exec}{/findfont cvx{.completefont}.errorexec pop exch pop}ifelse
exch .setglobal}odef/.loadfontfile{userdict begin
cvx exec
end}bind def/.setloadingfont{//systemdict/.loadingfont 3 -1 roll .forceput}.bind odef/.loadfont{true .setloadingfont
{/FAPI_hook_disable pop{{.loadfontfile}.execasresource}count 1 sub 2 .execn
count exch sub{pop}repeat
exit}loop
false .setloadingfont}bind def/.substitutefaces[[(Book)/NewCenturySchlbk 0][(Grot)/Helvetica 0][(Roman)/Times 0]
[(Chancery)/ZapfChancery-MediumItalic 0][(Arial)/Helvetica 0][(Avant)/AvantGarde 0][(Bookman)/Bookman 0]
[(Century)/NewCenturySchlbk 0][(Cour)/Courier 0][(Frut)/Helvetica 0][(Garamond)/Palatino 0][(Geneva)/Helvetica 0]
[(Helv)/Helvetica 0][(NewYork)/Bookman 0][(Pala)/Palatino 0][(Schlbk)/NewCenturySchlbk 0][(Swiss)/Helvetica 0]
[(Symbol)/Symbol 0][(Times)/Times 0][(Minion)/Times 0][(Myriad)/Helvetica 0][(Monospace)/Courier 0][(Typewriter)/Courier 0]
[(Albertus)/Palatino 0][(AntiqueOlive)/Helvetica 0][(Bodoni)/NewCenturySchlbk 0][(Chicago)/Helvetica 2][(Clarendon)/Bookman 0]
[(Cooper)/NewCenturySchlbk 0][(Copperplate)/AvantGarde 0][(Coronet)/ZapfChancery-MediumItalic 0][(Eurostile)/Helvetica 0]
[(Geneva)/Courier 2][(GillSans)/Helvetica 2][(GillSans-Light)/Helvetica 0][(Goudy)/Palatino 0][(Hoefler)/NewCenturySchlbk 0]
[(Joanna)/Times 0][(LetterGothic)/Courier 0][(LubalinGraph-Book)/Bookman 2][(LubalinGraph-Demi)/Bookman 0]
[(Marigold)/ZapfChancery-MediumItalic 0][(MonaLisa-Recut)/Palatino 0][(Monaco)/Courier 2][(Optima)/Helvetica 0]
[(Oxford)/ZapfChancery-MediumItalic 0][(Tekton)/Helvetica 0][(Univers)/Helvetica 0]]readonly def/.substituteproperties[
[(It)9][(Oblique)1][(Black)2][(Bd)2][(Bold)2][(bold)2][(Demi)2][(Heavy)2][(Sb)2][(Cn)4][(Cond)4][(Narrow)4][(Pkg)4][(Compr)4]
[(Serif)8][(Sans)-8]]readonly def/.fontnameproperties{.fontnamestring
.substituteproperties{2 copy 0 get search{pop pop pop dup length 1 sub 1 exch getinterval 3 -1 roll exch{
dup 0 ge{or}{neg not and}ifelse}forall exch}{pop pop}ifelse}forall pop}bind def/.substitutefamilies mark/AvantGarde
{/AvantGarde-Book/AvantGarde-BookOblique/AvantGarde-Demi/AvantGarde-DemiOblique}/Bookman
{/Bookman-Demi/Bookman-DemiItalic/Bookman-Light/Bookman-LightItalic}/Courier
{/Courier/Courier-Oblique/Courier-Bold/Courier-BoldOblique}/Helvetica
{/Helvetica/Helvetica-Oblique/Helvetica-Bold/Helvetica-BoldOblique/Helvetica-Narrow/Helvetica-Narrow-Oblique
/Helvetica-Narrow-Bold/Helvetica-Narrow-BoldOblique}/NewCenturySchlbk{/NewCenturySchlbk-Roman/NewCenturySchlbk-Italic
/NewCenturySchlbk-Bold/NewCenturySchlbk-BoldItalic}/Palatino{/Palatino-Roman/Palatino-Italic/Palatino-Bold/Palatino-BoldItalic}
/Symbol{/Symbol/Symbol/Symbol/Symbol}/Times{/Times-Roman/Times-Italic/Times-Bold/Times-BoldItalic}/ZapfChancery-MediumItalic
{/ZapfChancery-MediumItalic}.dicttomark readonly def/.nametostring{dup type/nametype eq{.namestring}if}bind def
/.fontnamestring{dup type dup/nametype eq{pop .namestring}{/stringtype ne{pop()}if}ifelse}bind def/.substitutefontname{
exch .fontnamestring{defaultfontname/Helvetica-Oblique/Helvetica-Bold/Helvetica-BoldOblique
/Helvetica-Narrow/Helvetica-Narrow-Oblique/Helvetica-Narrow-Bold/Helvetica-Narrow-BoldOblique
/Times-Roman/Times-Italic/Times-Bold/Times-BoldItalic/Helvetica-Narrow/Helvetica-Narrow-Oblique
/Helvetica-Narrow-Bold/Helvetica-Narrow-BoldOblique}3 1 roll
.substitutefaces{2 copy 0 get search{pop pop pop
dup 2 get 4 -1 roll or 3 1 roll
1 get .substitutefamilies exch get
4 -1 roll pop 3 1 roll}{pop pop}ifelse}forall pop
1 index length mod get exec}bind def/.substitutefont{dup 0 exch .fontnameproperties .substitutefontname
Fontmap 1 index known not{pop defaultfontname}if}bind def
FAKEFONTS not{(%END FAKEFONTS).skipeof}if/definefont{dup/FontMatrix known{//definefont}{
2 copy/FontName get findfont//definefont exch pop exch pop}ifelse}bind odef/scalefont{1 index/FontMatrix known{//scalefont}{
1 index/FontName get findfont 1 index//scalefont
exch pop exch pop}ifelse}bind odef/makefont{1 index/FontMatrix known{//makefont}{
1 index/FontName get findfont 1 index//makefont
exch pop exch pop}ifelse}bind odef/setfont{dup/FontMatrix known{//setfont}{dup/FontName get findfont//setfont pop}ifelse
}bind odef
%END FAKEFONTS
/.findfont{mark 1 index//systemdict begin .dofindfont
counttomark 1 sub{.aliasfont}repeat end
exch pop exch pop}odef/findfont{.findfont}bind def/.checkalias{counttomark 1 sub -1 1{index 1 index eq{pop QUIET not
{(Unable to substitute for font.)= flush}if/findfont cvx/invalidfont signalerror}if}for}bind def/.fontknownget{.knownget
{FAKEFONTS{dup/FontMatrix known{true}{pop false}ifelse}{true}ifelse}{false}ifelse}bind def/.stdsubstfont{/SUBSTFONT where{
pop QUIET not{(Substituting for font )print dup =only(.)= flush}if
cleartomark mark defaultfontname}{dup .substitutefont
2 copy eq{pop defaultfontname}if
.checkalias
QUIET not{SHORTERRORS{(%%[)print 1 index =only( not found, substituting )print dup =only(]%%)}{
(Substituting font )print dup =only( for )print 1 index =only(.)}ifelse = flush}if}ifelse/Font findresource}bind def
$error/SubstituteFont{}put/.scannextfontdir{null 0 1 FONTPATH length 1 sub{FONTPATH 1 index get null ne{exch pop exit}if pop
}for dup null ne{dup 0 eq{.scanfontbegin}if
FONTPATH 1 index get .scanfontdir
FONTPATH exch null put true}{pop false}ifelse}bind def/.dofindfont{.tryfindfont not{.scannextfontdir{
counttomark 1 sub{pop}repeat
.dofindfont}{systemdict/.nativefontmapbuilt get not{.buildnativefontmap}{false}ifelse{.dofindfont}{QUIET not{
(Didn't find this font on the system!\n)print}if
dup defaultfontname eq{QUIET not{(Unable to load default font )print
dup =only(!  Giving up.)= flush}if/findfont cvx/invalidfont signalerror}if
$error/SubstituteFont get exec
.stdsubstfont}ifelse}ifelse}if}bind def/.tryfindfont{.FontDirectory 1 index .fontknownget{exch pop true}
{dup Fontmap exch .knownget not{.tryloadfont}{false exch{exch pop
dup type/nametype eq{.checkalias .tryfindfont exit}{dup dup type dup/arraytype eq exch/packedarraytype eq or exch xcheck and{
exec
.FontDirectory 1 index .knownget{exch pop true exit}if}{.loadfontloop{true exit}if}ifelse}ifelse false}forall{true}{
.tryloadfont}ifelse}ifelse}ifelse}bind def/.putgstringcopy{2 index gcheck currentglobal
2 copy eq{pop pop .forceput}{5 1 roll setglobal
dup length string copy
.forceput setglobal}ifelse}.bind odef/.tryloadfont{dup .nametostring/.genericrfn where{pop
pop dup .fonttempstring/FontResourceDir getsystemparam .genericrfn
.loadfontloop{//true}{dup .nametostring .loadfontloop}ifelse}{.loadfontloop}ifelse}bind def/.loadfontloop{{
dup type/stringtype ne{QUIET not{(Can't find font with non-string name: )print dup =only(.)= flush}if pop false exit}if
findlibfile not{QUIET not{(Can't find \(or can't open\) font file )print dup print(.)= flush}if pop false exit}if
DISKFONTS{.currentglobal true .setglobal
2 index(r)file
FontFileDirectory exch 5 index exch .growput
.setglobal}if
QUIET not{(Loading )print 2 index =only( font from )print 1 index print(... )print flush}if
LOCALFONTS{false}{/setglobal where}ifelse{pop/FontType .findfontvalue{1 eq}{false}ifelse
.currentglobal exch/.setglobal .systemvar exec
.FontDirectory 3 index .forceundef
1 index(r)file .loadfont .FontDirectory exch/.setglobal .systemvar exec}{.loadfont .FontDirectory}ifelse
QUIET not{//systemdict/level2dict known{.currentglobal false .setglobal vmstatus
true .setglobal vmstatus 3 -1 roll pop
6 -1 roll .setglobal 5}{vmstatus 3}ifelse{=only( )print}repeat(done.)= flush}if
dup 3 index .fontknownget{dup/PathLoad 4 index//.putgstringcopy exec
4 1 roll pop pop pop true exit}if
exch dup(r)file .findfontname{2 index 1 index .fontknownget{dup 4 -1 roll/PathLoad exch//.putgstringcopy exec
3 -1 roll pop exch
QUIET{pop}{(Using )print =only( font for )print 1 index =only(.)= flush}ifelse
exch pop true exit}if pop}if pop pop
QUIET not{(Loading )print dup =only( font failed.)= flush}if
false exit}loop}bind executeonly def
currentdict/.putgstringcopy .undef/loadallfonts{Fontmap{pop findfont pop}forall}bind def/.definefakefonts{}{
(gs_fonts FAKEFONTS)VMDEBUG
Fontmap{pop dup type/stringtype eq{cvn}if
.FontDirectory 1 index known not{2 dict dup/FontName 3 index put
dup/FontType 1 put
.FontDirectory 3 1 roll{put}//superexec}{pop}ifelse}forall}FAKEFONTS{exch}if pop def/.loadinitialfonts{NOFONTMAP not
{/FONTMAP where{pop[FONTMAP .pathlist]{dup VMDEBUG findlibfile{exch pop .loadFontmap}{/undefinedfilename signalerror}ifelse}}
{LIBPATH{defaultfontmap
false .file_name_combine{dup VMDEBUG(r){file}.internalstopped{pop pop
defaultfontmap_content{.definefontmap}forall}{.loadFontmap}ifelse}{pop pop}ifelse}}ifelse forall}if
userdict/defaultfontmap_content .undef
.definefakefonts}def/.makemodifiedfont{exch{1 index/FID ne{2 index 2 index known{1 index/FontInfo eq{2 index 2 index get
1 index{2 index 2 index known{pop pop}{2 index 3 1 roll put}ifelse}forall pop}if}{2 index 3 1 roll put
dup dup}ifelse}if
pop pop}forall}bind def/.definemodifiedfont{.makemodifiedfont
dup/FontName get exch definefont pop}bind def
(END GS_FONTS)VMDEBUG/.setloreshalftone{16.001 div 0{1 add 7.9999 mul cvi exch 1 add 7.9999 mul cvi 16 mul add<
0E 8E 2E AE 06 86 26 A6 0C 8C 2C AC 04 84 24 A4
CE 4E EE 6E C6 46 E6 66 CC 4C EC 6C C4 44 E4 64
3E BE 1E 9E 36 B6 16 96 3C BC 1C 9C 34 B4 14 94
FE 7E DE 5E F6 76 D6 56 FC 7C DC 5C F4 74 D4 54
01 81 21 A1 09 89 29 A9 03 83 23 A3 0B 8B 2B AB
C1 41 E1 61 C9 49 E9 69 C3 43 E3 63 CB 4B EB 6B
31 B1 11 91 39 B9 19 99 33 B3 13 93 3B BB 1B 9B
F1 71 D1 51 F9 79 D9 59 F3 73 D3 53 FB 7B DB 5B
0D 8D 2D AD 05 85 25 A5 0F 8F 2F AF 07 87 27 A7
CD 4D ED 6D C5 45 E5 65 CF 4F EF 6F C7 47 E7 67
3D BD 1D 9D 35 B5 15 95 3F BF 1F 9F 37 B7 17 97
FD 7D DD 5D F5 75 D5 55 FF 7F DF 5F F7 77 D7 57
02 82 22 A2 0A 8A 2A AA 00 80 20 A0 08 88 28 A8
C2 42 E2 62 CA 4A EA 6A C0 40 E0 60 C8 48 E8 68
32 B2 12 92 3A BA 1A 9A 30 B0 10 90 38 B8 18 98
F2 72 D2 52 FA 7A DA 5A F0 70 D0 50 F8 78 D8 58
>exch get 256 div}bind//systemdict/setcolorscreen known processcolors 4 eq and{3 copy 6 copy//setcolorscreen}{//setscreen}
ifelse}bind def/.setloresscreen{.setloreshalftone
0 array cvx settransfer/setstrokeadjust where{pop true setstrokeadjust}if}bind def
currentpacking false setpacking/.linescreen{((C) 1989 Berthold K.P. Horn)pop
1 add 180 mul cos 1 0.08 add mul exch 2 add 180 mul cos
1 0.08 sub mul add 2 div}bind readonly def
setpacking/.sethireshalftone{//systemdict/DITHERPPI known{DITHERPPI}{dup cvi 100 idiv 15 .min
{//null 46 46 60 60 60 106 106 106 106 133 133 133 133 133 150}exch get}ifelse
1 index 4.01 div .min
45//.linescreen
currentdevice mark/RedValues 0/GreenValues 0/BlueValues 0/GrayValues 0
.dicttomark .getdeviceparams
counttomark 2 idiv 1 sub{exch pop dup 1 le{pop}{exch dup 1 le{pop}{.min}ifelse}ifelse}repeat
exch pop exch pop 32 lt 4 index 800 lt and 5 1 roll
4 -1 roll 150 ge{/setcolorscreen where{pop//systemdict/COLORSCREEN known{COLORSCREEN}{3 index}ifelse
dup false ne{4 1 roll 3 copy 6 copy 13 -1 roll
true eq{{45 90 15 75}{3 1 roll exch pop 12 3 roll}forall}if//setcolorscreen}{pop//setscreen}ifelse}{//setscreen}ifelse}
{//setscreen}ifelse}bind def/.sethiresscreen{.sethireshalftone{{dup dup 0.0 gt exch 1.0 lt and{0.8 exp}if}}{0 array cvx}ifelse
settransfer/setstrokeadjust where{pop false setstrokeadjust}if
0.5 .setfilladjust}bind def/.setdefaultbgucr{systemdict/setblackgeneration known{
{pop 0}dup setblackgeneration setundercolorremoval}if}bind def/.useloresscreen{
72 72 matrix defaultmatrix dtransform abs exch abs .min
dup 150 lt//systemdict/DITHERPPI known not and}bind def/.getdefaulthalftone{
{currentdevice/HalftoneDefault gsgetdeviceprop}.internalstopped{pop pop false}{dup type/dicttype eq{true}{pop false}ifelse}
ifelse
dup not{pop{/Default/Halftone/findresource .systemvar exec}.internalstopped{pop pop false}{true}ifelse}if}bind def
/.setdefaulthalftone{.getdefaulthalftone{sethalftone}{.useloresscreen{.setloreshalftone}{.sethireshalftone pop}ifelse}ifelse
}bind def/.setdefaultscreen{.useloresscreen{.setloresscreen}{.sethiresscreen}ifelse
.setdefaultbgucr}bind def/.renderingintentdict mark/Perceptual 0/RelativeColorimetric 1/Saturation 2/AbsoluteColorimetric 3
.dicttomark readonly def
.currentglobal true .setglobal
userdict/.cspace_util 80 dict put
.cspace_util begin/DeviceGray_array/DeviceGray 1 array astore readonly def
/DeviceRGB_array/DeviceRGB 1 array astore readonly def/DeviceCMYK_array/DeviceCMYK 1 array astore readonly def
/colorspacedict 20 dict def/make_array1{dup type/nametype eq{currentglobal true setglobal exch 1 array astore exch setglobal}if
}bind def/.get_cspace_type{dup type dup/arraytype eq exch/packedarraytype eq or{0 get}if}bind def/.get_method_dict
{//colorspacedict exch//.get_cspace_type exec get}bind def/.get_method{exch//.get_method_dict exec exch get}bind def
/.cs_potential_indexed_base{/cs_potential_indexed_base//.get_method exec}bind def/.cs_potential_pattern_base
{/cs_potential_pattern_base//.get_method exec}bind def/.cs_potential_alternate{/cs_potential_alternate//.get_method exec}
bind def/.cs_potential_icc_alternate{/cs_potential_icc_alternate//.get_method exec}bind def/.cs_get_ncomps
{dup/cs_get_ncomps//.get_method exec exec}bind def/.cs_get_range{dup/cs_get_range//.get_method exec exec}bind def
/.cs_get_default_color{dup/cs_get_default_color//.get_method exec exec}bind def/.cs_get_currentgray
{dup/cs_get_currentgray//.get_method exec exec}bind def/.cs_get_currentrgb{dup/cs_get_currentrgb//.get_method exec exec}
bind def/.cs_get_currentcmyk{dup/cs_get_currentcmyk//.get_method exec exec}bind def/.cs_validate
{dup/cs_validate//.get_method exec exec}bind def/.cs_substitute{dup/cs_substitute//.get_method exec exec}bind def/.cs_prepare
{dup/cs_prepare//.get_method exec exec}bind def/.cs_install{dup/cs_install//.get_method exec exec}bind def/.cs_prepare_color
{dup/cs_prepare_color//.get_method exec exec}bind def/.cs_complete_setcolor{dup/cs_complete_setcolor//.get_method exec exec}
bind def//DeviceGray_array setcolorspace/setcolor{{currentcolorspace//.cs_prepare_color exec//setcolor
currentcolorspace//.cs_complete_setcolor exec}stopped{//.cspace_util/setcolor get $error/errorname get signalerror}if}bind odef
systemdict/setcolor .undef/_setcolorspace{{1 index
dup type dup/arraytype eq exch/packedarraytype eq or{0 get}if
dup type/nametype ne{//.cspace_util/setcolorspace get/typecheck signalerror}if//colorspacedict exch known not{
//.cspace_util/setcolorspace get/undefined signalerror}if
1 index
type/nametype eq{currentcolorspace 0 get
2 index eq}{currentcolorspace
2 index eq}ifelse
and dup{/PDFfile where{pop}{.getuseciecolor not and}ifelse}if{mark
true
3 -1 roll//.cs_get_default_color exec setcolor
cleartomark}{//.cs_validate exec//.cs_substitute exec//.cs_prepare exec//.cs_install exec
dup//make_array1 exec//setcolorspace
mark
true
3 -1 roll//.cs_get_default_color exec setcolor
cleartomark}ifelse}stopped{//.cspace_util/setcolorspace get $error/errorname get signalerror}if}bind def/_setcolorspace_nosub{{
//.cs_validate exec
dup//.cs_prepare exec//.cs_install exec//make_array1 exec//setcolorspace}stopped
{//.cspace_util/setcolorspace get $error/errorname get signalerror}if}bind def
/setcolorspace{//true//_setcolorspace exec}bind odef/forcesetcolorspace{//false//_setcolorspace exec}bind odef/initgraphics
{initgraphics//DeviceGray_array forcesetcolorspace}.bind systemdict begin odef end
systemdict/setcolorspace .undef/setgray{{//DeviceGray_array//setcolorspace//setcolor}stopped
{/setgray .systemvar $error/errorname get signalerror}if}bind systemdict begin odef end/setrgbcolor{
{//DeviceRGB_array//setcolorspace//setcolor}stopped{/setrgbcolor .systemvar $error/errorname get signalerror}if}
bind systemdict begin odef end/setcolorscreen where{pop/setcmykcolor{{//DeviceCMYK_array//setcolorspace//setcolor}stopped
{/setcmykcolor .systemvar $error/errorname get signalerror}if}bind systemdict begin odef end}if/currentgray
{currentcolor currentcolorspace//.cs_get_currentgray exec}bind systemdict begin odef end/currentrgbcolor
{currentcolor currentcolorspace//.cs_get_currentrgb exec}bind systemdict begin odef end/setcolorscreen where{pop
/currentcmykcolor{currentcolor currentcolorspace//.cs_get_currentcmyk exec}bind systemdict begin odef end}if
/setcspace_typecheck{/setcolorspace cvx/typecheck signalerror}bind def/setcspace_rangecheck
{/setcolorspace cvx/rangecheck signalerror}bind def/setcspace_invalidaccess{/setcolorspace cvx/invalidaccess signalerror}
bind def/setcspace_undefined{/setcolorspace cvx/undefined signalerror}bind def/setcolor_typecheck
{/setcolor cvx/typecheck signalerror}bind def/setcolor_invalidaccess{/setcolor cvx/invalidaccess signalerror}bind def
/check_array{dup type dup/arraytype ne exch/packedarraytype ne and{/setcolorspace cvx/typecheck signalerror}if}bind def
/ncomps_1{pop 1}bind def/ncomps_3{pop 3}bind def/ncomps_4{pop 4}bind def/dflt_range_4[0 1 0 1 0 1 0 1]readonly def
/dflt_range_3 dflt_range_4 0 6 getinterval def/dflt_range_1 dflt_range_4 0 2 getinterval def
/get_range_1{pop//dflt_range_1}bind def/get_range_3{pop//dflt_range_3}bind def/get_range_4{pop//dflt_range_4}bind def
/check_num_stack{1 1 3 2 roll{index
type dup/integertype ne exch/realtype ne and//setcolor_typecheck
if}for}bind def/validate_1{1//check_num_stack exec pop}bind def/validate_3{3//check_num_stack exec pop}bind def
/validate_4{4//check_num_stack exec pop}bind def/pop_1{pop}bind def/dup_1{dup}bind def/clear_n_objs{//pop_1 repeat}bind def
/clear_setcolor_operands{//.cs_get_ncomps exec//clear_n_objs exec}bind def
/no_currentgray{//.cs_get_ncomps exec//clear_n_objs exec 0.}bind def
/no_currentrgb{//.cs_get_ncomps exec//clear_n_objs exec 0. 0. 0.}bind def
/no_currentcmyk{//.cs_get_ncomps exec//clear_n_objs exec 0. 0. 0. 1.}bind def/bound_0_1{dup 0 lt{pop 0.0}{dup 1 gt{pop 1.0}if}
ifelse}bind def/max_n{1 sub{2 copy lt{exch}if pop}repeat}bind def/min_n{1 sub{2 copy gt{exch}if pop}repeat}bind def
/.f1_3 1.0 3 div def/.f2_3 2.0 3 div def/.rgb_2_hsb{3 copy 3//max_n exec dup 5 1 roll
dup 0.0 eq{pop pop pop pop 0.0 0.0}{4 copy pop 3//min_n exec 1 index exch sub
dup 2 index div 7 1 roll
dup 0.0 eq{5{pop}repeat 0.0 3 1 roll}{6.0 mul 5 1 roll
2 copy eq{pop pop sub exch div//.f2_3 add}{2 index eq{exch pop exch sub exch div//.f1_3 add}{sub exch pop exch div
dup 0.0 lt{1.0 add}if}ifelse}ifelse
3 1 roll}ifelse}ifelse}bind def/.hsb_2_rgb{3{0.0 max 1.0 min 3 1 roll}repeat
1.0 2 index sub 1 index mul
3 -1 roll 2 index mul 6.0 mul
4 -1 roll{{mul 1 index add exch}{//.f1_3 exch sub mul 1 index add 3 1 roll}
{//.f1_3 sub mul 1 index add 3 1 roll exch 3 -1 roll}{//.f2_3 exch sub mul 1 index add 3 -1 roll}
{//.f2_3 sub mul 1 index add 3 1 roll exch}{1.0 exch sub mul 1 index add}{pop pop dup}}1 index 6.0 mul cvi
get exec}bind def/sethsbcolor{{//.hsb_2_rgb exec setrgbcolor}stopped{/sethsbcolor .systemvar $error/errorname get signalerror}
if}bind systemdict begin odef end/currenthsbcolor{{currentrgbcolor//.rgb_2_hsb exec}stopped
{/currenthsbcolor .systemvar $error/errorname get signalerror}if}bind systemdict begin odef end
currentdict/DeviceGray_array .undef
currentdict/DeviceRGB_array .undef
currentdict/DeviceCMYK_array .undef
end
.setglobal
(END BASIC COLOR)VMDEBUG
.currentglobal true .setglobal
.cspace_util begin/rgb_2_gray{3 copy 1 index eq 3 1 roll eq and{pop pop}{.11 mul exch .59 mul add exch .3 mul add}ifelse}
bind def
systemdict/..page_default_spaces 3 dict put/..includecolorspace{systemdict/..page_default_spaces get 1 index known{pop}{
mark exch{dup/ColorSpace resourcestatus{pop 0 eq{systemdict/..page_default_spaces get 1 index//true put
gsave{dup/ColorSpace findresource//_setcolorspace_nosub exec .includecolorspace}stopped pop
grestore}if}if}stopped pop
cleartomark}ifelse}bind def/cs_substitute_generic{.getuseciecolor{NOSUBSTDEVICECOLORS{//..includecolorspace exec dup}
{/ColorSpace findresource}ifelse}{pop dup}ifelse}bind def/cs_substitute_DeviceRGB_for_PDFX_or_PDFA
{systemdict/PDFX .knownget not{false}if
systemdict/PDFA .knownget not{false}if
or{dup/ColorSpace resourcestatus{pop pop}{
(Error: Need a /DefaultRGB /ColorSpace resource for generating a PDF/X or PDF/A document.)=
/cs_substitute_DeviceRGB_for_PDFX_or_PDFA cvx/undefined signalerror}ifelse/ColorSpace findresource}{
//cs_substitute_generic exec}ifelse}bind def
colorspacedict
dup/DeviceGray
mark/cs_potential_indexed_base true/cs_potential_pattern_base true/cs_potential_alternate true/cs_potential_icc_alternate true
/cs_get_ncomps//ncomps_1/cs_get_range//get_range_1/cs_get_default_color{pop 0.0}bind/cs_get_currentgray//pop_1
/cs_get_currentrgb{pop dup dup}bind/cs_get_currentcmyk{pop 1.0 exch sub 0.0 0.0 0.0 4 -1 roll}bind/cs_validate{}/cs_substitute
{/DefaultGray//cs_substitute_generic exec}bind/cs_prepare{}/cs_install{pop 0 .setdevcspace}bind/cs_prepare_color//validate_1
/cs_complete_setcolor//pop_1
.dicttomark
put/DeviceRGB
mark/cs_potential_indexed_base true/cs_potential_pattern_base true/cs_potential_alternate true/cs_potential_icc_alternate true
/cs_get_ncomps//ncomps_3/cs_get_range//get_range_3/cs_get_default_color{pop 0.0 0.0 0.0}bind
/cs_get_currentgray{pop//rgb_2_gray exec}bind/cs_get_currentrgb//pop_1/cs_get_currentcmyk{pop
3{1.0 exch sub 3 1 roll}repeat
3 copy
2{2 copy gt{exch}if
pop}repeat
dup 5 1 roll currentundercolorremoval exec cvr 4 1 roll
3{3 index sub//bound_0_1 exec 3 1 roll}repeat
5 3 roll pop currentblackgeneration exec cvr//bound_0_1 exec}bind/cs_validate{}/cs_substitute
{/DefaultRGB//cs_substitute_DeviceRGB_for_PDFX_or_PDFA exec}bind/cs_prepare{}/cs_install{pop 1 .setdevcspace}bind
/cs_prepare_color//validate_3/cs_complete_setcolor//pop_1
.dicttomark
put
end
.setglobal/setcolorscreen where{pop}{currentfile closefile}ifelse
.currentglobal true .setglobal
.cspace_util begin
colorspacedict/DeviceCMYK
mark/cs_potential_indexed_base true/cs_potential_pattern_base true/cs_potential_alternate true/cs_potential_icc_alternate true
/cs_get_ncomps//ncomps_4/cs_get_range//get_range_4/cs_get_default_color{pop 0.0 0.0 0.0 1.0}bind/cs_get_currentgray
{pop 4 1 roll//rgb_2_gray exec add 1.0 exch sub//bound_0_1 exec}bind/cs_get_currentrgb{pop
4 1 roll 3{3 index add 1.0 exch sub//bound_0_1 exec 3 1 roll}repeat
4 -1 roll pop}bind/cs_get_currentcmyk//pop_1/cs_validate{}/cs_substitute{/DefaultCMYK//cs_substitute_generic exec}bind
/cs_prepare{}/cs_install{pop 2 .setdevcspace}bind/cs_prepare_color//validate_4/cs_complete_setcolor//pop_1
.dicttomark
put
currentdict/..includecolorspace .undef
currentdict/cs_substitute_generic .undef
end
.setglobal
(END LEVEL 1 COLOR)VMDEBUG
.currentglobal true .setglobal
systemdict begin/.imagetypes
5 dict
dup 1/.image1 load put
def/.imagemasktypes
5 dict
dup 1/.imagemask1 load put
def
end
.setglobal
.currentglobal true .setglobal
userdict/img_utils_dict 30 dict put
img_utils_dict begin/img_csary[null/DeviceGray null/DeviceRGB/DeviceCMYK]def/img_decary[0 1 0 1 0 1 0 1]def/img_params_ary[
/ImageType/IMG_NComps/MultipleDataSources/DataSource/ImageMatrix/BitsPerComponent/Height/Width/Decode]def
/img_check_ary//img_params_ary def/img_unbuild_ary//img_params_ary 1 1 index length 2 sub getinterval
def/img_mask_params_ary[/ImageType/DataSource/ImageMatrix/Polarity/Height/Width]def/img_mask_check_ary[
/ImageType/BitsPerComponent/DataSource/ImageMatrix/Decode/Height/Width]def/img_mask_unbuild_ary
//img_mask_check_ary 2 1 index length 2 sub getinterval
def/img_check_keys{count 2 ge{1 index type/dicttype eq{true exch{2 index exch known and
dup not{exit}if}forall}{pop//false}ifelse}{pop//false}ifelse}.bind def/img_params_dict
mark/ImageType{1 def}.bind/IMG_NComps{exch def}.bind/MultipleDataSources 1 index/Width 1 index/Height 1 index
/ImageMatrix 1 index/BitsPerComponent 1 index/DataSource 1 index/Polarity{pop{{1 0}}{{0 1}}ifelse/Decode exch cvlit def}.bind
/Decode{//img_decary 0 IMG_NComps 2 mul getinterval def}.bind
.dicttomark
def/img_build_dict{.currentglobal false .setglobal
1 index length 2 add dict
exch .setglobal
begin{//img_params_dict 1 index get exec}forall
currentdict/BitsPerComponent known not{/BitsPerComponent 1 def}if
currentdict end}.bind def/img_unbuild_dict{exch begin
dup length 1 sub -1 0{1 index exch get load exch}for
pop
end}.bind def/good_image_types mark/filetype{pop//true}.bind/stringtype 1 index/arraytype//xcheck/packedarraytype//xcheck
.dicttomark readonly def/img_build_image_dict{count 8 lt{/.colorimage cvx/stackunderflow signalerror}if
3 copy
type/booleantype ne exch
type/integertype ne or exch
type/booleantype ne or{/.colorimage cvx/typecheck signalerror}if
1 index 1 lt 2 index 2 eq or 2 index 4 gt or{/.colorimage cvx/rangecheck signalerror}if
2 index{2 copy{1 add}if
dup count 9 sub gt{//true exch -1 1{3 add index//good_image_types 1 index type .knownget{exec and}{pop pop//false}ifelse}for
{/stackunderflow}{/typecheck}ifelse/.colorimage cvx exch signalerror}if
dup .currentglobal false .setglobal exch array exch .setglobal
5 1 roll 4 add 3 roll astore 4 1 roll}if
8 1 roll//img_params_ary//img_build_dict exec exch}.bind def
currentdict/good_image_types .undef/img_unbuild_image_dict{//img_check_ary//img_check_keys exec{
//img_unbuild_ary//img_unbuild_dict exec
1 index type/booleantype eq{1 index{3 -1 roll aload length 2 add -2 roll}if}if}if}.bind def/img_build_imagemask_dict{count 5 lt
{/imagemask .systemvar/stackunderflow signalerror}if
2 index type/booleantype ne{/imagemask .systemvar/typecheck signalerror}if//img_mask_params_ary//img_build_dict exec}.bind def
/img_unbuild_imagemask_dict{//img_mask_check_ary//img_check_keys exec{//img_mask_unbuild_ary//img_unbuild_dict exec
3 -1 roll
dup type dup/arraytype eq exch/packedarraytype eq or
1 index rcheck and{0 get 1 eq}if
3 1 roll}if}.bind def/.colorimage{//img_build_image_dict exec{gsave
1 index dup/Height get 0 eq exch/Width get 0 eq or{pop pop}{0 .setoverprintmode
//img_csary 2 index/IMG_NComps get get setcolorspace{.alphaimage}{.image1}ifelse}ifelse}stopped
grestore{//img_unbuild_image_dict exec/.colorimage cvx $error/errorname get
signalerror}if}.bind def
systemdict/setcolorscreen .knownget{type/operatortype eq{/colorimage{//false//.colorimage
stopped{/colorimage .systemvar $error/errorname get signalerror}if}.bind systemdict begin odef end}if}if/image{
dup type/dicttype eq .languagelevel 2 ge and{dup/ImageType get dup 2 eq{//.imagetypes exch known{gsave
0 .setoverprintmode
dup/PixelCopy .knownget dup{pop}if{[/DevicePixel
currentpagedevice dup/BitsPerPixel .knownget{exch pop}{/GrayValues .knownget not{2}if
ln 2 ln div round cvi}ifelse]}{/DeviceRGB}ifelse
setcolorspace//.imagetypes 2 get
stopped
grestore{/image .systemvar $error/errorname get signalerror}if}{/image .systemvar/rangecheck signalerror}ifelse}{
dup//.imagetypes exch .knownget{exch pop gsave
0 .setoverprintmode
stopped
grestore{/image .systemvar $error/errorname get signalerror}if}{/image .systemvar exch type/integertype eq
{/rangecheck}{/typecheck}ifelse signalerror}ifelse}ifelse}{//false 1//false//.colorimage
stopped{/image .systemvar $error/errorname get signalerror}if}ifelse}.bind systemdict begin odef end/.is_low_resolution{
1 exch 0 exch
0 exch 1 exch/ImageMatrix get dup
2{4 1 roll
idtransform dtransform dup mul exch dup mul add sqrt}repeat
max
2 gt}.bind def/imagemask{dup type/dicttype eq .languagelevel 2 ge and{dup/ImageType get//.imagemasktypes exch .knownget
{1 index//.is_low_resolution exec
2 index/ImageType get 1 eq and
2 index/BitsPerComponent get 1 eq and
2 index/Interpolate .knownget not{false}if and//filterdict/ImscaleDecode known and{exch dup length dict .copydict
dup dup/DataSource get
mark/Width 3 index/Width get/Height 5 index/Height get .dicttomark/ImscaleDecode filter/DataSource exch put
dup dup/Width get 4 mul/Width exch put
dup dup/Height get 4 mul/Height exch put
dup dup/ImageMatrix get
4 4 matrix scale matrix concatmatrix/ImageMatrix exch put
exch}if
exec}{/imagemask .systemvar/typecheck signalerror}ifelse}{//img_build_imagemask_dict exec{.imagemask1}stopped{
//img_unbuild_imagemask_dict exec/imagemask .systemvar $error/errorname get signalerror}if}ifelse}
.bind systemdict begin odef end
end
currentdict/INTERPOLATE known
currentdict/DOTERPOLATE known or
currentdict/NOTERPOLATE known or not{currentfile 1(%END INTERPOLATE).subfiledecode flushfile}if/.interpolate{
dup/Interpolate .knownget not{//false}if/INTERPOLATE .systemvar ne{dup gcheck .currentglobal exch .setglobal
exch dup length dict copy
dup/Interpolate/INTERPOLATE .systemvar put
exch .setglobal}if}.bind odef/colorimage{/INTERPOLATE .systemvar{.currentglobal//false .setglobal
9 dict begin
2 .argindex{1 index 7 add}{8}ifelse
dup .argindex pop
copy gsave pop{0/DeviceGray 0/DeviceRGB/DeviceCMYK}1 index get setcolorspace{0 1 0 1 0 1 0 1}1 index 2 mul 0 exch
getinterval/Decode exch def
exch dup/MultipleDataSources exch def{array astore}{pop}ifelse/DataSource exch def/ImageMatrix exch def
/BitsPerComponent exch def/Height exch def/Width exch def/ImageType 1 def/Interpolate//true def
.setglobal currentdict end
image grestore
exch{4 add}{6}ifelse{pop}repeat}{colorimage}ifelse}.bind odef/image{dup type/dicttype eq{dup/ImageType get 3 eq
{.currentglobal//false .setglobal exch
dup length dict copy begin .setglobal/DataDict DataDict .interpolate def/MaskDict MaskDict .interpolate def
currentdict end}{.interpolate}ifelse
image}{/INTERPOLATE .systemvar{4 .argindex pop
.currentglobal//false .setglobal
8 dict begin .setglobal/ImageType 1 def/DataSource 1 index def/ImageMatrix 2 index def/BitsPerComponent 3 index def
/Decode{0 1}def/Height 4 index def/Width 5 index def/Interpolate//true def
currentdict end
gsave/DeviceGray setcolorspace image grestore
5{pop}repeat}{image}ifelse}ifelse}.bind odef/imagemask{dup type/dicttype eq{.interpolate imagemask}{/INTERPOLATE .systemvar{
4 .argindex pop
.currentglobal//false .setglobal
8 dict begin .setglobal/ImageType 1 def/DataSource 1 index def/ImageMatrix 2 index def/BitsPerComponent 1 def
2 index{{1 0}}{{0 1}}ifelse/Decode exch def/Height 4 index def/Width 5 index def/Interpolate//true def
currentdict end imagemask 5{pop}repeat}{imagemask}ifelse}ifelse}.bind odef
currentdict/.interpolate .undef
%END INTERPOLATE
.setglobal
(END IMAGE)VMDEBUG/.makepathtemplate{dup length dup add string 0
0 1 4 index length 1 sub{3 index exch get
dup 92 eq{2 index 2 index 92
put
exch 1 add exch}if
dup 42 eq{2 index 2 index 92
put
exch 1 add exch}if
dup 63 eq{2 index 2 index 92
put
exch 1 add exch}if
2 index 2 index 3 -1 roll put 1 add}for
0 exch getinterval exch pop}bind def/.generate_dir_list_templates_with_length{dup dup length string copy
(*)0 get(?)0 get(\\)0 get(x)0 get 0 0{1 index 7 index length ge{exit}if
6 index 2 index get
dup 7 index eq
1 index 7 index eq or{pop 2 index}if
dup 5 index eq{3 2 roll 1 add 3 1 roll
2 index 8 index length ge{pop exit}if
pop 6 index 2 index get}if
7 index 2 index 3 2 roll put
1 add exch 1 add exch}loop
6 1 roll pop
exch pop exch pop exch pop exch{dup 3 index length ge{exit}if
3 copy exch put
1 add}loop
pop pop{dup length
1 sub
exch
.makepathtemplate
dup
4 index length dup
2 index length
exch sub
exch getinterval
4 index exch copy pop
5 index{exch
7 2 roll}{exch pop
6 1 roll}ifelse}5 1 roll
dup .file_name_is_absolute{dup
5 index exec}{2 index{1 index
false .file_name_combine{5 index exec}{pop pop}ifelse}forall}ifelse
pop pop pop pop pop}bind def/.generate_dir_list_templates{//false 3 1 roll//.generate_dir_list_templates_with_length exec
}bind def
/WRITEDICTS false def
languagelevel 1 .setlanguagelevel
level2dict begin
mark/abs/add/aload/anchorsearch/and/arc/arcn/arct/arcto/array/ashow/astore/awidthshow/begin/bind
/bitshift/ceiling/charpath/clear/cleartomark/clip/clippath/closepath/concat/concatmatrix
/copy/count/counttomark/currentcmykcolor/currentdash/currentdict/currentfile/currentfont/currentgray/currentgstate
/currenthsbcolor/currentlinecap/currentlinejoin/currentlinewidth/currentmatrix
/currentpoint/currentrgbcolor/currentshared/curveto/cvi/cvlit/cvn/cvr/cvrs/cvs/cvx/def/defineusername/dict/div
/dtransform/dup/end/eoclip/eofill/eoviewclip/eq/exch/exec/exit/file/fill/findfont/flattenpath/floor
/flush/flushfile/for/forall/ge/get/getinterval/grestore/gsave/gstate/gt/identmatrix/idiv/idtransform/if
/ifelse/image/imagemask/index/ineofill/infill/initviewclip/inueofill/inufill/invertmatrix/itransform/known/le/length/lineto
/load/loop/lt/makefont/matrix/maxlength/mod/moveto/mul/ne/neg/newpath/not/null/or/pathbbox/pathforall/pop/print/printobject
/put/putinterval/rcurveto/read/readhexstring/readline/readstring/rectclip/rectfill/rectstroke
/rectviewclip/repeat/restore/rlineto/rmoveto/roll/rotate/round/save/scale/scalefont/search/selectfont/setbbox/setcachedevice
/setcachedevice2/setcharwidth/setcmykcolor/setdash/setfont/setgray/setgstate/sethsbcolor/setlinecap/setlinejoin
/setlinewidth/setmatrix/setrgbcolor/setshared/shareddict/show/showpage/stop/stopped/store
/string/stringwidth/stroke/strokepath/sub/systemdict/token/transform/translate/truncate/type/uappend/ucache/ueofill/ufill
/undef/upath/userdict/ustroke/viewclip/viewclippath/where/widthshow/write/writehexstring
/writeobject/writestring/wtranslation/xor/xshow/xyshow/yshow/FontDirectory/SharedFontDirectory/Courier
/Courier-Bold/Courier-BoldOblique/Courier-Oblique/Helvetica/Helvetica-Bold
/Helvetica-BoldOblique/Helvetica-Oblique/Symbol/Times-Bold/Times-BoldItalic
/Times-Italic/Times-Roman/execuserobject/currentcolor/currentcolorspace/currentglobal/execform/filter/findresource/globaldict
/makepattern/setcolor/setcolorspace/setglobal/setpagedevice/setpattern
counttomark 256 exch sub{0}repeat/=/==/ISOLatin1Encoding/StandardEncoding([)cvn(])cvn/atan/banddevice/bytesavailable
/cachestatus/closefile/colorimage/condition/copypage/cos/countdictstack/countexecstack/cshow/currentblackgeneration
/currentcacheparams/currentcolorscreen/currentcolortransfer/currentcontext/currentflat
/currenthalftone/currenthalftonephase/currentmiterlimit/currentobjectformat/currentpacking
/currentscreen/currentstrokeadjust/currenttransfer/currentundercolorremoval/defaultmatrix
/definefont/deletefile/detach/deviceinfo/dictstack/echo/erasepage/errordict/execstack/executeonly
/exp/false/filenameforall/fileposition/fork/framedevice/grestoreall/handleerror/initclip/initgraphics
/initmatrix/instroke/inustroke/join/kshow/ln/lock/log/mark/monitor/noaccess/notify/nulldevice/packedarray/quit
/rand/rcheck/readonly/realtime/renamefile/renderbands/resetfile/reversepath/rootfont/rrand
/run/scheck/setblackgeneration/setcachelimit/setcacheparams/setcolorscreen/setcolortransfer/setfileposition/setflat/sethalftone
/sethalftonephase/setmiterlimit/setobjectformat/setpacking/setscreen
/setstrokeadjust/settransfer/setucacheparams/setundercolorremoval/sin/sqrt/srand/stack/status/statusdict
/true/ucachestatus/undefinefont/usertime/ustrokepath/version/vmreclaim/vmstatus/wait/wcheck
/xcheck/yield/defineuserobject/undefineuserobject/UserObjects/cleardictstack/A/B/C/D/E/F/G/H/I/J/K/L/M
/N/O/P/Q/R/S/T/U/V/W/X/Y/Z/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z/setvmthreshold(<<)cvn
(>>)cvn/currentcolorrendering/currentdevparams/currentoverprint/currentpagedevice
/currentsystemparams/currentuserparams/defineresource/findencoding/gcheck/glyphshow/languagelevel/product/pstack/resourceforall
/resourcestatus/revision/serialnumber/setcolorrendering/setdevparams
/setoverprint/setsystemparams/setuserparams/startjob/undefineresource
/GlobalFontDirectory/ASCII85Decode/ASCII85Encode/ASCIIHexDecode/ASCIIHexEncode
/CCITTFaxDecode/CCITTFaxEncode/DCTDecode/DCTEncode/LZWDecode/LZWEncode/NullEncode/RunLengthDecode/RunLengthEncode/SubFileDecode
/CIEBasedA/CIEBasedABC/DeviceCMYK/DeviceGray/DeviceRGB/Indexed/Pattern/Separation/CIEBasedDEF/CIEBasedDEFG/DeviceN
.packtomark .installsystemnames/cntdict mark/integertype/pop load/realtype 1 index/marktype 1 index/nulltype 1 index
/booleantype 1 index/nametype{length add}bind/stringtype 1 index/arraytype null/dicttype null
.dicttomark def/.cntobj{dup type//cntdict exch get exec}.bind def
cntdict/arraytype{dup dup length 5 -1 roll add 4 2 roll{.cntobj}forall}bind put
cntdict/dicttype{WRITEDICTS{dup dup length 2 mul 5 -1 roll add 4 2 roll{cvlit{.cntobj}exch 2 .execn .cntobj}forall}{
/writeobject .systemvar/typecheck signalerror}ifelse}bind put/w2dict mark/nametype{2 copy .writecvs pop}bind/stringtype 1 index
.dicttomark def/.bosheader{dup 0 currentobjectformat 127 add put
2 index 255 le 2 index 65531 le and{exch 4 add exch
0 4 getinterval
dup 1 5 -1 roll put}{exch 8 add exch
0 0 4 2 roll .bosobject exch pop exch pop}ifelse
exch dup -8 bitshift exch 255 and
currentobjectformat 1 and 0 eq{exch}if
2 index 3 3 -1 roll put
1 index 2 3 -1 roll put}.bind def/.writeobjects{mark exch
dup length 0 3 -1 roll
dup 4 1 roll{.cntobj}forall
counttomark 3 add -2 roll 4 1 roll
dup counttomark 1 sub index length
4 index 3 bitshift 4 index add(xxxxxxxx).bosheader writestring
3 1 roll pop
counttomark 1 sub index length 3 bitshift exch
3 bitshift
counttomark 4 sub{counttomark -1 roll dup 6 1 roll
dup type/dicttype eq{{5 1 roll(x\000xxxxxx).bosobject
3 index exch writestring
4 -1 roll(x\000xxxxxx).bosobject
3 index exch writestring}forall}{{(x\000xxxxxx).bosobject
dup 1 6 index put
3 index exch writestring
4 -1 roll pop 0 4 1 roll}forall}ifelse}repeat
pop pop exch pop
counttomark 1 sub{counttomark -1 roll{1 index type/filetype ne{exch 2 index exch dup type//w2dict exch .knownget
{exec}{pop}ifelse pop}if
dup type//w2dict exch .knownget{exec}{pop}ifelse}forall}repeat
pop pop}.bind def/printobject{currentobjectformat 0 eq{/printobject .systemvar/undefined signalerror}if
(%stdout)(w)file 2 index 2 index .writeobject pop pop}odef/writeobject{currentobjectformat 0 eq{
/writeobject .systemvar/undefined signalerror}if
2 .argindex pop
.writeobject}odef/.writeobject{3 copy exch
.currentglobal false .setglobal exch 1 array astore exch .setglobal
.writeobjects pop pop pop}.bind def/.objectprinttest{mark 0 0 3 .argindex .cntobj cleartomark pop}bind odef/.printerror{
$error/binary get .languagelevel 2 ge and{currentobjectformat 0 ne{[/Error $error/errorname get $error/command get
dup{.objectprinttest}.internalstopped{pop 100 string cvs}if
false]250 printobject}//.printerror
ifelse}//.printerror
ifelse}bind def
currentdict/cntdict .undef
currentdict/w2dict .undef
end
.setlanguagelevel
level2dict begin/currentshared/.currentglobal load def/scheck/.gcheck load def
/shareddict currentdict/globaldict .knownget not{20 dict}if def
end
systemdict begin/SharedFontDirectory .FontDirectory .gcheck{.currentglobal false .setglobal
/LocalFontDirectory .FontDirectory dup maxlength dict copy
.forcedef
.setglobal .FontDirectory}{/LocalFontDirectory .FontDirectory
.forcedef
50 dict}ifelse def
end
level2dict begin/.setglobal{dup .setglobal//systemdict/FontDirectory .currentglobal{//SharedFontDirectory}
{/LocalFontDirectory .systemvar}ifelse .forceput pop}.bind odef/setshared{/.setglobal .systemvar exec}odef
.currentglobal setshared/selectfont{{1 .argindex findfont
1 index dup type/arraytype eq{makefont}{scalefont}ifelse
setfont pop pop}stopped{/selectfont .systemvar $error/errorname get signalerror}if}odef/undefinefont
{.FontDirectory 1 .argindex .forceundef
.currentglobal{//systemdict/LocalFontDirectory .knownget{1 index .forceundef}if}{//systemdict/SharedFontDirectory .knownget
{1 index .knownget{.FontDirectory 2 index 3 -1 roll{put}//superexec}if}if}ifelse pop}odef/restore{dup//restore
/LocalFontDirectory .systemvar
FAKEFONTS{mark
1 index dup{length 1 gt{pop}{//SharedFontDirectory 1 index .knownget{length 1 eq{pop}{1 index}ifelse}{1 index}ifelse}ifelse
}forall
pop counttomark 2 idiv{.forceundef}repeat pop}if//SharedFontDirectory exch .forcecopynew pop
.currentglobal .setglobal
pop}.bind odef
end
level2dict begin{/configurationerror/undefinedresource/unregistered}{.registererror}forall/.makestackdict
{{counttomark -1 roll}forall .dicttomark}bind def/currenthalftone{mark .currenthalftone{{exch pop}{/HalftoneType 1
{/Frequency/Angle/SpotFunction}.makestackdict readonly}{/HalftoneType 2{/RedFrequency/RedAngle/RedSpotFunction
/GreenFrequency/GreenAngle/GreenSpotFunction/BlueFrequency/BlueAngle/BlueSpotFunction/GrayFrequency/GrayAngle/GraySpotFunction}
.makestackdict readonly}}exch get exec}odef/.makehalftoneRGBV{4 -1 roll exch{1 index exch get exch}forall 15 1 roll
14 -2 roll mark 15 1 roll{/Gray/Blue/Green/Red}{mark
2 index 0 get 8 -1 roll
4 index 1 get 9 -1 roll
6 index 2 get 10 -1 roll/HalftoneType 10 index .dicttomark
counttomark 2 roll}forall pop pop/Default 1 index .dicttomark exch pop{.sethalftone5}}bind def
systemdict begin
15 dict/.halftonetypes 1 index def begin
1{mark exch/Default exch .dicttomark{.sethalftone5}}bind def
2{1{/Frequency/Angle/SpotFunction}{/RedFrequency/RedAngle/RedSpotFunction/GreenFrequency/GreenAngle/GreenSpotFunction
/BlueFrequency/BlueAngle/BlueSpotFunction/GrayFrequency/GrayAngle/GraySpotFunction}.makehalftoneRGBV}bind def
3{mark exch/Default exch .dicttomark{.sethalftone5}}bind def
4{3{/Width/Height/Thresholds}{/RedWidth/RedHeight/RedThresholds/GreenWidth/GreenHeight/GreenThresholds
/BlueWidth/BlueHeight/BlueThresholds/GrayWidth/GrayHeight/GrayThresholds}.makehalftoneRGBV}bind def
5{pop dup length dict copy
mark 1 index{dup type/dicttype ne{0}{dup/HalftoneType .knownget not{0}if}ifelse dup 5 gt{1 index 3 1 roll
//.halftonetypes exch get exec pop/Default get
counttomark 1 add index 3 index 4 -1 roll put}{pop}ifelse}forall .dicttomark{.sethalftone5}}bind def
end
end/sethalftone{.currentglobal 1 .argindex dup gcheck .setglobal
dup//.halftonetypes 1 index/HalftoneType get
dup type/integertype ne{/sethalftone .systemvar/typecheck signalerror}if
.knownget not{/sethalftone .systemvar/rangecheck signalerror}if
exec exec
.setglobal pop}.bind odef/.fixsethalftonescreen{dup dup/HalftoneType get 1 eq{dup wcheck not{dup length .copydict}if
dup/Frequency 5 index put
dup/Angle 4 index put
languagelevel 3 ge{dup/AccurateScreens dup getuserparam put}if}if}bind def/setscreen{dup type/dicttype eq
{.fixsethalftonescreen sethalftone pop pop pop}{//setscreen}ifelse}.bind odef/setcolorscreen{dup type/dicttype eq
{.fixsethalftonescreen sethalftone 12{pop}repeat}{//setcolorscreen}ifelse}.bind odef/.fixcurrenthalftonescreen
{dup/HalftoneType get 1 eq{dup/Frequency get 1 index/Angle get}{60.0 0.0}ifelse 3 2 roll}bind def/currentscreen
{.currenthalftone{{.fixcurrenthalftonescreen}{}{12 3 roll 9{pop}repeat
dup type/dicttype eq{.fixcurrenthalftonescreen}if}}exch get exec}odef/currentcolorscreen{.currenthalftone
{{.fixcurrenthalftonescreen 3 copy 6 copy}{dup rcheck{dup length array copy cvx}if
3 copy 6 copy}{}}exch get exec}odef/.UserObjects{.userdict/UserObjects}odef/defineuserobject{1 index 65535 gt{
/defineuserobject .systemvar/rangecheck signalerror}if
.UserObjects .knownget{length dup 3 .argindex le{2 index eq{1 index 2 mul}{1 index 1 add}ifelse
.localvmarray .UserObjects get
1 index copy pop
.UserObjects 3 -1 roll put}{pop}ifelse}{.UserObjects 3 .argindex 1 add 10 .max .localvmarray put}ifelse
.UserObjects get 2 .argindex 2 index put pop pop}odef/execuserobject{dup type/integertype ne{
/execuserobject .systemvar/typecheck signalerror}if
.UserObjects get 1 .argindex get exch pop exec}odef/undefineuserobject{dup type/integertype ne{
/undefineuserobject .systemvar/typecheck signalerror}if
.UserObjects get 1 .argindex//null put pop}odef/ucachestatus{mark 0 0 0 0/MaxUPathItem getuserparam}odef/setucacheparams{
counttomark 1 lt{()0 get}if
dup 0 or/MaxUPathItem getuserparam .max
1 dict dup/MaxUPathItem 4 -1 roll put setuserparams cleartomark}odef
end
/.buildfont1{.currentglobal 3 1 roll
dup .gcheck .setglobal
dup .fontbbox{pop pop pop pop
dup/FontInfo known not{.growfontdict dup/FontInfo 2 dict put}if
dup dup/FontInfo get dup dup/UnderlinePosition known exch/UnderlineThickness known and{pop pop}{dup length 2 add dict .copydict
dup/UnderlinePosition known not{dup/UnderlinePosition 3 index/FontBBox get
1 get 2 div put}if
dup/UnderlineThickness known not{dup/UnderlineThickness 3 index/FontBBox get
dup 3 get exch 1 get sub 20 div put}if
1 index/FontInfo get wcheck not{readonly}if/FontInfo exch put}ifelse}if//.buildfont1
3 2 roll .setglobal}bind def/.loadfontdict where{pop}{/.loadfontdict 0 dict readonly def}ifelse/.loadfontfile{mark exch
DISKFONTS{.loadfontdict begin}if/userdict .systemvar begin
currentpacking{//false setpacking .loadfont1//true setpacking}{.loadfont1}ifelse end{stop}if
DISKFONTS{end}if
cleartomark}bind def/closesourcedict mark/CloseSource//true
.dicttomark readonly def/.loadfont1{{dup read not{-1}if
2 copy unread 16#80 eq{dup//closesourcedict//true/PFBDecode filter cvx
exch .currentresourcefile eq{dup/.execasresource .systemvar}{{exec}}ifelse
2 index cvlit/closefile .systemvar 3 .execn}{cvx exec}ifelse}stopped}bind def
currentdict/closesourcedict .undef(%Type1BuildChar)cvn{1 index/Encoding get 1 index get .type1build .type1execchar}bind def
(%Type1BuildGlyph)cvn{dup .type1build .type1execchar}bind def/.type1build{2 index begin
dup CharStrings exch .knownget not{2 copy eq{exch pop/.notdef exch}if
QUIET not{(Substituting .notdef for )print
=string cvs print( in the font )print
1 index/FontName get = flush}{pop}ifelse/.notdef CharStrings/.notdef get}if
end}bind def
1183615869 internaldict begin/CCRun{dup type/dicttype eq{dup 4 index/Private .knownget{ne}{pop//true}ifelse{
.currentglobal//false .setglobal 10 dict exch .setglobal begin/Private exch def/FontType 1 def
/FontMatrix 3 index/FontMatrix get def/Encoding 3 index/Encoding .knownget not{StandardEncoding}if def
/FontBBox 3 index/FontBBox .knownget not{{0 0 0 0}}if def/PaintType 0 def/CharStrings 1 dict dup/.notdef()put def
3 -1 roll pop()currentdict end .buildfont1 exch pop 3 1 roll}{pop}ifelse}if
1 index dup type/integertype eq{3 index/Encoding get exch get}if exch .type1execchar}bind def/setweightvector{
dup type dup/arraytype ne exch/packedarraytype ne and
2 index type/dicttype ne or{/setweightvector cvx/typecheck signalerror}if
1 index/FontType known not{/setweightvector cvx/invalidfont signalerror}if
dup gcheck 2 index gcheck not and{/setweightvector cvx/invalidaccess signalerror}if
2 copy/WeightVector exch .forceput
.setweightvector}.bind executeonly def
end
buildfontdict 1/.buildfont1 cvx put
buildfontdict 4/.buildfont4 cvx put/.buildfont2 where not{(%END2).skipeof}if
pop(%Type2BuildChar)cvn{1 index/Encoding get 1 index get .type1build .type2execchar}bind def(%Type2BuildGlyph)cvn{
dup .type1build .type2execchar}bind def
buildfontdict 2/.buildfont2 cvx put
%END2
level2dict begin/.checkparamtype{exch type eq}.bind def/.checksetparams{2 .argindex{3 copy 3 1 roll .knownget{exec not{
pop pop pop load/typecheck signalerror}if
dup type/stringtype eq{dup rcheck not{pop pop pop load/invalidaccess signalerror}if}if}{pop}ifelse pop pop}forall pop pop
}.bind def/.copyparam{dup type/arraytype eq{.currentglobal true .setglobal exch
dup wcheck exch dup xcheck exch
dup length array exch dup{dup type/arraytype eq{dup 2 index ne{.copyparam}{pop 1 index}ifelse}{dup type/stringtype eq{
.copyparam}if}ifelse 3 1 roll}forall pop astore
exch{cvx}if
exch not{readonly}if
exch .setglobal}if
dup type/stringtype eq{dup wcheck exch
.currentglobal true .setglobal
1 index length string exch .setglobal
copy exch not{readonly}if}if}.bind def
systemdict begin/psuserparams 48 dict def/getuserparam{/userparams .systemvar 1 .argindex get exch pop}odef
mark .currentuserparams
counttomark 2 idiv{userparams 3 1 roll put}repeat pop/.definepsuserparam{psuserparams 3 copy pop
type cvlit/.checkparamtype cvx 2 packedarray cvx put
userparams 3 1 roll put}.bind def
end/currentuserparams{/userparams .systemvar dup length dict .copydict}odef/.setuserparams2{
/setuserparams/psuserparams .systemvar .checksetparams
dup .setuserparams
dup{/userparams .systemvar 2 index known{psuserparams 2 index known not{pop dup .getuserparam}if
.copyparam[/PermitFileReading/PermitFileWriting/PermitFileControl]{2 index eq{currentglobal exch dup gcheck setglobal
dup length array exch{readonly exch}forall astore
exch setglobal}if}forall
dup type dup/arraytype eq exch/stringtype eq or{readonly}if/userparams .systemvar 3 1 roll .forceput}{pop pop}ifelse}forall
.setuserparams}.bind def/setuserparams{.setuserparams2}.bind odef/JobName().definepsuserparam/restore{
//restore/userparams .systemvar .setuserparams}.bind odef
systemdict begin
currentdict/pssystemparams known not{/pssystemparams 40 dict readonly def}if/getsystemparam{
//pssystemparams 1 .argindex .knownget{exch pop}{.getsystemparam}ifelse}odef
end/currentsystemparams{mark .currentsystemparams//pssystemparams{}forall .dicttomark}odef/setsystemparams{dup pop
/SAFETY .systemvar/safe get{[/GenericResourceDir/FontResourceDir/GenericResourcePathSep]{2 copy .knownget{
exch//pssystemparams exch .knownget{ne{/setsystemparams/invalidaccess signalerror}if}{pop}ifelse}{pop}ifelse}forall}if
/setsystemparams//pssystemparams mark exch{type cvlit/.checkparamtype cvx 2 packedarray cvx}forall .dicttomark .checksetparams
dup .setsystemparams
dup{//pssystemparams 2 index known{.copyparam
dup type dup/arraytype eq exch/stringtype eq or{readonly}if//pssystemparams 3 1 roll .forceput}{pop pop}ifelse}forall pop
}.bind odef/StartJobPassword 65 string noaccess def/SystemParamsPassword 65 string noaccess def/setcachelimit{
{mark/MaxFontItem 2 .argindex .dicttomark setuserparams pop}stopped{/setcachelimit .systemvar $error/errorname get signalerror
}if}.bind odef/setcacheparams{counttomark 1 add copy setcacheparams
currentcacheparams
3 -1 roll pop/MinFontCompress 3 1 roll/MaxFontItem exch
.dicttomark{setuserparams cleartomark}stopped{/setcacheparams .systemvar $error/errorname get signalerror}if}.bind odef
/MaxFormItem 100000 .definepsuserparam/MaxPatternItem 20000 .definepsuserparam/MaxScreenItem 48000 .definepsuserparam
/MaxUPathItem 0 .definepsuserparam
.currentglobal true .setglobal/.checkFilePermitparams{type/arraytype eq{currentuserparams/LockFilePermissions get{
5{pop}repeat/setuserparams/invalidaccess signalerror}{dup{readonly exch}forall
.currentglobal exch dup gcheck .setglobal length array exch .setglobal
astore readonly}ifelse}{5{pop}repeat/setuserparams/typecheck signalerror}ifelse
true}.bind def/PermitFileReading dup[(*)].definepsuserparam
psuserparams exch/.checkFilePermitparams load put/PermitFileWriting dup[(*)].definepsuserparam
psuserparams exch/.checkFilePermitparams load put/PermitFileControl dup[(*)].definepsuserparam
psuserparams exch/.checkFilePermitparams load put
.setglobal
pssystemparams begin/CurDisplayList 0 .forcedef/CurFormCache 0 .forcedef/CurInputDevice().forcedef/CurOutlineCache 0 .forcedef
/CurOutputDevice().forcedef/CurPatternCache 0 .forcedef/CurUPathCache 0 .forcedef/CurScreenStorage 0 .forcedef
/CurSourceList 0 .forcedef/DoPrintErrors false .forcedef/JobTimeout 0 .forcedef/LicenseID(LN-001).forcedef
/MaxDisplayList 140000 .forcedef/MaxFormCache 100000 .forcedef/MaxImageBuffer 524288 .forcedef/MaxOutlineCache 65000 .forcedef
/MaxPatternCache 100000 .forcedef/MaxUPathCache 300000 .forcedef/MaxScreenStorage 84000 .forcedef/MaxSourceList 25000 .forcedef
/PrinterName product .forcedef/RamSize 4194304 .forcedef/WaitTimeout 40 .forcedef
end/.checkprocesscomment{dup null eq{pop true}{dup xcheck{type dup/arraytype eq exch/packedarraytype eq or}{pop false}ifelse
}ifelse}.bind def/ProcessComment null .definepsuserparam
psuserparams/ProcessComment{.checkprocesscomment}put(%ProcessComment)cvn{/ProcessComment getuserparam
dup null eq{pop pop pop}{exec}ifelse}bind def/ProcessDSCComment null .definepsuserparam
psuserparams/ProcessDSCComment{.checkprocesscomment}put/.loadingfont false def(%ProcessDSCComment)cvn{
/ProcessDSCComment getuserparam
dup null eq .loadingfont or{pop pop pop}{exec}ifelse}bind def(<<)cvn/mark load def/languagelevel 2 def
/version(2017)readonly def/setobjectformat where{pop/RealFormat getsystemparam(IEEE)eq{1}{3}ifelse
/ByteOrder getsystemparam{1 add}if
setobjectformat}if
.wheredict/setcolor{/FreeHandDict .where{/FreeHandDict get currentdict eq{
pop currentdict/setcolor known{currentdict true}{false}ifelse}{.where}ifelse}{.where}ifelse}bind put/currentglobal
/currentshared load def/gcheck/scheck load def/setglobal/setshared load def
/globaldict currentdict/shareddict .knownget not{4 dict}if def/GlobalFontDirectory SharedFontDirectory def/setvmthreshold{
mark/VMThreshold 2 .argindex .dicttomark .setuserparams2 pop}odef/vmreclaim{dup 0 gt{.vmreclaim}{
mark/VMReclaim 2 index .dicttomark .setuserparams2 pop}ifelse}odef
-1 setvmthreshold/.getdevparams where{pop/currentdevparams{.getdevparams .dicttomark}odef}if/.putdevparams where{
pop/setdevparams{dup type/dicttype ne{/setdevparams .systemvar/typecheck signalerror}if
mark 1 index{}forall counttomark 2 add index
.putdevparams pop pop}odef}if
serverdict begin/.jobsave//null def/.jobsavelevel 0 def/.adminjob//true def
end/.startnewjob{serverdict/.jobsave get dup//null eq{pop}{restore}ifelse
exch{serverdict/.jobsave//null put
serverdict/.jobsavelevel 0 put
serverdict/.adminjob 3 -1 roll 1 gt put}{pop
serverdict/.jobsave save put
serverdict/.jobsavelevel 1 put
.userdict/quit{stop}.bind put}ifelse
clear cleardictstack
initgraphics//false setglobal
2 vmreclaim}bind def/.startjob{vmstatus pop pop serverdict/.jobsavelevel get eq
2 .argindex .checkpassword 0 gt and{exch .checkpassword exch count 3 roll count 3 sub{pop}repeat
cleardictstack
2 .stop}{pop pop pop//false}ifelse}odef/startjob{1 .argindex type/booleantype ne{/startjob .systemvar/typecheck signalerror}if
{.startnewjob//true}.startjob}odef/.endjob{clear cleardictstack
serverdict/.jobsave get dup//null eq{pop}{restore}ifelse
serverdict/.jobsave//null put
2 vmreclaim}odef
systemdict begin/quit{//systemdict begin serverdict/.jobsave get null eq{end//quit}
{/quit .systemvar/invalidaccess/signalerror load end exec}ifelse}bind odef
end
serverdict begin/exitserver{//true exch{.startnewjob}.startjob not{/exitserver/invalidaccess signalerror}if}bind def
end/.dict1{exch mark 3 1 roll .dicttomark}bind def
currentglobal false setglobal 25 dict exch setglobal begin
currentsystemparams/buildtime 1 index/BuildTime get def
systemdict/buildtime dup load put/byteorder 1 index/ByteOrder get def/checkpassword{.checkpassword 0 gt}bind def
dup/DoStartPage known{/dostartpage{/DoStartPage getsystemparam}bind def
/setdostartpage{/DoStartPage .dict1 setsystemparams}bind def}if
dup/StartupMode known{/dosysstart{/StartupMode getsystemparam 0 ne}bind def
/setdosysstart{{1}{0}ifelse/StartupMode .dict1 setsystemparams}bind def}if/jobname{/JobName getuserparam}bind def
/jobtimeout{/JobTimeout getuserparam}bind def/ramsize{/RamSize getsystemparam}bind def/realformat 1 index/RealFormat get def
dup/PrinterName known{/setprintername{/PrinterName .dict1 setsystemparams}bind def}if/printername
{currentsystemparams/PrinterName .knownget not{()}if exch copy}bind def
currentuserparams/WaitTimeout known{/waittimeout{/WaitTimeout getuserparam}bind def}if
/.setpagedevice where{pop}{(%END PAGEDEVICE).skipeof}ifelse/defaulttimeouts{currentsystemparams dup
/JobTimeout .knownget not{0}if
exch/WaitTimeout .knownget not{0}if
currentpagedevice/ManualFeedTimeout .knownget not{0}if}bind def/margins{currentpagedevice/Margins .knownget{exch}{[0 0]}ifelse
}bind def/pagemargin{currentpagedevice/PageOffset .knownget{0 get}{0}ifelse}bind def/pageparams{currentpagedevice
dup/Orientation .knownget{1 and ORIENT1{1 xor}if}{0}ifelse exch
dup/PageSize get aload pop 3 index 0 ne{exch}if 3 2 roll/PageOffset .knownget{0 get}{0}ifelse 4 -1 roll}bind def
/setdefaulttimeouts{exch mark/ManualFeedTimeout 3 -1 roll/Policies mark/ManualFeedTimeout 1 .dicttomark
.dicttomark setpagedevice/WaitTimeout exch mark/JobTimeout 5 2 roll .dicttomark setsystemparams}bind def
/.setpagesize{2 array astore/PageSize .dict1 setpagedevice}bind def/setduplexmode{/Duplex .dict1 setpagedevice}bind def
/setmargins{exch 2 array astore/Margins .dict1 setpagedevice}bind def
/setpagemargin{0 2 array astore/PageOffset .dict1 setpagedevice}bind def/setpageparams{mark/PageSize 6 -2 roll
4 index 1 and ORIENT1{1}{0}ifelse ne{exch}if 2 array astore/Orientation 5 -1 roll ORIENT1{1 xor}if
/PageOffset counttomark 2 add -1 roll 0 2 array astore
.dicttomark setpagedevice}bind def/setresolution{dup 2 array astore/HWResolution .dict1 setpagedevice}bind def
%END PAGEDEVICE
pop/statusdict currentdict def
currentdict end/statusdict exch .forcedef/devforall{exch{1 index currentdevparams/Type .knownget{/FileSystem eq}{false}ifelse
{exec}{pop pop}ifelse}/exec load 3 packedarray cvx exch(*)3 1 roll/IODevice resourceforall}odef/devstatus{dup length 5 ge{
dup 0 5 getinterval(%disk)eq{dup/IODevice resourcestatus{pop pop dup currentdevparams
dup/Searchable get
exch dup/Writeable get
exch dup/HasNames get
exch dup/Mounted get
exch dup/Removable get
exch dup/SearchOrder get
exch dup/Free get
exch/LogicalSize get
9 -1 roll pop true}{pop false}ifelse}{pop false}ifelse}{pop false}ifelse}odef
level2dict/setcolorspace .cspace_util 1 index get put
level2dict/setcolor .cspace_util 1 index get put
level2dict/colorspacedict .cspace_util 1 index get put
/.setdevicepixelspace where{pop}{currentfile closefile}ifelse
.currentglobal true .setglobal
.cspace_util begin
colorspacedict/DevicePixel
mark/cs_potential_indexed_base true/cs_potential_pattern_base true/cs_potential_alternate true/cs_potential_icc_alternate true
/cs_get_ncomps//ncomps_1/cs_get_range{[exch 1 get 1 exch bitshift 1 sub]}bind/cs_get_default_color{pop 0}bind
/cs_get_currentgray//no_currentgray/cs_get_currentrgb//no_currentrgb/cs_get_currentcmyk//no_currentcmyk/cs_validate{
//check_array exec
dup 1 get dup type/integertype ne//setcspace_typecheck
if
dup 0 lt//setcspace_rangecheck
if
31 gt{/setcolorspace .systemvar/limitcheck signalerror}if}bind/cs_substitute//dup_1/cs_prepare{}
/cs_install{.setdevicepixelspace}bind/cs_prepare_color//validate_1/cs_complete_setcolor//pop_1
.dicttomark
put
end
.setglobal
true{/.setcieaspace/.setcieabcspace/.setciedefspace/.setciedefgspace}{where{pop not exit}if}forall{currentfile closefile}if
.currentglobal true .setglobal
.cspace_util begin/check_cie_cspace{//check_array exec
dup 1 get type/dicttype ne//setcspace_typecheck
if}bind def/.setcieaspace where{pop
colorspacedict/CIEBasedA
mark/cs_potential_indexed_base true/cs_potential_pattern_base true/cs_potential_alternate true/cs_potential_icc_alternate true
/cs_get_ncomps//ncomps_1/cs_get_range{1 get/RangeA .knownget not{//dflt_range_1}if}bind/cs_get_default_color{pop 0}bind
/cs_get_currentgray//no_currentgray/cs_get_currentrgb//no_currentrgb/cs_get_currentcmyk//no_currentcmyk
/cs_validate//check_cie_cspace/cs_substitute//dup_1/cs_prepare{}/cs_install{NOCIE{pop/DeviceGray//.cs_install exec}
{1 get .setcieaspace}ifelse}bind/cs_prepare_color//validate_1/cs_complete_setcolor//pop_1
.dicttomark
put}if/.setcieabcspace where{pop
colorspacedict/CIEBasedABC
mark/cs_potential_indexed_base true/cs_potential_pattern_base true/cs_potential_alternate true/cs_potential_icc_alternate true
/cs_get_ncomps//ncomps_3/cs_get_range{1 get/RangeABC .knownget not{//dflt_range_3}if}bind/cs_get_default_color{pop 0 0 0}bind
/cs_get_currentgray//no_currentgray/cs_get_currentrgb//no_currentrgb/cs_get_currentcmyk//no_currentcmyk
/cs_validate//check_cie_cspace/cs_substitute//dup_1/cs_prepare{}/cs_install{NOCIE{pop/DeviceRGB//.cs_install exec}
{1 get .setcieabcspace}ifelse}bind/cs_prepare_color//validate_3/cs_complete_setcolor//pop_1
.dicttomark
put}if
end
.setglobal
/.setindexedspace where{pop}{currentfile closefile}ifelse
.currentglobal true .setglobal
.cspace_util begin/restrict_index{exch round cvi
dup 0 lt{pop 0}{1 index 2 get 2 copy gt{exch}if
pop}ifelse
exch}bind def/get_indexed_base_color{//restrict_index exec
mark 1 index 3 get dup type/stringtype eq{2 index 1 get//.cs_get_ncomps exec dup 6 -1 roll mul exch getinterval{255 div}forall}
{4 -1 roll exch exec}ifelse
counttomark 2 add -2 roll pop}bind def
colorspacedict/Indexed
mark/cs_potential_indexed_base false/cs_potential_pattern_base true/cs_potential_alternate false
/cs_potential_icc_alternate false/cs_get_ncomps//ncomps_1/cs_get_range{0 exch 2 get 2 array astore}bind
/cs_get_default_color{pop 0}bind/cs_get_currentgray{//get_indexed_base_color exec 1 get//.cs_get_currentgray exec}bind
/cs_get_currentrgb{//get_indexed_base_color exec 1 get//.cs_get_currentrgb exec}bind/cs_get_currentcmyk
{//get_indexed_base_color exec 1 get//.cs_get_currentcmyk exec}bind/cs_validate{//check_array exec
dup 1 get//.cs_validate exec//.cs_potential_indexed_base exec not//setcspace_rangecheck
if
dup 2 get dup type/integertype ne//setcspace_typecheck{dup 0 lt exch 4095 gt or//setcspace_rangecheck
if}ifelse
dup 3 get dup type/stringtype eq{length
1 index dup 2 get 1 add exch 1 get//.cs_get_ncomps exec mul
lt//setcspace_rangecheck
if}{//check_array exec xcheck not//setcspace_typecheck
if}ifelse}bind/cs_substitute{dup 1 get//.cs_substitute exec 2 copy eq{pop pop dup}{exch pop
.currentglobal 3 1 roll//false .setglobal
1 index dup length array copy dup 1 4 -1 roll put
3 -1 roll .setglobal}ifelse}bind/cs_prepare{}/cs_install{currentcolorspace
1 index 1 get//forcesetcolorspace
mark 2 index{.setindexedspace}stopped{cleartomark setcolorspace stop}{pop pop pop}ifelse}bind
/cs_prepare_color{//validate_1 exec cvi}bind/cs_complete_setcolor{3 get dup type/stringtype eq{pop}{currentcolor exch exec
currentcolorspace 1 get//clear_setcolor_operands exec}ifelse}bind
.dicttomark
put
end
.setglobal
/.setseparationspace where{pop}{currentfile closefile}ifelse
.currentglobal true .setglobal
.cspace_util begin/apply_sepr_tint_xform{exch//bound_0_1 exec
mark exch 2 index 3 get exec
counttomark{cvr counttomark -1 roll}repeat
counttomark 2 add -2 roll pop}bind def/build_tintxform_function{dup 3 get dup .isencapfunction not{
.currentglobal exch//false .setglobal
6 dict begin/FunctionType 4 def/Function exch def/Domain 2 index//.cs_get_range exec def
/Range 2 index 2 get//.cs_get_range exec def
currentdict end{.buildfunction}.internalstopped{dup/Order 3 put
dup/BitsPerSample 16 put{.buildsampledfunction}.internalstopped{dup/Function{}put
.buildfunction}if}if
exch .setglobal}if}bind def/converttinttransform{//build_tintxform_function exec
1 index 3 get 2 copy eq{pop pop}{pop
3 copy pop eq{.currentglobal//false .setglobal
3 -1 roll dup length array copy 3 1 roll
.setglobal}if
1 index exch 3 exch put}ifelse}bind def
colorspacedict/Separation
mark/cs_potential_indexed_base true/cs_potential_pattern_base true/cs_potential_alternate false
/cs_potential_icc_alternate false/cs_get_ncomps//ncomps_1/cs_get_range//get_range_1/cs_get_default_color{pop 1}bind
/cs_get_currentgray{//apply_sepr_tint_xform exec 2 get//.cs_get_currentgray exec}bind/cs_get_currentrgb
{//apply_sepr_tint_xform exec 2 get//.cs_get_currentrgb exec}bind/cs_get_currentcmyk
{//apply_sepr_tint_xform exec 2 get//.cs_get_currentcmyk exec}bind/cs_validate{//check_array exec
dup 1 get type dup/nametype ne exch/stringtype ne and//setcspace_typecheck
if
dup 2 get//.cs_validate exec//.cs_potential_alternate exec not//setcspace_rangecheck
if
dup 3 get//check_array exec xcheck not//setcspace_typecheck
if}bind/cs_substitute{dup 2 get//.cs_substitute exec 2 copy eq{pop pop dup}{exch pop
.currentglobal 3 1 roll//false .setglobal
1 index dup length array copy dup 2 4 -1 roll put
3 -1 roll .setglobal}ifelse}bind/cs_prepare//converttinttransform/cs_install{currentcolorspace
1 index 2 get//forcesetcolorspace
mark 2 index{.setseparationspace}stopped{cleartomark setcolorspace stop}{pop pop pop}ifelse}bind/cs_prepare_color//validate_1
/cs_complete_setcolor{.usealternate{currentcolor exch 3 get exec
currentcolorspace 2 get//clear_setcolor_operands exec}{pop}ifelse}bind
.dicttomark
put
end
.setglobal
/.setpatternspace where{pop}{currentfile closefile}ifelse
.currentglobal true .setglobal
.cspace_util begin/get_pattern_base_cspace{dup type/nametype eq{pop//null}{dup length 1 gt{1 get}{pop//null}ifelse}ifelse}
bind def/has_base_color{dup//null eq{pop//false}{dup/PatternType get 1 eq{/PaintType get 2 eq}{pop//false}ifelse}ifelse}
bind def/get_pattern_base_color{exch//has_base_color exec{1 get//true}{pop//false}ifelse}bind def
colorspacedict/Pattern
mark/cs_potential_indexed_base false/cs_potential_pattern_base false/cs_potential_alternate false
/cs_potential_icc_alternate false/cs_get_ncomps{//get_pattern_base_cspace exec dup//null eq{pop 0}//.cs_get_ncomps
ifelse
1 add neg}bind/cs_get_range{{}cvlit}bind/cs_get_default_color{pop//null}bind/cs_get_currentgray{//get_pattern_base_color exec
//.cs_get_currentgray{0.}ifelse}bind/cs_get_currentrgb{//get_pattern_base_color exec//.cs_get_currentrgb{0. 0. 0.}ifelse}bind
/cs_get_currentcmyk{//get_pattern_base_color exec//.cs_get_currentcmyk{0. 0. 0. 1.}ifelse}bind/cs_validate{
dup//get_pattern_base_cspace exec dup//null eq{pop}{//.cs_validate exec//.cs_potential_pattern_base exec not
//setcspace_rangecheck
if}ifelse}bind/cs_substitute{dup//get_pattern_base_cspace exec dup//null eq{pop dup}{//.cs_substitute exec 2 copy eq
{pop pop dup}{exch pop
.currentglobal 3 1 roll//false .setglobal
1 index dup length array copy dup 1 4 -1 roll put
3 -1 roll .setglobal}ifelse}ifelse}bind/cs_prepare{}/cs_install{dup//get_pattern_base_cspace exec dup//null eq{pop
dup type/nametype eq{pop{/Pattern}cvlit}if
.setpatternspace}{currentcolorspace
exch//forcesetcolorspace
mark 2 index{.setpatternspace}stopped{cleartomark setcolorspace stop}{pop pop pop}ifelse}ifelse}bind/cs_prepare_color{
1 index dup type/dicttype ne{//null ne//setcspace_typecheck
if
pop}{dup/Implementation .knownget{0 get type dup dup/gs_pattern1_instance_t ne exch/gs_pattern2_instance_t ne and
exch xcheck not
or//setcspace_typecheck
if}//setcspace_typecheck
ifelse
dup/PatternType get 1 eq{/PaintType get 2 eq{//get_pattern_base_cspace exec dup//null eq//setcspace_rangecheck
if//.cs_get_ncomps exec
1 exch 1 exch{index type dup/integertype ne exch/realtype ne and//setcolor_typecheck
if}for}{pop}ifelse}{pop pop}ifelse}ifelse}bind/cs_complete_setcolor//pop_1
.dicttomark
put
end
.setglobal
/findcolorrendering{/findcolorrendering{/ColorRendering/ProcSet findresource
1 .argindex dup type/nametype eq{.namestring}if(.)concatstrings
1 index/GetPageDeviceName get exec dup type/nametype eq{.namestring}if(.)concatstrings
2 index/GetHalftoneName get exec dup type/nametype eq{.namestring}if
concatstrings concatstrings cvn
dup/ColorRendering resourcestatus{pop pop exch pop exch pop true}{pop/GetSubstituteCRD get exec false}ifelse}.errorexec}odef
5 dict dup begin/GetPageDeviceName{currentpagedevice dup/PageDeviceName .knownget{exch pop dup null eq{pop/none}if}{pop/none
}ifelse}bind def/GetHalftoneName{currenthalftone/HalftoneName .knownget not{/none}if}bind def/GetSubstituteCRD{
pop/DefaultColorRendering}bind def
end/ColorRendering exch def/.colorrenderingtypes 5 dict def/setcolorrendering{dup/ColorRenderingType get
dup type/integertype ne{/setcolorrendering .systemvar/typecheck signalerror}if//.colorrenderingtypes exch .knownget{exec}{
/setcolorrendering .systemvar/rangecheck signalerror}ifelse}odef/.setcolorrendering1 where{pop}{(%END CRD).skipeof}ifelse
.colorrenderingtypes 1{dup/Intent .knownget{//.renderingintentdict exch .knownget{.setrenderingintent}if}if
dup .buildcolorrendering1 .setcolorrendering1}.bind put
.colorrenderingtypes 101{dup .builddevicecolorrendering1 .setdevicecolorrendering1}.bind put
mark/ColorRenderingType 1/RangePQR[-0.5 2 -0.5 2 -0.5 2]readonly/MatrixPQR[0.8951 -0.7502 0.0389
0.2664 1.7135 -0.0685
-0.1614 0.0367 1.0296]readonly/MatrixLMN[3.240449 -0.969265 0.055643
-1.537136 1.876011 -0.204026
-0.498531 0.041556 1.057229]readonly/EncodeABC[{dup 0.00304 le{12.92321 mul}{1 2.4 div exp 1.055 mul 0.055 sub}ifelse
}bind dup dup]readonly/WhitePoint[0.9505 1 1.0890]readonly/BlackPoint[0 0 0]readonly/TransformPQR[{.TransformPQR_scale_WB0}bind
{.TransformPQR_scale_WB1}bind{.TransformPQR_scale_WB2}bind]readonly
.dicttomark setcolorrendering
%END CRD
/CIEsRGB[/CIEBasedABC
mark/DecodeLMN[{dup 0.03928 le{12.92321 div}{0.055 add 1.055 div 2.4 exp}ifelse}bind dup dup]readonly/MatrixLMN[
0.412457 0.212673 0.019334
0.357576 0.715152 0.119192
0.180437 0.072175 0.950301]readonly/WhitePoint[0.9505 1.0 1.0890]readonly
.dicttomark readonly]readonly def/.execform1{dup/Matrix get concat
dup/BBox get aload pop
exch 3 index sub exch 2 index sub rectclip
dup/PaintProc get
1 index/Implementation known not{1 index dup/Implementation null .forceput readonly pop}if
exec}.bind odef/.formtypes 5 dict
dup 1/.execform1 load put
def/execform{gsave{dup/FormType get//.formtypes exch get exec}stopped grestore{stop}if}odef/.patterntypes 5 dict
dup 1/.buildpattern1 load put
def/makepattern{dup type/dicttype eq{/makepattern .systemvar/typecheck signalerror}if
//.patterntypes 2 .argindex/PatternType get .knownget not{/makepattern .systemvar/rangecheck signalerror}if
.currentglobal false .setglobal exch
3 index dup length 1 add dict .copydict
3 index 3 -1 roll exec
1 index/Implementation 3 -1 roll gstate 2 array astore
put
readonly exch .setglobal exch pop exch pop}odef/setpattern{{currentcolorspace 0 get/Pattern ne{
[/Pattern currentcolorspace]setcolorspace}if setcolor}stopped{/setpattern .systemvar $error/errorname get signalerror}if}odef
/NO_TN5044 where{pop(%END TN 5044 psuedo-ops).skipeof}if/findcmykcustomcolor{5 array astore}bind def/buildcustomtinttransform
{[/dup load 2 index 0 get/mul load/exch load/dup load 6 index 1 get/mul load/exch load/dup load 10 index 2 get/mul load
/exch load 13 index 3 get/mul load]cvx bind
exch pop}bind def/setcustomcolor{dup//null ne{[/Separation 3 index 4 get/DeviceCMYK
5 index//buildcustomtinttransform exec]setcolorspace
setcolor
pop}{pop}ifelse}bind def/setcmykoverprint{4{dup -1 eq{pop 0}if 4 1 roll}repeat setcmykcolor}bind def
/separation_all[/Separation/All/DeviceCMYK{dup dup dup}bind]readonly def/args2dict{10 dict begin{1 0}1
{/ImageType/Decode/DataSource/ImageMatrix/BitsPerComponent/Height/Width}{exch def}forall
currentdict end}bind def/setseparationgray{//separation_all setcolorspace
1 exch sub setcolor}bind def/customcolorimage{gsave
[/Separation 2 index 4 get/DeviceCMYK 5 -1 roll//buildcustomtinttransform exec]setcolorspace//args2dict exec image
grestore}bind def/separationimage{gsave//separation_all setcolorspace//args2dict exec image
grestore}bind def{/buildcustomtinttransform/separation_all/args2dict}{currentdict exch undef}forall
%END TN 5044 psuedo-ops
end
level2dict begin(BEGIN RESOURCES)VMDEBUG
currentglobal false setglobal systemdict begin/localinstancedict 5 dict
.forcedef
end true setglobal/.emptydict 0 dict readonly def
setglobal/.findcategory{/Category .findresource begin}bind def/.undefinedresource{
/Category dup load eq{/undefined}{/undefinedresource}ifelse
signaloperror}bind def/.resourceexec{load exec end}bind def/.getvminstance{.GetInstance{dup 1 get 2 ne{true}{pop false}ifelse}{
false}ifelse}bind def
20 dict begin/Category/Category def/InstanceType/dicttype def/DefineResource{.CheckResource{dup/Category 3 index cvlit .growput
dup[exch 0 -1]exch
.Instances 4 2 roll put
readonly}{/defineresource cvx/typecheck signaloperror}ifelse}bind def/FindResource{.Instances exch get 0 get}bind def
/.Instances 30 dict def
.Instances/Category[currentdict 0 -1]put/.LocalInstances 0 dict def/.GetInstance{.Instances exch .knownget}bind def
/.CheckResource{dup gcheck currentglobal and{/DefineResource/FindResource/ResourceForAll/ResourceStatus/UndefineResource}
{2 index exch known and}forall
not{/defineresource cvx/invalidaccess signaloperror}if
true}bind def
.Instances end begin(END CATEGORY)VMDEBUG/.findresource{2 copy dup/Category eq{pop//Category 0 get begin}{.findcategory}ifelse
/FindResource .resourceexec exch pop exch pop}bind
end
def/findresource{1 .argindex
dup type/stringtype eq{cvn}if
3 1 roll exch pop
dup type/nametype ne{/findresource .systemvar/typecheck signalerror}if/findresource cvx//.findresource .errorexec}odef
/defineresource{2 .argindex 2 index 2 index/defineresource cvx{.findcategory
currentdict/InstanceType known{dup type InstanceType ne{dup type/packedarraytype eq InstanceType/arraytype eq and
not{/defineresource cvx/typecheck signaloperror}if}if}if/DefineResource .resourceexec
4 1 roll pop pop pop}.errorexec}bind odef/resourceforall1{dup .findcategory/ResourceForAll load
exch pop
exec end}bind def/resourceforall{//resourceforall1 exec}bind odef/resourcestatus{{0 .argindex type/nametype ne{
/resourcestatus cvx/typecheck signalerror}if
2 copy .findcategory/ResourceStatus .resourceexec{4 2 roll pop pop true}{pop pop false}ifelse}stopped{
/resourcestatus cvx $error/errorname get signalerror}if}bind odef/undefineresource{0 .argindex type/nametype ne{
/undefinedresource cvx/typecheck signaloperror}if
1 .argindex 1 index{.findcategory/UndefineResource .resourceexec pop pop}stopped{
/undefineresource cvx $error/errorname get signalerror}if}bind odef
systemdict begin/.default_resource_dir{.file_name_parent .file_name_directory_separator concatstrings(Resource)concatstrings
/LIBPATH .systemvar{dup .file_name_current eq{pop}{1 index false .file_name_combine{exch pop exit}{pop pop}ifelse}ifelse}forall
}bind def/.resource_dir_name{systemdict 2 index .knownget{exch pop
systemdict 1 index undef}{dup()ne{.file_name_directory_separator concatstrings}if
2 index exch false .file_name_combine not{
(Error: .default_resource_dir returned )print exch print( that can't combine with )print =
/.default_resource_dir cvx/configurationerror signalerror}if}ifelse}bind def
currentdict/pssystemparams known not{/pssystemparams 10 dict readonly def}if
pssystemparams begin
.default_resource_dir/FontResourceDir(Font).resource_dir_name
readonly .forcedef/GenericResourceDir().resource_dir_name
readonly .forcedef
pop/GenericResourcePathSep
.file_name_separator readonly .forcedef(%diskFontResourceDir)cvn(/Resource/Font/)readonly .forcedef
(%diskGenericResourceDir)cvn(/Resource/)readonly .forcedef
end
end(x)pssystemparams/GenericResourcePathSep get(y)concatstrings concatstrings dup length
pssystemparams/GenericResourceDir get dup length exch
3 index true .file_name_combine not{exch(File name )print print( cant combine with )print =
/GenericResourceDir cvx/configurationerror signaloperror}if
dup length
4 2 roll add
ne{(GenericResourceDir value does not end with directory separator.\n)=/GenericResourceDir cvx/configurationerror signaloperror
}if
pop pop/.rfnstring 8192 string def/.genericrfn{3 -1 roll//.rfnstring cvs concatstrings exch copy}bind def/Generic mark
/Category null/.enumerateresource{1 index type dup/stringtype eq exch/nametype eq or{exch 1 index 2 get cvs exch}if
1 get false .setstackprotect exec true .setstackprotect}bind def/.localresourceforall{exch pop
2 copy 0 get .stringmatch{.enumerateresource}{pop pop}ifelse}bind def/.globalresourceforall{exch pop
2 copy 0 get .stringmatch{dup 3 get begin .LocalInstances end 2 index known not{.enumerateresource}{pop pop}ifelse}{pop pop
}ifelse}bind def/.externalresourceforall{3 1 roll 1 index length 1 index sub getinterval exch
dup 3 get begin .Instances .LocalInstances end
3 index known{pop pop pop}{2 index known{pop pop}{.enumerateresource}ifelse}ifelse}bind def/DefineResource{.CheckResource
{dup[exch 0 -1]currentglobal{false setglobal 2 index UndefineResource
true setglobal
.Instances dup//.emptydict eq{pop 3 dict/.Instances 1 index .forcedef}if}{.LocalInstances dup//.emptydict eq
{pop 3 dict localinstancedict Category 2 index put}if}ifelse
3 index 2 index .growput
0 2 copy get{readonly}.internalstopped pop
dup 4 1 roll put exch pop exch pop}{/defineresource cvx/typecheck signaloperror}ifelse}.bind executeonly/UndefineResource
{{dup 2 index .knownget{dup 1 get 1 ge{dup 0 null put 1 2 put pop pop}{pop exch .undef}ifelse}{pop pop}ifelse}currentglobal
{2 copy .Instances exch exec}if .LocalInstances exch exec}bind/FindResource{dup//null eq{
/findresource cvx/typecheck signaloperror}if
dup .getvminstance{exch pop 0 get}{dup ResourceStatus{pop 1 gt{.DoLoadResource .getvminstance not{
/findresource cvx .undefinedresource}if 0 get}{.GetInstance pop 0 get}ifelse}{/findresource cvx .undefinedresource}ifelse
}ifelse}bind/ResourceStatus{dup .GetInstance{exch pop dup 1 get exch 2 get true}{.ResourceFileStatus}ifelse}bind
/.ResourceFileStatus{.ResourceFile{closefile 2 -1 true}{pop false}ifelse}bind/ResourceForAll{currentdict 4 .localvmpackedarray
.currentglobal not{.LocalInstances length 0 ne{//.localresourceforall{exec}0 get 3 .localvmpackedarray cvx
.LocalInstances exch{forall}0 get 1 index 0 get
currentdict end 3 .execn begin}if}if//.globalresourceforall{exec}0 get 3 .localvmpackedarray cvx
.Instances exch cvx{forall}0 get 1 index 0 get
currentdict end 3 .execn begin
mark
Category .namestring .file_name_separator concatstrings
2 index 0 get
dup length 3 1 roll
concatstrings[true/LIBPATH .systemvar 3 index
.generate_dir_list_templates_with_length
true[currentsystemparams/GenericResourceDir get]counttomark 1 add index .generate_dir_list_templates_with_length
true[currentsystemparams/GenericResourceDir get]counttomark 1 add index .file_name_separator(*)
concatstrings concatstrings .generate_dir_list_templates_with_length]exch pop
dup length 1 sub 0 exch 2 exch{2 copy get
exch 2 index exch 1 add get
exch{dup length
2 index sub
2 index exch
getinterval cvn dup
5 2 roll}//.rfnstring filenameforall
pop}for
pop pop
.dicttomark{pop}0 get
2 index 2 get{cvs 0}aload pop 5 index//.externalresourceforall{exec}0 get
7 .localvmpackedarray cvx
3 2 roll pop{forall}0 get
currentdict end 2 .execn begin}bind/.file_name_is_iodevice_or_absolute{{dup length 0 gt{dup 0 get(%)0 get eq{pop true exit}if
}if
.file_name_is_absolute exit}loop}bind def/ResourceFileName{exch//.rfnstring cvs/GenericResourcePathSep getsystemparam exch
Category .namestring
3 1 roll
concatstrings concatstrings/GenericResourceDir getsystemparam//.file_name_is_iodevice_or_absolute exec not{
/GenericResourceDir getsystemparam exch concatstrings
findlibfile{pop exch copy true}{false}ifelse}{false}ifelse
not{/GenericResourceDir getsystemparam
dup length exch
3 index copy pop
1 index length
3 index 3 copy pop
getinterval
4 3 roll exch
copy pop
add 0 exch getinterval}if}bind/.Instances//.emptydict/.LocalInstances{localinstancedict Category .knownget not{//.emptydict}if
}bind/.GetInstance{currentglobal{.Instances exch .knownget}{.LocalInstances 1 index .knownget{exch pop true}
{.Instances exch .knownget}ifelse}ifelse}bind/.CheckResource{true}bind/.vmused{0 2{.currentglobal not .setglobal
vmstatus pop exch pop add}repeat}bind def/.DoLoadResource{count 1 index cvlit .vmused{.LoadResource}4 1 roll 4 .execn
.vmused exch sub
1 index .getvminstance not{pop dup .undefinedresource}if
dup 1 1 put
2 3 -1 roll put
exch count 1 sub exch sub{exch pop}repeat}bind/.LoadResource{dup .ResourceFile{exch pop currentglobal{.runresource}
{true setglobal{.runresource}stopped false setglobal{stop}if}ifelse}{dup .undefinedresource}ifelse}bind/.ResourceFile{
Category//.rfnstring cvs length
dup//.rfnstring dup length 2 index sub
3 2 roll exch getinterval
.file_name_directory_separator exch copy length add
dup//.rfnstring dup length 2 index sub
3 2 roll exch getinterval
2 index exch cvs length add//.rfnstring exch 0 exch getinterval
.libfile{exch pop true}{pop
currentdict/ResourceFileName known{mark 1 index//.rfnstring{ResourceFileName}.internalstopped{cleartomark false}{
(r){file}.internalstopped{cleartomark false}{exch pop exch pop true}ifelse}ifelse}{pop false}ifelse}ifelse}bind
.dicttomark/Category defineresource pop/Category/Category findresource dup/Generic/Category findresource begin{
/FindResource/ResourceForAll/ResourceStatus/.ResourceFileStatus/UndefineResource/ResourceFileName
/.ResourceFile/.LoadResource/.DoLoadResource}{dup load put dup}forall
pop readonly pop end(END GENERIC)VMDEBUG
mark/ColorSpaceFamily{}/Emulator
mark EMULATORS{cvn}forall .packtomark/Filter{}/IODevice
errordict/rangecheck 2 copy get
errordict/rangecheck{pop stop}put
mark 0{{dup .getiodevice dup null eq{pop}{exch}ifelse 1 add}loop}.internalstopped
pop pop pop .packtomark
4 1 roll put
.clearerror/ColorRenderingType{}/FMapType{}/FontType{}/FormType{}/HalftoneType{}/ImageType{}/PatternType{}/setsmoothness where{
pop/ShadingType{}}if
counttomark 2 idiv{mark/DefineResource{currentglobal not{/defineresource cvx/invalidaccess signaloperror}{2 copy ne
{/defineresource cvx/rangecheck signaloperror}{dup .Instances 4 -2 roll .growput}ifelse}ifelse}bind/UndefineResource
{/undefineresource cvx/invalidaccess signaloperror}bind/FindResource{.Instances 1 index .knownget{exch pop}
{/findresource cvx .undefinedresource}ifelse}bind/ResourceStatus{.Instances exch known{0 0 true}{false}ifelse}bind
/ResourceForAll/Generic .findcategory/ResourceForAll load end
counttomark 2 add -1 roll
dup length dict dup begin exch{dup def}forall end/.Instances exch/.LocalInstances
0 dict def
.dicttomark/Category defineresource pop}repeat pop(END FIXED)VMDEBUG/.definecategory{counttomark 2 idiv 2 add
/Generic/Category findresource dup maxlength 3 -1 roll add
dict .copydict begin
counttomark 2 idiv{def}repeat pop
currentdict end/Category defineresource pop}bind def/ColorRendering mark/InstanceType/dicttype .definecategory
/Form mark/InstanceType/dicttype .definecategory/Halftone mark/InstanceType/dicttype .definecategory
/Pattern mark/InstanceType/dicttype .definecategory/ProcSet mark/InstanceType/dicttype .definecategory
/ControlLanguage mark/InstanceType/dicttype .definecategory/HWOptions mark/InstanceType/dicttype .definecategory
/Localization mark/InstanceType/dicttype .definecategory/OutputDevice mark/InstanceType/dicttype .definecategory
/PDL mark/InstanceType/dicttype .definecategory(END MISC)VMDEBUG/.defaultcsnames mark/DefaultGray 0/DefaultRGB 1/DefaultCMYK 2
.dicttomark readonly def/.definedefaultcs{pop pop}bind def/.undefinedefaultcs{pop}bind def/ColorSpace mark
/InstanceType/arraytype
userdict/.localcsdefaults false put/DefineResource{2 copy/Generic/Category findresource/DefineResource get exec
exch pop
exch//.defaultcsnames exch .knownget{1 index .definedefaultcs
currentglobal not{.userdict/.localcsdefaults true put}if}if}bind/UndefineResource{
dup/Generic/Category findresource/UndefineResource get exec//.defaultcsnames 1 index .knownget{currentglobal{
.undefinedefaultcs pop}{exch .GetInstance{0 get .definedefaultcs}{.undefinedefaultcs}ifelse
.userdict/.localcsdefaults false//.defaultcsnames{pop .LocalInstances exch known{pop true exit}if}forall put}ifelse}{pop}ifelse
}bind
.definecategory/Encoding mark/InstanceType/arraytype/.Instances mark
EncodingDirectory{dup length 256 eq{[exch readonly 0 -1]}{pop[null 2 -1]}ifelse}forall
.dicttomark/.ResourceFileDict mark
EncodingDirectory{dup length 256 eq{pop pop}{0 get}ifelse}forall
.dicttomark/ResourceFileName{.ResourceFileDict 2 index .knownget{exch copy exch pop}
{/Generic/Category findresource/ResourceFileName get exec}ifelse}bind
.definecategory/.findencoding/.findencoding load def/findencoding/findencoding load def
/.defineencoding/.defineencoding load def(END ENCODING)VMDEBUG/.fontstatus{{Fontmap 1 index .knownget{{dup type/nametype eq{
.fontstatus{pop null exit}if}{dup type/stringtype eq{findlibfile{closefile pop null exit}if pop}{pop null exit}ifelse}ifelse
}forall dup null eq{pop true exit}if}if
dup type/nametype eq{.namestring}if
dup type/stringtype ne{false exit}if
dup .fonttempstring/FontResourceDir getsystemparam .genericrfn
status{pop pop pop pop true exit}if
findlibfile{closefile true exit}if
.scannextfontdir not{false exit}if}loop}bind def/Font mark/InstanceType/dicttype/DefineResource{2 copy//definefont exch pop
/Generic/Category findresource/DefineResource get exec}bind/UndefineResource{dup//undefinefont
/Generic/Category findresource/UndefineResource get exec}bind/FindResource{dup .getvminstance{exch pop 0 get}{
dup ResourceStatus{pop 1 gt{.loadfontresource}{.GetInstance pop 0 get}ifelse}{.loadfontresource}ifelse}ifelse}bind
/ResourceForAll{{.scannextfontdir not{exit}if}loop/Generic/Category findresource/ResourceForAll get exec}bind
/.ResourceFileStatus{.fontstatus{pop 2 -1 true}{pop false}ifelse}bind/.loadfontresource{dup vmstatus pop exch pop exch
currentfile{pop//findfont exec}.execasresource
exch vmstatus pop exch pop exch sub
2 index .getvminstance{dup 1 1 put
2 3 -1 roll put}{pop}ifelse exch pop}bind/.Instances FontDirectory length 2 mul dict
.definecategory/.definefontmap{/Font/Category findresource/.Instances get
dup 3 index known{pop}{2 index
.currentglobal true .setglobal[null 2 -1]exch .setglobal
.growput}ifelse//.definefontmap exec}bind def
systemdict begin/.origdefinefont/definefont load def/.origundefinefont/undefinefont load def/.origfindfont/findfont load def
end/definefont{{/Font defineresource}stopped{/definefont cvx $error/errorname get signalerror}if}bind odef/undefinefont{
/Font undefineresource}bind odef/.findfontop{{/Font findresource}stopped{pop/findfont $error/errorname get signalerror}if
}bind odef/findfont{.findfontop}bind def
currentdict/.definecategory .undef
currentdict/.emptydict .undef
end/.fixresources{EncodingDirectory{dup length 256 eq{/Encoding defineresource pop}{pop pop}ifelse}forall/.findencoding{
{/Encoding findresource}stopped{pop/findencoding $error/errorname get signalerror}if}bind def
/findencoding/.findencoding load def/.defineencoding{/Encoding defineresource pop}bind def
systemdict/ColorRendering .knownget{/ColorRendering exch/ProcSet defineresource pop
systemdict/ColorRendering undef/DefaultColorRendering currentcolorrendering/ColorRendering defineresource pop}if
systemdict/CIEsRGB .knownget{/sRGB exch/ColorSpace defineresource pop
systemdict/CIEsRGB undef}if
colorspacedict{pop dup/ColorSpaceFamily defineresource pop}forall
filterdict{pop dup/Filter defineresource pop}forall
buildfontdict{pop dup/FontType defineresource pop}forall
mark
buildfontdict 0 known{2 3 4 5 6 7 8}if
buildfontdict 9 known{9}if
counttomark{dup/FMapType defineresource pop}repeat pop
.formtypes{pop dup/FormType defineresource pop}forall
.halftonetypes{pop dup/HalftoneType defineresource pop}forall
.colorrenderingtypes{pop dup/ColorRenderingType defineresource pop}forall
.imagetypes{pop dup/ImageType defineresource pop}forall
.patterntypes{pop dup/PatternType defineresource pop}forall/.shadingtypes where{
pop .shadingtypes{pop dup/ShadingType defineresource pop}forall}if
[/ColorSpaceFamily/Emulator/Filter/IODevice/ColorRenderingType/FMapType/FontType/FormType/HalftoneType/ImageType/PatternType
/.shadingtypes where{pop/ShadingType}if]{/Category findresource
dup/.Instances get readonly pop
.LocalInstances readonly pop
readonly pop}forall
systemdict/.fixresources undef}bind def
languagelevel 2 .setlanguagelevel
currentglobal true setglobal/MappedCategoryRedefiner 10 dict begin
currentpacking false setpacking/InstanceEnumeratorPattern{end{0 1 2{en_local_dict exch/status exch put
InstancesStatus{en_local_dict/status get eq{scr cvs
proc exec}{pop}ifelse}forall}for}stopped
Category begin{stop}if}bind def/.BindAux{0 exec}bind def
setpacking/BindWithCurrentdict{dup length array copy
dup length 1 sub -1 0{2 copy get
dup dup type/arraytype eq exch xcheck and{//.BindAux exec
2 index 3 1 roll put}{dup dup type/nametype eq exch xcheck and{currentdict exch .knownget{2 index 3 1 roll put}{pop}ifelse}{
pop pop}ifelse}ifelse}for
cvx}bind def//.BindAux 0//BindWithCurrentdict put/MakeResourceEnumerator{currentglobal 4 1 roll
false setglobal
currentdict
6 dict begin/Category exch def/InstancesStatus exch def/scr exch def/proc exch def/en_local_dict currentdict def
//InstanceEnumeratorPattern//BindWithCurrentdict exec/status 0 def
end
exch setglobal}bind def/execstack_lookup{currentglobal false setglobal
countexecstack array execstack
dup null exch
length 3 sub -1 0{2 index exch get
dup type dup/packedarraytype eq exch/arraytype eq or{dup rcheck{dup length 1 gt{dup 0 get
5 index eq{1 get
exch pop exit}{pop}ifelse}{pop}ifelse}{pop}ifelse}{pop}ifelse}for
exch pop exch setglobal exch pop}bind def
currentpacking false setpacking/MethodsToRedefine 5 dict begin/FindResource{RESMPDEBUG{(resmp FindResource beg )print dup =}if
dup ResourceStatus exec{pop 2 lt}{false}ifelse{FindResource exec}{dup dup .map exch .knownget{
dup dup/RecordVirtualMethods get/IsActive get exec{1 index .getvminstance{1 get 1 eq}{true}ifelse
4 1 roll
dup/RecordVirtualMethods get/MakeInstance get exec
5 1 roll
DefineResource exec
exch .getvminstance pop
dup 5 -1 roll 2 exch put
3 2 roll{1 1 put}{pop}ifelse}{pop pop FindResource exec}ifelse}{pop FindResource exec}ifelse}ifelse
RESMPDEBUG{(resmp FindResource end)=}if}bind def/ResourceStatus{RESMPDEBUG{(resmp ResourceStatus beg )print dup ==}if
dup ResourceStatus exec{1 index 2 lt{3 2 roll pop true}{exch pop exch
dup .map exch .knownget{dup dup/RecordVirtualMethods get/IsActive get exec{3 2 roll pop
dup/RecordVirtualMethods get/GetSize get exec 2 exch true}{pop pop 2 exch true}ifelse}{pop 2 exch true}ifelse}ifelse}{
dup .map exch .knownget{dup dup/RecordVirtualMethods get/IsActive get exec{
dup/RecordVirtualMethods get/GetSize get exec 2 exch true}{pop pop false}ifelse}{pop false}ifelse}ifelse
RESMPDEBUG{(resmp ResourceStatus end)=}if}bind def/ResourceFileName{RESMPDEBUG{(resmp ResourceFileName beg )print 1 index =}if
exch
.map 1 index .knownget{RESMPDEBUG{(resmp ResourceFileName : have a map record.)=}if
dup dup/RecordVirtualMethods get/IsActive get exec{RESMPDEBUG{(resmp ResourceFileName : record is active.)=}if
dup/RecordVirtualMethods get/GetFilePath get exec
RESMPDEBUG{(resmp ResourceFileName : retrieving )print dup =}if}{
RESMPDEBUG{(resmp ResourceFileName : record is NOT active.)=}if
pop exch ResourceFileName exec
RESMPDEBUG{(resmp ResourceFileName : retrieving )print dup =}if}ifelse}{
RESMPDEBUG{(resmp ResourceFileName : have NO map record.)=}if
exch ResourceFileName exec
RESMPDEBUG{(resmp ResourceFileName : retrieving )print dup =}if}ifelse
RESMPDEBUG{(resmp ResourceFileName end)=}if}bind def/ResourceForAll
{RESMPDEBUG{(resmp ResourceForAll beg )print CategoryName =string cvs print( )print 2 index =}if
20 dict
4 1 roll/.DisableResourceOrdering//execstack_lookup exec null eq 4 1 roll
currentdict
begin
2 index{cvn
4 index{dup ResourceStatus exec{pop 6 index 3 1 roll put}{pop}ifelse}{5 index exch 2 put}ifelse}2 index ResourceForAll exec
4 3 roll pop
end
4 -1 roll begin
.map{dup dup/RecordVirtualMethods get/IsActive get exec{pop
dup currentdict exch known{pop}{dup 2 index cvs
4 index .stringmatch{2 def}{pop}ifelse}ifelse}{pop pop}ifelse}forall
3 2 roll pop
currentdict end//MakeResourceEnumerator exec exec
RESMPDEBUG{(resmp ResourceForAll end)=}if}bind def/GetCIDSystemInfoFromMap
{RESMPDEBUG{(resmp GetCIDSystemInfoFromMap beg )print dup =}if
dup .map exch .knownget{RESMPDEBUG{(resmp GetCIDSystemInfoFromMap : have a map record.)=}if
dup/RecordVirtualMethods get/GetCSI get exec
dup null ne{RESMPDEBUG{(resmp GetCIDSystemInfoFromMap : retrieving a dict.)=}if
exch}if
pop}if
RESMPDEBUG{(resmp GetCIDSystemInfoFromMap end)=}if}bind def
currentdict end def
setpacking/Redefine{begin
CategoryName/Category findresource/OldCategory exch def
OldCategory/.IsRedefinedWithMap known{OldCategory/NewCategory exch def}{OldCategory dup length dict
dup/.PreprocessRecord 4 dict put
copy/NewCategory exch def}ifelse
NewCategory/.PreprocessRecord get dup length
currentdict/PreprocessRecord get .growput
currentdict/MapFileName known{MapFileName .libfile{1 dict begin/;{}def
mark exch cvx exec .dicttomark
end
dup VerifyMap}{QUIET not{currentdict/IsMapFileOptional .knownget not{false}if not{
(Warning: the map file )print dup =string cvs print( was not found.)=}if}if
pop 0 dict}ifelse}{currentdict/.map .knownget not{0 dict}if}ifelse
dup NewCategory/.PreprocessRecord get
3 1 roll{false 3 1 roll
4 index{exch pop
exec{3 -1 roll pop true 3 1 roll
exit}if}forall
3 2 roll{2 index 3 1 roll put}{exch
(Incorrect record )print =string cvs print( of the map file )print MapFileName =string cvs print(.)=
end
pop pop pop/Redefine cvx/undefinedresource signalerror}ifelse}forall
exch pop
OldCategory/.IsRedefinedWithMap known{OldCategory/.map get copy pop}{dup NewCategory exch/.map exch put/.map exch def}ifelse
OldCategory/.IsRedefinedWithMap known not{[/DefineResource/ResourceStatus/ResourceFileName/FindResource/ResourceForAll]{
dup OldCategory exch get def}forall//MethodsToRedefine{//BindWithCurrentdict exec NewCategory 3 1 roll put}forall
CategoryName/CIDFont ne{NewCategory/GetCIDSystemInfoFromMap undef}if
NewCategory/.IsRedefinedWithMap true put
CategoryName NewCategory/Category defineresource pop}if
end}bind executeonly def
currentdict/PutPreprocessRecord .undef
currentdict end/ProcSet defineresource pop
setglobal .setlanguagelevel
(%Type42BuildChar)cvn{1 index/Encoding get 1 index get .type42build}bind def(%Type42BuildGlyph)cvn{dup .type42build}bind def
/.type42build{2 index begin
dup CharStrings exch .knownget not{2 copy eq{exch pop/.notdef exch}if
QUIET not{(Substituting .notdef for )print
=string cvs print( in the font )print
1 index/FontName get = flush}{pop}ifelse/.notdef CharStrings/.notdef get}if
end .type42execchar}bind def
buildfontdict 42{dup/sfnts get 0 get length 14 lt{dup/FontType 3 put
dup/BuildGlyph{1 index/CharStrings get exch 2 copy known not{pop/.notdef}if get exec}bind put//.buildfont3 exec}{
//.buildfont42 exec}ifelse}bind
put
/.checkfonttype{1 index/FID known{1 index/FontType get ne{/definefont cvx/invalidfont signalerror}if false}{
1 index/FontType 3 -1 roll put true}ifelse}bind def/.cidfonttypes where{pop}{/.cidfonttypes 6 dict def}ifelse
.cidfonttypes
30 dict begin
dup 0{9 .checkfonttype{/CIDInit/ProcSet findresource begin
.completefont9
end}if
1 index exch .buildfont9 exch pop}put/.completefont9{currentglobal 3 1 roll dup gcheck setglobal
dup/FontMatrix known not{dup/FontMatrix[0.001 0 0 0.001 0 0]put
dup/FDArray get{currentglobal exch dup gcheck setglobal
dup/FontMatrix get[1000 0 0 1000 0 0]matrix concatmatrix/FontMatrix exch put
setglobal}forall}if
dup/FDArray get{dup/Private get dup/Subrs known not{dup/SubrCount .knownget{currentglobal 3 1 roll 1 index gcheck setglobal
array 1 index/Subrs 3 -1 roll put
2 index begin begin .loadsubrs end end
setglobal}{pop}ifelse readonly pop}{pop pop}ifelse}forall
3 -1 roll setglobal}bind def/.readsubrs{1 SubrCount 1 sub{dup SDBytes mul SubrMapOffset add
dup SDBytes .readint exch SDBytes add SDBytes .readint
1 index sub string ReadString 2 index 3 1 roll put}for}bind def/.loadsubrs{Subrs length 0 ne{SubrCache SubrMapOffset .knownget{
dup length SubrCount lt{SubrCount array exch 1 index copy length .readsubrs
SubrCache SubrMapOffset 2 index put}if}{SubrCount array 0 .readsubrs
SubrCache SubrMapOffset 2 index put}ifelse
Subrs copy pop}if}bind def
dup 1{10 .checkfonttype pop
1 index exch .buildfont10 exch pop}put
dup 2{11 .checkfonttype pop
1 index exch .buildfont11 exch pop}put
pop/StartData{mark{2 index(Binary)ne{stop}if
currentfile .currentresourcefile ne{stop}if
currentdevice .devicename/pdfwrite eq{stop}if
currentfile fileposition}.internalstopped{cleartomark exch
currentfile exch(Hex)eq{/ASCIIHexDecode filter}if
exch
dup 65400 le{string dup()ne{1 index exch readstring pop}if}{mark 3 1 roll{dup 0 eq{pop exit}if
dup 65400 .min dup string 3 index exch readstring pop
4 1 roll sub}loop
counttomark 1 add 1 roll]}ifelse/GlyphData exch def
dup currentfile eq{pop}{closefile}ifelse}{/GlyphData 0 def
exch pop 3 -1 roll pop exch/DataSource currentfile 2 index().subfiledecode true .reusablestream def
currentfile 3 1 roll add setfileposition}ifelse/SubrCache 10 dict def
CIDFontName currentdict/CIDFont defineresource pop
end
end}bind def/cid_Setup{}def/ReadString{GlyphData 0 eq{DataSource 3 -1 roll setfileposition
DataSource exch readstring pop}{GlyphData .stringsreadstring}ifelse}bind def/.stringsreadstring{dup type/stringtype eq
{3 1 roll length getinterval}{{dup 0 get length dup 4 index gt{exit}if
4 -1 roll exch sub 3 1 roll
dup length 1 sub 1 exch getinterval}loop
3 index 3 index length add 1 index le{pop 0 get 3 1 roll length getinterval}{
1 index 0 get 4 index 3 -1 roll 1 index sub getinterval
2 index copy
length exch 1 get 0 3 index length
3 index sub getinterval 2 index 3 1 roll putinterval
exch pop}ifelse}ifelse}bind def/.cvbsi{0 exch{exch 8 bitshift add}forall}bind def/.readint{string ReadString .cvbsi}bind def
currentdict end/.readglyphdata{currentfont exch .type9mapcid
FDArray exch get exch}bind def/.cid0buildstring 10 string def(%Type9BuildGlyph)cvn{
.currentglobal 3 1 roll 1 index gcheck .setglobal
1 index begin
dup .readglyphdata dup null eq{pop pop 0 .readglyphdata}if
dup null eq{pop pop pop pop}{4 -1 roll pop
3 1 roll exch dup 4 -1 roll 0 0 moveto
3 index/FontType get 2 eq{.type2execchar}{.type1execchar}ifelse}ifelse
end
.setglobal}bind def(%Type11BuildGlyph)cvn{2 copy{.type11mapcid}.internalstopped{pop/CharStrings get/.notdef get}if
1 index exch .type42execchar}bind def
languagelevel exch 2 .setlanguagelevel/CIDInit/ProcSet 2 copy resourcestatus{pop 0 eq}{false}ifelse{
pop pop findresource dup length 4 index length add dict .copydict
4 -1 roll exch .copydict}{3 -1 roll}ifelse exch defineresource pop/.buildcidfont{
systemdict/ProvideUnicode .knownget not{false}if{/FontEmulationProcs/ProcSet findresource/ProvideUnicodeDecoding get exec}if
dup/CIDFontType get//.cidfonttypes exch get exec}odef/CIDFont/Generic/Category findresource dup length dict .copydict
dup/InstanceType/dicttype put
dup/DefineResource{.buildcidfont
dup/OrigFont known not{dup dup/OrigFont exch .growput}if
dup/PaintType known not{dup/PaintType 0 .growput}if/Generic/Category findresource/DefineResource get exec}put
/.loadcidfontresource{dup .ResourceFile{{.loadfont}.execasresource}{dup/undefinedresource signalerror}ifelse}bind def
dup/.LoadResource{currentglobal{.loadcidfontresource}{true setglobal{.loadcidfontresource}stopped false setglobal{stop}if
}ifelse}bind put/Category defineresource pop
9 1 11{dup/FontType defineresource pop}for
9 dup/FMapType defineresource pop/CIDMap/Generic/Category findresource dup length dict .copydict
dup/.CheckResource{dup type dup dup/stringtype eq exch/dicttype eq or{pop true}{dup/arraytype eq exch/packedarraytype eq or{
true exch{type/stringtype eq and}forall}{false}ifelse}ifelse}bind put/Category defineresource pop
.setlanguagelevel
languagelevel 2 .setlanguagelevel
currentglobal true setglobal/ParseDecoding<</Parse{dict begin
0{currentfile token not{exit}if
dup type/integertype eq{exch pop}{1 index def}ifelse}loop
pop
currentdict end/Decoding
defineresource pop}bind
>>/ProcSet defineresource pop/Generic/Category findresource dup length dict copy
dup/InstanceType/dicttype put/Decoding exch/Category defineresource pop/ParseCMap_Inverse<</findresource{pop}bind
/defineresource{pop pop}bind/dict{}/def{pop pop}bind/dup null/begin{pop}bind/end{}/currentdict null/CMapName null
/usecmap{pop}bind/begincmap{}/endcmap{}/begincodespacerange{pop mark}bind/endcodespacerange{cleartomark}bind
/beginnotdefrange{pop mark}bind/endnotdefrange{cleartomark}bind/beginbfchar{pop mark}bind/endbfchar{pop mark}bind
/beginbfrange{begincidrange}/endbfrange{endcidrange}/begincidchar{beginbfchar}/endcidchar{endbfchar}
/begincidrange{pop mark}bind/endcidrange{cleartomark}bind
>>
dup length 5 add dict begin/.Ranges 40 dict def//.Ranges/CIDCount 0 put/.StringToInt{0 exch{exch 8 bitshift add}forall}bind def
/.SetCouple{exch
dup 256 idiv
dup//.Ranges exch known not{dup//.Ranges exch 256 array put}if//.Ranges exch get
exch 256 mod
2 copy get
dup//null ne{dup type/integertype eq{4 3 roll
2 array astore put}{dup length 1 add dup dup array dup
3 2 roll 0 exch getinterval
4 3 roll exch copy pop
dup 3 2 roll 1 sub
6 5 roll
put put}ifelse}{pop 3 2 roll put}ifelse}bind def/endcidrange{counttomark 3 idiv{exch .StringToInt
3 2 roll .StringToInt
dup 3 2 roll exch sub 1 add{2 copy//.SetCouple exec
1 add exch 1 add exch}repeat
pop
dup//.Ranges/CIDCount get gt{dup//.Ranges exch/CIDCount exch put}if
pop}repeat
pop}bind def/.GetCIDDecoding{//.Ranges dup length dict copy//.Ranges//.PurgeDict exec//.Ranges/CIDCount 0 put}bind def
currentdict end
exch copy/ProcSet defineresource pop/Generic/Category findresource dup length dict copy
begin/Category/CIDDecoding def/InstanceType/dicttype def/.CMapChooser<</CNS1.Big5[/ETen-B5-H/ETen-B5-V]
/CNS1.Unicode[/UniCNS-UCS2-H/UniCNS-UCS2-V]/GB1.GB2312[/GBK-EUC-H/GBK-EUC-V]/GB1.Unicode[/UniGB-UCS2-H/UniGB-UCS2-V]
/Japan1.ShiftJIS[/90ms-RKSJ-H/90ms-RKSJ-V]/Japan1.Unicode[/UniJIS-UCS2-H/UniJIS-UCS2-V]
/Japan2.ShiftJIS[/90ms-RKSJ-H/90ms-RKSJ-V]/Japan2.Unicode[/UniHojo-UCS2-H]/Korea1.Johab[/KSC-Johab-V/KSC-Johab-H]
/Korea1.Wansung[/KSCms-UHC-V/KSCms-UHC-H]/Korea1.Unicode[/UniKS-UCS2-H/UniKS-UCS2-V]/Identity.Symbol[/Identity-H/Identity-V]
/Unicode.Unicode[/Identity-UTF16-H]>>def/.MakeInstance{dup//.CMapChooser exch .knownget not{
(Can't build /)print =string cvs print( /CIDDecoding resource. See gs_ciddc.ps . )=
/findresource cvx/undefinedresource signalerror}if
exch pop/CMap/Category findresource/ParseCMap_Inverse/ProcSet findresource
3 2 roll{3 2 roll begin
dup .ResourceFile not{(Can't find CMap )print =string cvs print( building a CIDDecoding resource. )=
/findresource cvx/undefinedresource signalerror}if
currentdict end exch
3 index begin
cvx exec
end
exch pop exch}forall
exch pop begin
.GetCIDDecoding
end}bind def/FindResource{currentglobal exch
true setglobal
dup//.MakeInstance exec
DefineResource
exch setglobal}bind def
currentdict end/CIDDecoding exch/Category defineresource pop
setglobal
.setlanguagelevel
languagelevel 2 .setlanguagelevel currentglobal true setglobal
25 dict begin/.prs_dict currentdict def/.prs_empty 0 dict readonly def/path_buffer 8192 string def/name_buffer 1024 string def
/minus(-)0 get def/period(.)0 get def/CMap 10 dict def/CIDFont 10 dict def/enable_cache true def/.prsFile 0 def
/.prsResult 0 def/.prsDictCount 0 def/DummyCIDInit 15 dict
begin/begincmap{}def/usecmap{pop}bind def{stop}bind[/begincodespacerange/endcodespacerange/beginnotdefchar/endnotdefchar
/beginnotdefrange/endnotdefrange/begincidchar/endcidchar/begincidrange/endcidrange/endcmap/usefont/StartData]{1 index def
}bind forall
pop
currentdict end def/findresource{2 copy/ProcSet eq exch/CIDInit eq and{pop pop//DummyCIDInit}{//findresource exec}ifelse
}bind def/StopIfCSIDefined{countdictstack//.prs_dict/.prsDictCount get sub dup{currentdict/CIDSystemInfo .knownget{
//.prs_dict exch/.prsResult exch put
stop}if
currentdict exch end}repeat{begin}repeat}bind def/PrescanFile{{//.prs_dict/.prsFile get token{dup type
dup/nametype eq exch/operatortype eq or{dup xcheck{exec//StopIfCSIDefined exec}if}if}{stop}ifelse}loop}bind odef
/GetCIDSystemInfoFromFile{RESMPDEBUG{(cidcm GetCIDSystemInfoFromFile beg)=}if//.prs_dict begin/.prsFile exch def
/.prsResult//.prs_empty def/.prsDictCount countdictstack def
RESMPDEBUG{(cidcm GetCIDSystemInfoFromFile will PrescanFile.)=}if{//PrescanFile}stopped pop//.prs_dict/.prsResult get
end
RESMPDEBUG{(cidcm GetCIDSystemInfoFromFile end)=}if}bind def/GetCIDSystemInfo{RESMPDEBUG{(cidcm GetCIDSystemInfo beg)=}if
/Category findresource begin
dup ResourceStatus{pop 2 lt{FindResource/CIDSystemInfo .knownget not{//.prs_empty}if}{
currentdict/GetCIDSystemInfoFromMap .knownget{exec}if
dup type/nametype eq{RESMPDEBUG{(cidcm GetCIDSystemInfo got a name.)=}if//.prs_dict Category get
dup 2 index known//enable_cache and{RESMPDEBUG{(cidcm GetCIDSystemInfo from cache.)=}if
exch get}{RESMPDEBUG{(cidcm GetCIDSystemInfo from file.)=}if
exch
dup//path_buffer ResourceFileName
RESMPDEBUG{(cidcm GetCIDSystemInfo from file )print dup =}if
currentglobal exch true setglobal
mark exch{(r)file//GetCIDSystemInfoFromFile exec}stopped{cleartomark//.prs_empty}{exch pop}ifelse
exch setglobal
dup 4 1 roll
put
RESMPDEBUG{(cidcm GetCIDSystemInfo got from file : <<)print
dup{exch//=string cvs print( )print//=string cvs print( )print}forall(>>)=}if}ifelse}if}ifelse}{pop//.prs_empty}ifelse
end
RESMPDEBUG{(cidcm GetCIDSystemInfo end)=}if}bind def/IsCompatibleCSI{exch{dup type/arraytype eq{dup length 1 ne{
pop pop false exit}if
0 get}if
dup type/dicttype ne{pop pop false exit}if
exch
dup type/dicttype ne{pop pop false exit}if
true[/Registry/Ordering]{2 index 1 index .knownget not{1234567}if
exch
4 index exch .knownget not{7654321}if
eq and}forall
exch pop exch pop
exit}loop}bind def/IsWellComposed{exch/CIDFont//GetCIDSystemInfo exec
dup type/dicttype eq{dup length 0 ne{exch/CMap//GetCIDSystemInfo exec//IsCompatibleCSI exec}{pop pop false}ifelse}{
pop pop false}ifelse}bind def/IsComposedFont{dup type/stringtype ne{//name_buffer cvs}if{dup length 2 sub -1 1{
2 copy get dup//minus eq exch//period eq or{2 copy 2 copy
2 copy get//minus eq{2 copy 1 sub get//minus eq{1 sub}if}if
0 exch getinterval cvn
3 1 roll
1 add dup
5 index length
exch sub getinterval cvn
2 copy//IsWellComposed exec{4 2 roll pop pop
stop}if
pop pop pop}{pop}ifelse}for
pop}stopped}bind def/ComposeName{dup dup 5 2 roll
3 2 roll exch cvs length dup
4 -1 roll exch//minus put
1 add dup
3 index dup length
2 index sub
3 2 roll
exch getinterval
3 2 roll exch cvs length
add 0 exch getinterval}bind def/Font/Category findresource dup length dict copy begin/FindResource{dup//ResourceStatus exec{
pop pop//FindResource exec}{dup//IsComposedFont exec{exch[exch]composefont}{//FindResource exec}ifelse}ifelse}bind def
/ResourceStatus{dup//ResourceStatus exec{3 2 roll pop true}{//IsComposedFont exec{/CMap resourcestatus{exch pop exch
/CIDFont resourcestatus{exch pop
dup 0 ge{exch dup 0 ge{add}{exch pop}ifelse}{pop}ifelse
2 exch true}{pop pop pop false}ifelse}{pop pop pop false}ifelse}{false}ifelse}ifelse}bind def/ResourceForAll{
currentglobal false setglobal
20 dict 20 dict 20 dict{/.DisableResourceOrdering pop
6 index[2 index{exch//null put}aload pop]cvx bind 6 index//ResourceForAll exec
(*)[3 index{exch dup type/stringtype eq{cvn dup put}{pop pop}ifelse}aload pop]cvx bind 6 index/CMap resourceforall
(*)[4 index{exch dup type/stringtype eq{cvn dup put}{pop pop}ifelse}aload pop]cvx bind 6 index/CIDFont resourceforall
exit}loop
4 -1 roll setglobal
dup{pop dup//ResourceStatus exec{pop 2 index
3 1 roll put}{pop}ifelse}forall
3 2 roll{3 index{3 1 roll
6 index//ComposeName exec
dup 8 index .stringmatch{cvn
dup 4 index exch known{pop pop}{2 index
4 2 roll//IsWellComposed exec{exch 2 index exch 2 put}{exch pop}ifelse}ifelse}{pop pop}ifelse
dup}forall
pop pop}forall
exch pop
4 3 roll pop/MappedCategoryRedefiner/ProcSet findresource/MakeResourceEnumerator get exec exec}bind def
currentdict end/Font exch/Category defineresource pop
end
setglobal .setlanguagelevel
languagelevel 2 .setlanguagelevel
mark
/TrueType[(3.0)/Symbol(3.1)/Unicode(3.2)/ShiftJIS(3.3)/PRC(3.4)/Big5(3.5)/Wansung(3.6)/Johab]/PostScript[(*)/Unicode]
/Intellifont[(*)/FCO_Unicode]/Microtype[(*)/FCO_Unicode]
.dicttomark dup systemdict exch/.xlatmap_dict exch put()exch{3 1 roll =string cvs concatstrings(\0\0)concatstrings
exch{=string cvs concatstrings(\0)concatstrings}forall}forall(\0)concatstrings
systemdict exch/.xlatmap exch put/FontEmulationProcs 10 dict begin/FontCommon{currentdict/PaintType known not{/PaintType 0 def
}if
currentdict/Encoding .knownget not{//StandardEncoding}if
dup type/nametype eq{/Encoding findresource}if/Encoding exch def}bind def/FontOptions 5 dict begin/make_procs currentdict def
/NameKey/FontName def/TypeKey/FontType def
1{/FontMatrix[0.001 0 0 0.001 0 0]def/FontBBox[-128 -128 1024 1024]def/Private 0 dict def/CharStrings<</.notdef()>>def
//FontCommon exec}bind def
42{/FontMatrix[1 0 0 1 0 0]def/FontBBox[0 0 1 1]def/CharStrings<<>>def/sfnts[<00010000 0000 0000 0000 0000 0000>]def
/GlyphDirectory[]def//FontCommon exec}bind def
currentdict end def/TranslateCSI{RESMPDEBUG{(fntem TranslateCSI beg )=}if
begin
CSI length 2 eq{<</Registry(Adobe)/Ordering CSI aload pop/Supplement exch
>>}{<</Registry CSI 0 get/Ordering CSI 1 get/Supplement CSI 2 get
>>}ifelse
end
RESMPDEBUG{(fntem TranslateCSI end )=}if}bind def/CIDFontCommon{/CIDSystemInfo currentdict//TranslateCSI exec def
currentdict/CSI undef/FontBBox[-128 -128 1024 1024]def/CIDCount 1 def}bind def
currentpacking false setpacking/SubstNWP<</Japan1{p 1 94 231 n
p 17 26 780 w
p 34 59 790 w
p 66 91 816 w
w 842 842 7918 w
w 844 844 7919 w
w 846 846 7920 w
w 848 848 7921 w
w 850 850 7922 w
w 876 876 7923 w
w 908 908 7924 w
w 910 910 7925 w
w 912 912 7926 w
w 914 914 7927 w
w 925 925 7928 w
w 927 927 7929 w
w 929 929 7930 w
w 931 931 7931 w
w 933 933 7932 w
w 959 959 7933 w
w 991 991 7934 w
w 993 993 7935 w
w 995 995 7936 w
w 1002 1002 7937 w
w 1009 1009 7938 w
w 1010 1010 7939 w}cvlit/Japan2 1 index/CNS1{p 1 94 13648 n
p 17 26 333 w
p 34 59 365 w
p 66 91 391 w}cvlit/GB1{p 2 94 814 n
p 2 94 262 w
p 1 1 7716 n}cvlit/Korea1{p 1 60 8094 n
p 62 94 8155 n
p 2 59 264 w
p 63 94 325 w}cvlit/Identity[]/Unicode[]>>def
setpacking/CIDFontOptions 5 dict begin/make_procs currentdict def/NameKey/CIDFontName def/TypeKey/CIDFontType def
0{//CIDFontCommon exec/FDArray[14 dict begin/FontName CIDFontName =string cvs(%)concatstrings cvn def/FontType 1 def
/FontMatrix[0.001 0 0 0.001 0 0]def/PaintType 0 def/Private 0 dict def
currentdict
end]def/GlyphDirectory[]def/GDBytes 1 def/FDBytes 0 def}bind def
1{//CIDFontCommon exec/FontMatrix[1 0 0 1 0 0]def/BuildGlyph{}def}bind def
2{//CIDFontCommon exec/FontMatrix[1 0 0 1 0 0]def/GDBytes 2 def/CIDMap<0000>def/sfnts[<00010000 0000 0000 0000 0000 0000>]def
/Encoding[]def/CharStrings<</.notdef 0 >>def}bind def
currentdict end def/complete_instance{begin
dup length dict copy
begin
dup type/nametype ne{cvn}if
dup NameKey exch def
currentglobal true setglobal
make_procs TypeKey load .knownget{exec}{setglobal/complete_instance cvx/invalidfont signalerror}ifelse
setglobal
currentdict end
end}bind def/GetFilePath{exch pop/Path get
exch copy}bind def/GetSize{pop pop -1}bind def/RecordVirtualMethodsStub 3 dict begin/GetFilePath//GetFilePath def
/GetSize//GetSize def
currentdict end def/encodingnames mark
StandardEncoding/StandardEncoding
ISOLatin1Encoding/ISOLatin1Encoding
SymbolEncoding/SymbolEncoding
DingbatsEncoding/DingbatsEncoding/resourceforall where{pop(*){dup cvn
EncodingDirectory exch .knownget not{(.svn)anchorsearch{pop pop}{(/)search{pop pop pop}{cvn dup/Encoding findresource}ifelse
}ifelse}{exch cvn exch}ifelse
exch}1024 string/Encoding resourceforall}if
.dicttomark def/ChooseDecoding{{dup/Decoding .knownget{dup type/nametype eq{
1 index/CIDFontType known{/CIDDecoding}{/Decoding}ifelse
findresource 1 index exch/Decoding exch put}{pop}ifelse
dup/CIDFontType known{dup dup/Decoding get/CIDCount get/CIDCount exch put}if
exit}if
dup/CIDFontType known{exit}if
dup/Encoding get
dup type/nametype eq{/Decoding findresource 1 index exch/Decoding exch put}{dup//encodingnames
exch .knownget{exch pop/Decoding findresource 1 index exch/Decoding exch put}{dup length dict begin/.notdef 0 def
0 1 currentdict length 1 sub{dup 2 index exch get
dup/.notdef ne{exch def}{pop pop}ifelse}for
pop
currentdict end
1 index exch/Decoding exch put}ifelse}ifelse
exit}loop
dup/CIDFontType known{dup/SubstNWP .knownget not{dup/CIDSystemInfo get/Ordering get cvn}if
dup type/nametype eq{//SubstNWP exch .knownget not{[]}if}if
1 index exch/SubstNWP exch put}if}bind def/PrintFontRef{dup/FontName known{(Font )}{(CIDFont )}ifelse print
1 index =string cvs print
dup/FontName .knownget not{dup/CIDFontName get}if
dup 3 index ne{( \( aliased from )print
=string cvs print( \))print}{pop}ifelse}bind def/GetFontType{dup/CIDFontType .knownget{exch pop 9 add}{/FontType get}ifelse
}bind def/FindInArray{false 3 1 roll
exch{1 index eq{pop true exch}if}forall
pop}bind def/ProvideUnicodeDecoding{currentglobal true setglobal exch
dup/FontInfo known not{dup/FontInfo 1 dict put}if{dup/FontInfo get/GlyphNames2Unicode known{exit}if
dup/CIDFontType known{dup mark exch
dup/CIDSystemInfo get/Ordering get(.Unicode)concatstrings cvn/CIDDecoding{findresource}stopped{cleartomark exit}if
exch/FontInfo get exch/GlyphNames2Unicode exch
.forceput
pop
exit}if
dup/FontInfo get/GlyphNames2Unicode/Unicode/Decoding findresource
.forceput
exit}loop
exch setglobal}bind def
currentdict end/ProcSet defineresource pop
.setlanguagelevel
languagelevel 2 .setlanguagelevel
15 dict begin/FontEmulationProcs/ProcSet findresource{def}forall
currentdict/super.complete_instance currentdict/complete_instance get put/GenerateCIDMap{begin
Decoding/CIDCount get/CIDCount exch def/CIDMap[CIDCount 22000 le{CIDCount 2 mul string}{44000 string
CIDCount 44000 gt{44000 string
CIDCount 44000 sub 2 mul string}{CIDCount 22000 sub 2 mul string}ifelse}ifelse]def
Decoding TT_cmap SubstNWP GDBytes CIDMap .fillCIDMap
currentdict end}bind def/load_sfnts{dup/Path get
QUIET not{(Loading a TT font from )print dup print( to emulate a CID font )print 1 index/CIDFontName get =only( ... )print}if
(r)file dup
3 1 roll
1 index/SubfontID .knownget not{0}if
.load_tt_font_stripped exch copy
QUIET not{(Done.)=}if
dup 3 1 roll
exch/File exch put
dup dup/CIDSystemInfo get/Ordering get(.)2 index/Decoding get =string cvs
concatstrings concatstrings cvn/Decoding exch put//ChooseDecoding exec//GenerateCIDMap exec}bind def/RefinePath{dup begin
Path .libfile{dup .filename{currentdict exch/Path exch put}if
closefile}{(Can't find the font file )print =/findfont cvx/undefinedfilename signalerror}ifelse
end}bind def/complete_instance{1 index/CIDFontType 2 put//super.complete_instance exec//RefinePath exec//load_sfnts exec
}bind def/IsMyRecord{dup type/dicttype eq{dup/FileType .knownget{/TrueType eq}{false}ifelse}{false}ifelse}bind def/IsActive
{pop true}bind def/CIDFontRecordVirtualMethods//RecordVirtualMethodsStub dup length 3 add dict copy begin
/GetCSI//TranslateCSI def/IsActive//IsActive def/MakeInstance{currentglobal 3 1 roll true setglobal
//CIDFontOptions//complete_instance exec
2 copy//GetSize exec
4 3 roll setglobal}bind def
currentdict end def
4 dict begin/CategoryName/CIDFont def/IsMapFileOptional true def/VerifyMap{pop}bind def/PreprocessRecord{//IsMyRecord exec dup{
pop dup/RecordVirtualMethods//CIDFontRecordVirtualMethods put
true}if}bind def
currentdict end/MappedCategoryRedefiner/ProcSet findresource/Redefine get exec
end
.setlanguagelevel
languagelevel 2 .setlanguagelevel
4 dict begin/CategoryName/CIDFont def/MapFileName(cidfmap)def/IsMyRecord{dup type/nametype eq}bind def
/RecordVirtualMethods 3 dict begin/MakeInstance{/Substitute get FindResource
dup length dict copy
1 index ResourceStatus pop exch pop}bind def/GetFilePath{exch pop/Substitute get exch ResourceFileName}bind def/GetSize{
/Substitute get ResourceStatus{exch pop exch pop}{/undefinedresource signalerror}ifelse}bind def/GetCSI{
RESMPDEBUG{(cidfm GetCSI beg )=}if/Substitute get
GetCIDSystemInfoFromMap
RESMPDEBUG{(cidfm GetCSI end )print dup =}if}bind def/IsActive{pop true}bind def
currentdict end def/VerifyMap{dup length dict copy
dup length dict{true 2 index{3 2 roll pop false exit}forall{exit}if
3 index 2 index undef
exch 2 index exch 0 put{//IsMyRecord exec not{pop exit}if
1 index 1 index known{(Vicious substitution cycle in map file with the entry )print =string cvs print( .)=
/VerifyMap cvx/undefinedresource signalerror}if
1 index 1 index 0 put
dup 3 index exch .knownget not{pop exit}if
exch
3 index exch undef}loop{true 1 index{3 2 roll pop false exit}forall{exit}if
pop 1 index exch undef}loop}loop
pop pop}bind def/PreprocessRecord{//IsMyRecord exec{1 dict begin/Substitute exch def
/RecordVirtualMethods//RecordVirtualMethods def
currentdict end
true}{false}ifelse}bind def
currentdict end/MappedCategoryRedefiner/ProcSet findresource/Redefine get exec
.setlanguagelevel
[/CMERGE_DEBUG/USE_CIDCHAR_AS_RANGE]{dup where{pop pop}{currentdict exch//false def pop}ifelse}forall/.rewriteTempMapsNotDef{
CMAPDEBUG{(rewriting TempMapsNotDef\n)print flush}if
.TempMaps 2 get
dup length 0 gt{0 get
CMAPDEBUG{(...original...\n)print flush}if
1 5 2 index length 1 sub{{1 index exch get 2 3 put}stopped{CMAPDEBUG{(cannot rewrite\n)print flush}if}
{CMAPDEBUG{(rewrite\n)print flush}if}ifelse}for}if
pop
CMAPDEBUG{(...FINISHED...\n)print}if}bind def/.composefontdict{10 dict begin
/CMap 2 index dup type/dicttype ne{/CMap findresource}if def/FDepVector 1 index cvlit def
/Encoding[0 1 FDepVector length 1 sub{}for]def/FontInfo 1 dict def/FDepVector[0 1 FDepVector length 1 sub{
FDepVector 1 index get
dup type/dicttype ne{dup/CIDFont resourcestatus{pop pop/CIDFont}{/Font}ifelse findresource}if
exch CMap/FontMatrices get dup length 2 index gt{exch get dup//null eq{pop}{makefont}ifelse}{pop pop}ifelse}for]readonly def
/FMapType 9 def/FontMatrix matrix def/FontName 3 index def
CMap/WMode .knownget{/WMode exch def}if/FontType 0 def
pop pop currentdict end}bind odef/composefont{.composefontdict/Font defineresource}bind def
40 dict begin/begincmap{/.CodeMapData[[[]][[]][[]]]def/FontMatrices[]def/.FontIndex 0 def/.TempMaps[20 dict 50 dict 50 dict]def
/CodeMap//null def}bind def/endcmap{.rewriteTempMapsNotDef
CMAPDEBUG{2(*** undefined charmap ***)1(*** defined charmap ***)0(*** code space ranges ***)3{=
.TempMaps exch get
0 1 2 index length 1 sub{dup ==(\t)print
1 index exch get ==}for
pop}repeat}if/.CodeMapData dup load[exch
.TempMaps aload pop begin begin begin{[exch aload pop
0 1 currentdict length 1 sub{currentdict exch get}for]end}forall].endmap def
CMAPDEBUG{(*** Content of .CodeMapData ***)=
0 .CodeMapData{exch dup == 1 add exch(\t)print ==}forall
pop}if
currentdict/.TempMaps undef/FontMatrices FontMatrices .endmap def}bind def/.endmap{dup type/arraytype eq{dup wcheck{
0 1 2 index length 1 sub{2 copy 2 copy get .endmap put pop}for readonly}if}{dup type/stringtype eq{readonly}if}ifelse}bind def
/.appendmap{.TempMaps exch get counttomark 1 add 1 roll]1 index length exch put}bind def/begincodespacerange{pop mark}bind def
/endcodespacerange{0 .appendmap}bind def/usecmap{/CMap findresource dup/.CodeMapData exch/.CodeMapData get copyarray def
/FontMatrices exch/FontMatrices get copyarray def}bind def/usefont{/.FontIndex exch def}bind def/beginusematrix{
FontMatrices wcheck not FontMatrices length 2 index le or{FontMatrices length 1 index 1 add .max array
dup 0 FontMatrices putinterval/FontMatrices exch def}if}bind def/endusematrix{FontMatrices 3 1 roll put}bind def
/beginrearrangedfont{10 dict begin/.FontNames exch def/.FontName exch def
begincmap}bind def/endrearrangedfont{(REARRANGED FONTS NOT IMPLEMENTED YET.)= flush
FontName .FontNames 0 get findfont end definefont pop}bind def/beginbfchar{pop mark}bind def/endbfchar{counttomark 2 idiv{
counttomark -2 roll
.addbfchar}repeat 1 .appendmap}bind def/beginbfrange{pop mark}bind def/endbfrange{counttomark 3 idiv{counttomark -3 roll
dup type dup/arraytype eq exch/packedarraytype eq or{exch pop{1 index exch .addbfchar
6 -1 roll dup length string copy
dup dup length 1 sub 2 copy get 1 add 255 and put}forall pop}{.addbfrange}ifelse}repeat 1 .appendmap}bind def/.addbfchar{
1 index exch .addbfrange}bind def/.addbfrange{4 string dup 3
3 index type/nametype eq{2 index 2 1 put
4 -1 roll 1 array astore 4 1 roll 4}{2 index 2 2 put
3 index length}ifelse put
3 index 3 index eq{3 -1 roll pop exch()exch}{dup 0 1 put dup 1 1 put
4 2 roll
dup dup length 1 sub 0 exch getinterval 5 1 roll
2{exch dup length 1 sub 1 getinterval}repeat concatstrings
3 -1 roll}ifelse
.FontIndex}bind def/begincidchar{pop mark}bind def/endcidchar{1 .endmapchars}bind def/begincidrange{pop mark}bind def
/endcidrange{1 .endmapranges}bind def/.endmapchars{counttomark 1 add 1 roll
counttomark 2 idiv{counttomark -2 roll
exch
dup length 1 eq{<00 00 00 02>()}{dup 0 1 getinterval exch
4 string dup 0
USE_CIDCHAR_AS_RANGE{<00 01 00 02>}{<00 00 00 02>}ifelse
putinterval
exch
dup length
1 sub
dup
3 index
exch
0 exch
put
1 exch
getinterval
USE_CIDCHAR_AS_RANGE{dup length 2 mul string
dup
2 index
0 exch putinterval
dup
3 -1 roll
dup length
exch putinterval}if}ifelse
4 -1 roll
.endmapvalue
counttomark 5 gt{4 index 10 index eq
4 index 10 index eq and
1 index 7 index eq and{CMAPDEBUG{(merge! char\n)print}if
pop 4 2 roll pop pop
5 -1 roll 3 -1 roll concatstrings
4 -1 roll 3 -1 roll concatstrings
3 -1 roll}if}if
CMERGE_DEBUG{( prefix:)print 4 index =only( param:)print 3 index =only( key:)print 2 index =only( hex_cid:)print 1 index =only
( font_idx:)print 0 index == flush}if}repeat
counttomark 2 add -1 roll .appendmap}bind def/.endmapranges{counttomark 1 add 1 roll
counttomark 3 idiv{counttomark -3 roll
3 1 roll
dup 2 index eq{dup length 1 eq{0}{1}ifelse}{dup length 1 sub
0{dup 2 index ge{exit}if
3 index 1 index get
3 index 2 index get
eq{1 add}{exit}ifelse}loop
exch pop}ifelse
1 index exch 0 exch getinterval
dup length 3 index length exch sub
dup 255 gt{(too long coderange specification for current GS\n)print/.endmapranges cvx/rangecheck signalerror}if
<00 01 00 02>4 string copy
dup 0 4 -1 roll put
3 -1 roll dup length 3 index length dup 3 1 roll sub getinterval
4 -1 roll dup length 4 index length dup 3 1 roll sub getinterval
exch concatstrings
4 -1 roll
.endmapvalue
counttomark 5 gt{4 index 10 index eq
4 index 10 index eq and
1 index 7 index eq and{CMAPDEBUG{(merge!\n)print}if
pop 4 2 roll pop pop
5 -1 roll 3 -1 roll concatstrings
4 -1 roll 3 -1 roll concatstrings
3 -1 roll}if}if}repeat
counttomark 2 add -1 roll .appendmap}bind def/.endmapvalue{2 string dup 0 3 index -8 bitshift put
dup 1 4 -1 roll 255 and put
.FontIndex}bind def/beginnotdefchar{pop mark}bind def/endnotdefchar{2 .endmapchars}bind def/beginnotdefrange{pop mark}bind def
/endnotdefrange{2 .endmapranges}bind def
currentdict end
languagelevel exch 2 .setlanguagelevel/CMap/Generic/Category findresource dup length dict .copydict
dup/InstanceType/dicttype put
dup/DefineResource{dup/CMapName known not{dup wcheck not{.currentglobal exch dup wcheck .setglobal
dup length dict .copydict exch .setglobal}if
dup gcheck 2 index gcheck not and{exch .currentglobal exch//true .setglobal
dup length string copy exch .setglobal exch}if dup/CMapName 3 index put}if
dup/CIDSystemInfo known not{dup wcheck not{.currentglobal exch dup wcheck .setglobal
dup length dict .copydict exch .setglobal}if
dup/CIDSystemInfo[//null]put}if
dup/CodeMap .knownget{//null eq{.buildcmap}if}if/Generic/Category findresource/DefineResource get exec}bind put
/Category defineresource pop/CIDInit/ProcSet 2 copy{findresource}.internalstopped//true .setglobal{pop pop 3 -1 roll}
{dup length 4 index length add dict .copydict 4 -1 roll exch .copydict}ifelse exch defineresource pop
.setlanguagelevel
languagelevel 1 .setlanguagelevel
level2dict begin/.beginpage{.currentshowpagecount{.currentpagedevice pop
dup//null ne{/BeginPage .knownget}{pop//false}ifelse{count 2 .execn
count 1 add exch sub{pop}repeat}{pop}ifelse}if}bind odef/.endpage{.currentshowpagecount{1 index .currentpagedevice pop
dup//null ne{/EndPage .knownget}{pop//false}ifelse{count 2 .execn
count 2 add exch sub{exch pop}repeat}{pop pop 2 ne}ifelse}{2 ne}ifelse}bind odef(%gsavepagedevice)cvn
{currentpagedevice pop gsave}bind def(%savepagedevice)cvn{currentpagedevice pop save}bind def(%gstatepagedevice)cvn
{currentpagedevice pop gstate}bind def(%copygstatepagedevice)cvn{currentpagedevice pop copy}bind def
(%currentgstatepagedevice)cvn{currentpagedevice pop currentgstate}bind def/.installpagedevice{
.currentpagedevice pop//null currentdevice//null .trysetparams
dup type/booleantype eq{pop pop}{SETPDDEBUG{(Error in .trysetparams!)= pstack flush}if
cleartomark pop pop pop/.installpagedevice cvx/rangecheck signalerror}ifelse pop pop
erasepage .beginpage}bind def/.uninstallpagedevice{2 .endpage{.currentnumcopies//false .outputpage}if
nulldevice}bind def(%grestorepagedevice)cvn{.uninstallpagedevice grestore .installpagedevice}bind def
(%grestoreallpagedevice)cvn{.uninstallpagedevice grestore .installpagedevice grestoreall}bind def(%restore1pagedevice)cvn
{.uninstallpagedevice grestore .installpagedevice restore}bind def(%restorepagedevice)cvn
{.uninstallpagedevice restore .installpagedevice}bind def(%setgstatepagedevice)cvn
{.uninstallpagedevice setgstate .installpagedevice}bind def/.numcopiesdict mark/NumCopies dup
.dicttomark readonly def/.currentnumcopies{currentdevice//.numcopiesdict .getdeviceparams
dup type/integertype eq{exch pop exch pop}{cleartomark #copies}ifelse}bind odef/.nullpagedevice 0 dict readonly def
/.currentpagedevice{//.currentpagedevice exch dup//null eq{pop//.nullpagedevice}if exch}bind odef/.setpagedevice{
dup//.nullpagedevice eq{pop//null}if//.setpagedevice}bind odef/.defaultpolicies mark
NOMEDIAATTRS{/PolicyNotFound 7/PageSize 7}{/PolicyNotFound 1/PageSize 0}ifelse/PolicyReport{dup/.LockSafetyParams known{
/setpagedevice .systemvar/invalidaccess signalerror}if
pop}bind
.dicttomark readonly def/.requiredattrs mark/PageDeviceName//null/PageOffset[0 0]readonly/InputAttributes{mark
0 mark/PageSize currentdevice/PageSize gsgetdeviceprop .dicttomark
statusdict/.pagetypenames get{counttomark 1 sub 2 idiv exch mark exch/PageSize exch
load dup 0 get exch 1 get 2 array astore .dicttomark}forall
systemdict/NORANGEPAGESIZE known not{counttomark 2 idiv
mark/PageSize[0 dup 16#7ffff dup].dicttomark}if
.dicttomark}(%MediaSource)0/OutputAttributes{mark 0 mark .dicttomark readonly .dicttomark}(%MediaDestination)0
/Install{{.callinstall}}bind/BeginPage{{.callbeginpage}}bind/EndPage{{.callendpage}}bind/Policies .defaultpolicies
/ImagingBBox//null/UseCIEColor/.getuseciecolor load
.dicttomark readonly def/.dynamicppkeys mark/.MediaSize dup/PageCount dup/Colors dup/BitsPerPixel dup/ColorValues dup
.dicttomark readonly def/.makecurrentpagedevice{currentdevice//null .getdeviceparams
counttomark 2 idiv .requiredattrs length add dict
counttomark 2 idiv{dup 4 2 roll put}repeat exch pop
.currentglobal exch dup gcheck .setglobal
.requiredattrs{2 index 2 index known{1 index/Policies eq{2 index
3 2 roll get
exch{2 index 2 index known{pop pop}{2 index 3 1 roll put}ifelse}forall
pop}{pop pop}ifelse}{exec 2 index 3 1 roll put}ifelse}forall exch .setglobal
dup .setpagedevice}bind def/currentpagedevice{.currentpagedevice{dup length 0 eq{pop .makecurrentpagedevice}{
currentdevice//.dynamicppkeys .getdeviceparams .dicttomark{2 index 2 index .knownget{1 index ne}{//true}ifelse
{2 index wcheck not{3 -1 roll
currentglobal 1 index dup gcheck currentglobal and setglobal
length dict
exch setglobal
.copydict
3 1 roll}if
2 index 3 1 roll put}{pop pop}ifelse}forall
currentdevice .devicename/pdfwrite eq{currentdistillerparams{2 index 2 index .knownget{1 index ne}{//true}ifelse
{2 index 3 1 roll put}{pop pop}ifelse}forall}if
dup gcheck not{dup{dup type/dicttype eq{dup gcheck}{//false}ifelse{2 index wcheck not{3 -1 roll dup length dict .copydict
3 1 roll}if
.copytree 2 index 3 1 roll put}{pop pop}ifelse}forall}if
readonly}ifelse}if}bind odef/.copytree{dup length dict exch{dup type/dicttype eq{.copytree}if 2 index 3 1 roll put}forall
}bind def/.mergespecial mark/InputAttributes{dup//null eq{pop//null}{3 copy pop .knownget{dup//null eq{pop dup length dict}
{dup length 2 index length add dict .copydict}ifelse}{dup length dict}ifelse .copydict readonly}ifelse}bind
/OutputAttributes 1 index/Policies{3 copy pop .knownget{dup length 2 index length add dict .copydict}{dup length dict}
ifelse copy readonly}bind
.dicttomark readonly def
NOMEDIAATTRS{/.inputattrkeys[/PageSize]readonly def/.inputselectionkeys[/noInputSelectionsKeys]readonly def/.outputattrkeys[
/noOutputAttrKeys]readonly def}{/.inputattrkeys[/PageSize/MediaColor/MediaWeight/MediaType/InsertSheet/ManualFeed
/LeadingEdge/MediaClass]readonly def/.inputselectionkeys[/MediaPosition/Orientation]readonly def/.outputattrkeys[
/OutputType/Duplex/Tumble/ManualFeed]readonly def}ifelse/.copiedkeys[/OutputDevice
.mergespecial{pop}forall
.inputattrkeys aload pop
.inputselectionkeys aload pop
.outputattrkeys aload pop]readonly def/.presentspecial mark
.dynamicppkeys{pop dup/LeadingEdge ne{//false}{pop}ifelse}forall/.MediaSize//false/Name//false/OutputDevice//false
/PageDeviceName//false/PageOffset//false/PageSize//false/InputAttributes//false
.inputattrkeys{dup dup/PageSize eq exch/LeadingEdge eq or{pop}{{2 index/InputAttributes .knownget{//null eq}{//true}ifelse}}
ifelse}forall
.inputselectionkeys{//false}forall/OutputAttributes//false
.outputattrkeys{{2 index/OutputAttributes .knownget{//null eq}{//true}ifelse}}forall/Install//false/BeginPage//false
/EndPage//false/Policies//false/HWColorMap{//false}/ViewerPreProcess//false/ImagingBBox//false
.dicttomark readonly def/.defaultdeviceparams{finddevice//null .getdeviceparams}bind def/.selectmedia
{5 index 5 -2 roll 4 index .matchmedia{4 index 3 1 roll put pop}{5 index 1 index .knownget{4 index 3 1 roll put}
{3 index exch .undef}ifelse{3 index 1 index .knownget{5 index 2 index .knownget{ne}{pop//true}ifelse}{//true}ifelse
{2 copy/rangecheck put}if pop}forall}ifelse}bind def/.policyprocs mark
0{NOMEDIAATTRS{pop 2 index exch 7 put}{pop dup 4 index exch get 2 array astore
$error/errorinfo 3 -1 roll put
cleartomark/setpagedevice .systemvar/configurationerror signalerror}ifelse}bind
1{SETPDDEBUG{(Rolling back.)= pstack flush}if
3 index 2 index 3 -1 roll .forceput
4 index 1 index .knownget{4 index 3 1 roll .forceput}{3 index exch .undef}ifelse}.bind
7{1 index/PageSize eq{pop pop 1 index/PageSize 7 put}{.policyprocs 0 get exec}ifelse}bind
.dicttomark readonly def/.applypolicies{1 index/Policies get 1 index{type/integertype eq{pop}
{2 copy .knownget not{1 index/PolicyNotFound get}if
.policyprocs 1 index .knownget not{.policyprocs 0 get}if exec}ifelse}forall pop}bind def/.prepareparams{mark exch dup{
.presentspecial 2 index .knownget{exec{3 -1 roll}{pop pop}ifelse}{3 -1 roll}ifelse}forall pop}bind def/.putdeviceparamsonly
{.currentpagedevice{counttomark 4 add 1 roll .putdeviceparams
dup type/booleantype eq{3}{counttomark 5 add}ifelse -1 roll
.setpagedevice}{pop .putdeviceparams}ifelse}bind def/.trysetparams{//true 4 index .prepareparams
counttomark 5 add index .computemediasize
exch pop exch pop/.MediaSize exch
SETPDDEBUG{(Putting.)= pstack flush}if
.putdeviceparamsonly
SETPDDEBUG{(Result of putting.)= pstack flush}if}bind def/.computemediasize{dup/PageSize get
1 index/InputAttributes get
2 index(%MediaSource)get get/PageSize get
2 index/Policies get
dup/PageSize .knownget{exch pop}{/PolicyNotFound get}ifelse
3 index/Orientation .knownget not{//null}if
4 index/RollFedMedia .knownget not{//false}if
matrix .matchpagesize not{/setpagedevice .systemvar/rangecheck signalerror}if
2 array astore}bind def/setpagedevice{mark 1 index currentpagedevice
SETPDDEBUG{(Checking.)= pstack flush}if
dup/OutputDevice .knownget{2 index/OutputDevice .knownget{2 copy eq{pop pop//null}{exch pop}ifelse}{pop//null}ifelse}{
1 index/OutputDevice .knownget not{.defaultdevicename}if}ifelse
dup//null eq{pop}{exch pop .defaultdeviceparams
.requiredattrs{exec}forall .dicttomark}ifelse
exch dup/ViewerPreProcess .knownget{exec}{1 index/ViewerPreProcess .knownget{exec}if}ifelse exch
SETPDDEBUG{(Merging.)= pstack flush}if
exch 1 index length 1 index length add dict
.copiedkeys{3 index 1 index .knownget{3 copy put pop}if pop}forall
dup 2 index{.mergespecial 2 index .knownget{exec}if
put dup}forall pop
FIXEDRESOLUTION{dup/HWResolution .undef}if
FIXEDMEDIA{dup/PageSize 4 index/PageSize get put
dup/HWSize 4 index/HWSize get put}if
dup/PageSize .knownget{length 2 ne{dup/PageSize 4 index/PageSize get put}if}if
SETPDDEBUG{(Selecting.)= pstack flush}if
0 dict
1 index/InputAttributes .knownget{2 index/Policies get
.inputattrkeys(%MediaSource)cvn .selectmedia}if
1 index/OutputAttributes .knownget{2 index/Policies get
.outputattrkeys(%MediaDestination)cvn .selectmedia}if
3 -1 roll 4 1 roll
.applypolicies
3 -1 roll 4 1 roll
SETPDDEBUG{(Constructing.)= pstack flush}if
currentdevice .devicename 2 index/OutputDevice get eq{currentdevice}{1 index/OutputDevice get finddevice}ifelse
2 index/Policies get
.trysetparams
dup type/booleantype ne{SETPDDEBUG{(Recovering.)= pstack flush}if
counttomark 4 add index
counttomark 2 idiv{dup 4 -2 roll put}repeat
pop pop pop
6 2 roll 3 -1 roll 4 1 roll
.applypolicies
3 -1 roll 4 1 roll 6 -2 roll
.trysetparams
dup type/booleantype ne{2{counttomark 1 add 1 roll cleartomark}repeat/setpagedevice .systemvar exch signalerror}if}if
SETPDDEBUG{(Installing.)= pstack flush}if
pop 2 .endpage{1//true .outputpage(>>setpagedevice, press <return> to continue<<\n).confirm}if
.currentpagedevice pop exch
.setdevice pop
.setpagedevice/.setuseciecolor where{pop 1 index/UseCIEColor .knownget{dup .setuseciecolor not{/DeviceRGB setcolorspace}if}if}
if
exch currentpagedevice dup length 2 index length add dict
2 index/OutputDevice .knownget{2 index/OutputDevice .knownget not{//null}if eq}{//true}ifelse{.copydict}{exch pop
}ifelse .copydict
.computemediasize pop initmatrix concat
dup/PageOffset .knownget{dup 0 get exch 1 get
2 index/HWResolution get dup 1 get exch 0 get
4 -1 roll mul 72 div 3 1 roll mul 72 div
idtransform translate}if
dup .setpagedevice
.setdefaulthalftone
dup/Install .knownget{{.execinstall}stopped{pop
1 index/Install $error/errorname get put
exch 4 2 roll exch 4 2 roll .applypolicies exch 4 2 roll exch 4 2 roll
dup/Install .knownget{{.execinstall}stopped{pop}if}if
.postinstall stop}{.postinstall}ifelse}{.postinstall}ifelse}odef/.execinstall{dup
exec
pop}odef/.postinstall{matrix currentmatrix .setdefaultmatrix
initgraphics
currentoverprint//false setoverprint 1 setcolor
.fillpage
0 setcolor setoverprint
.beginpage
SETPDDEBUG{(Finishing.)= pstack flush}if
exch dup length 0 ne{1 index/Policies get/PolicyReport get
counttomark 1 add 2 roll cleartomark
exec}{cleartomark}ifelse pop}odef
end
.setlanguagelevel
languagelevel dup 2 .max .setlanguagelevel/BitmapFontInit mark/.makeglyph32 systemdict/.makeglyph32 get
systemdict/.makeglyph32 .undef/addglyph{1 index dup 2 index .removeglyphs
22 string .makeglyph32
3 index()ne{dup length 4 index length 5 mul add 10 add string
dup 0 3 index putinterval
dup 2 index length 1 index length 1 index sub getinterval
mark/Columns 8 index dup 4 get exch 2 get sub/Rows 10 index dup 5 get exch 3 get sub/K -1/EndOfBlock true/BlackIs1 true
.dicttomark/CCITTFaxEncode filter
dup 6 index writestring closefile{dup dup length 1 sub get 0 ne{exit}if
0 1 index length 1 sub getinterval}loop
0 1 index length 3 sub getinterval
exch pop}if
1 index/CharStrings get 3 index 3 -1 roll put
pop pop pop pop}obind/removeall{0 65535 2 index removeglyphs pop}obind/.removeglyphs systemdict/.removeglyphs get
systemdict/.removeglyphs .undef/removeglyphs{3 copy .removeglyphs
dup/CharStrings get dup{pop dup 5 index ge{dup 4 index le{2 copy undef}if}if pop}forall pop pop pop pop}obind
.dicttomark/ProcSet defineresource pop/.cidfonttypes where{pop}{/.cidfonttypes 6 dict def}ifelse
.cidfonttypes begin
4{dup/FontType 32 .forceput
dup/CharStrings 20 dict .forceput
1 index exch .buildfont32 exch pop}bind def
end(%Type32BuildGlyph)cvn{1 index/CharStrings get
dup 2 index .knownget{exch pop}{0 .knownget not{exch pop
.getshowoperator/invalidfont signalerror}if}ifelse
dup//.getmetrics32
dup 14 gt{8 index 8 index 13 3 roll setcachedevice2}{4 index 4 index 9 3 roll setcachedevice}ifelse
6 -1 roll 4 -1 roll 1 index length 1 index sub getinterval
dup()eq{pop pop pop}{mark/Columns 6 index/Rows 7 index/K -1/EndOfBlock false/BlackIs1 true
.dicttomark/CCITTFaxDecode filter 4 index 4 index true[1 0 0 1 11 -2 roll exch neg exch neg]5 -1 roll imagemask}ifelse
pop pop pop pop}.bind def
systemdict/.getmetrics32 .undef
buildfontdict 32/.buildfont32 cvx put
32 dup/FontType defineresource pop
.setlanguagelevel
level2dict begin/.reusablestreamdecode{dup type/dicttype eq{2 copy}{dup 0 dict}ifelse
dup .rsdparams
2 index/CloseSource .knownget not{false}if 5 -1 roll
0 1 5 index length 1 sub{4 index 1 index get
4 index null eq{0 dict}{4 index 2 index get dup null eq{pop}if}ifelse
3 -1 roll pop exch filter
exch pop true exch}for
4 index/AsyncRead .knownget not{false}if{1 index{.reusablestream}.internalstopped}{null true}ifelse{pop
dup type/filetype ne{0().subfiledecode}if
.currentglobal 1 index gcheck .setglobal exch
10 dict exch{dup 64000 string readstring
3 index dup length 4 -1 roll put not{exit}if}loop pop
0 1 index{length exch pop add}forall
dup 65400 gt{.bytestring}{string}ifelse
3 -1 roll .setglobal exch{exch 64000 mul exch 2 index 3 1 roll putinterval}forall
1 index .reusablestream}if
4{exch pop}repeat
1 index type/dicttype eq{exch pop}if exch pop}odef
filterdict/ReusableStreamDecode/.reusablestreamdecode load put
end
ll3dict begin
languagelevel dup 2 .max .setlanguagelevel/IdiomRecognition false .definepsuserparam/.bindscratch 128 string def/.bind_{
//.bind currentuserparams/IdiomRecognition
.knownget not{false}if{(*){/IdiomSet findresource
false exch{exch pop dup 1 get exch 0 get
3 index .eqproc{2 index gcheck 1 index gcheck not and{pop}{3 -1 roll pop exch not exit}ifelse}{pop}ifelse}forall{exit}if
}//.bindscratch/IdiomSet resourceforall}if}def/.bind/.bind_ load odef
currentdict/.bindscratch .undef
DELAYBIND NOBIND or not{/bind{//.bind_ exec}odef}if
currentdict/.bind_ undef/.makehalftone7{8 dict begin/HalftoneType 7 def/BitsPerSample exch def
dup null eq{pop 0}{/Height2 1 index def/Width2 2 index def mul}ifelse 3 1 roll/Height 1 index def/Width 2 index def
mul add BitsPerSample 8 idiv mul .bigstring
dup type/stringtype eq{readstring}{.readbytestring}ifelse
not{/sethalftone .systemvar/rangecheck signalerror exit}if
readonly/Thresholds exch def/TransferFunction .knownget{/TransferFunction exch def}if
dup/Thresholds get type/filetype eq{dup/Thresholds[Thresholds]cvx 0().subfiledecode put}if
mark/HalftoneType 5/Default currentdict end .dicttomark{.sethalftone5}}bind def/.bigstring{
dup 65400 gt{.bytestring}{string}ifelse}bind def/.readbytestring{true exch 0 1 2 index length 1 sub{
3 index read not{pop exch not exch exit}if
3 copy put pop pop}for 3 -1 roll pop exch}bind def/.sethalftone6{dup/Thresholds get
1 index/Width get 2 index/Height get
null 8 .makehalftone7}bind def/.sethalftone10{dup/Thresholds get dup type/stringtype eq{0().subfiledecode}if
1 index/Xsquare get dup 3 index/Ysquare get dup
8 .makehalftone7}bind def/.sethalftone16{dup/Thresholds get
1 index/Width get 2 index/Height get
3 index/Width2 .knownget{4 index/Height2 get}{null}ifelse 16 .makehalftone7}bind def
.halftonetypes begin
6/.sethalftone6 load def
10/.sethalftone10 load def
16/.sethalftone16 load def
end/setcolorscreen{/HalftoneMode getuserparam 0 eq{//setcolorscreen}{12{pop}repeat .getdefaulthalftone{//sethalftone}
{.setdefaulthalftone}ifelse}ifelse}odef/setscreen{/HalftoneMode getuserparam 0 eq{//setscreen}{pop pop pop .getdefaulthalftone
{//sethalftone}{.setdefaulthalftone}ifelse}ifelse}odef/sethalftone{/HalftoneMode getuserparam 0 eq{//sethalftone}{
gsave//sethalftone grestore
.getdefaulthalftone{//sethalftone}{.setdefaulthalftone}ifelse}ifelse}odef
.imagetypes
dup 3/.image3 load put
dup 4/.image4 load put/.image3x where{pop dup 103/.image3x load put}if
pop/Generic/Category findresource dup maxlength 3 add dict .copydict begin/InstanceType/integertype def
/FunctionType currentdict end/Category defineresource pop{0 2 3}{dup/FunctionType defineresource pop}forall
/Generic/Category findresource dup maxlength 3 add dict .copydict begin/InstanceType/integertype def
/ShadingType currentdict end/Category defineresource pop
systemdict/.shadingtypes mark
1/.buildshading1 load
2/.buildshading2 load
3/.buildshading3 load
4/.buildshading4 load
5/.buildshading5 load
6/.buildshading6 load
7/.buildshading7 load
.dicttomark put
systemdict/.reuseparamdict mark/Intent 2/AsyncRead false/CloseSource true
.dicttomark readonly put/.buildshading{dup rcheck not{/$error .systemvar/errorinfo[/ColorSpace null]put
/shfill .systemvar/invalidaccess signalerror}if
dup/DataSource .knownget{dup type/filetype eq{//.reuseparamdict/ReusableStreamDecode filter
.currentglobal 2 index gcheck .setglobal
2 index dup length dict copy exch .setglobal
dup/DataSource 4 -1 roll put exch pop}{pop}ifelse}if
dup/ShadingType .knownget not{/$error .systemvar/errorinfo[/ShadingType//null]put/shfill .systemvar/undefined signalerror}if
dup type/integertype ne{/$error .systemvar/errorinfo[/ShadingType 4 index]put/shfill .systemvar/typecheck signalerror}if
//.shadingtypes 1 index .knownget not{/$error .systemvar/errorinfo[/ShadingType 4 index]put
/shfill .systemvar/rangecheck signalerror}if
exch pop 1 index/ColorSpace .knownget{{setcolorspace}stopped{/$error .systemvar/errorinfo[/ColorSpace 4 index]put
/shfill .systemvar/$error .systemvar/errorname get signalerror}if
exec}{/$error .systemvar/errorinfo[/ColorSpace//null]put/shfill .systemvar/undefined signalerror}ifelse}bind def
systemdict/.reuseparamdict undef/.buildpattern2{1 index/Shading get
mark currentcolor currentcolorspace
counttomark 4 add -3 roll mark 4 1 roll{.buildshading}stopped{cleartomark setcolorspace setcolor pop stop}if
.buildshadingpattern
3 -1 roll pop counttomark 1 add 2 roll setcolorspace setcolor pop}bind def
.patterntypes
2/.buildpattern2 load put/shfill{{dup gsave 0 .setoverprintmode .buildshading .shfill}stopped
grestore{/$error .systemvar/errorinfo 2 copy known{pop pop}{//null put}ifelse
stop}if
pop}odef
0.02 setsmoothness
.currentglobal true .setglobal
.cspace_util begin/.setciedefspace where{pop
colorspacedict/CIEBasedDEF
mark/cs_potential_indexed_base true/cs_potential_pattern_base true/cs_potential_alternate true/cs_potential_icc_alternate true
/cs_get_ncomps//ncomps_3/cs_get_range{1 get/RangeDEF .knownget not{//dflt_range_3}if}bind
/cs_get_default_color{1 get/RangeDEF .knownget{aload pop pop 5 1 roll pop 4 1 roll pop 3 1 roll}{0.0 0.0 0.0}ifelse}bind
/cs_get_currentgray//no_currentgray/cs_get_currentrgb//no_currentrgb/cs_get_currentcmyk//no_currentcmyk
/cs_validate//check_cie_cspace/cs_substitute//dup_1/cs_prepare{}/cs_install{NOCIE{pop/DeviceRGB//.cs_install exec}
{1 get .setciedefspace}ifelse}bind/cs_prepare_color//validate_3/cs_complete_setcolor//pop_1
.dicttomark
put}if/.setciedefgspace where{pop
colorspacedict/CIEBasedDEFG
mark/cs_potential_indexed_base true/cs_potential_pattern_base true/cs_potential_alternate true/cs_potential_icc_alternate true
/cs_get_ncomps//ncomps_4/cs_get_range{1 get/RangeDEFG .knownget not{//dflt_range_4}if}bind
/cs_get_default_color{1 get/RangeDEFG .knownget{aload pop pop 7 1 roll pop 6 1 roll pop 5 1 roll pop 4 1 roll}{0.0 0.0 0.0 0.0
}ifelse}bind/cs_get_currentgray//no_currentgray/cs_get_currentrgb//no_currentrgb/cs_get_currentcmyk//no_currentcmyk
/cs_validate//check_cie_cspace/cs_substitute//dup_1/cs_prepare{}/cs_install{NOCIE{pop/DeviceCMYK//.cs_install exec}
{1 get .setciedefgspace}ifelse}bind/cs_prepare_color//validate_4/cs_complete_setcolor//pop_1
.dicttomark
put}if
end
.setglobal
/.setdevicenspace where{pop/.setseparationspace where{pop//false}{//true}ifelse}{//true}ifelse{currentfile closefile}if
.currentglobal true .setglobal
.cspace_util begin/apply_devn_tint_xform{dup 1 get length 1 add exch
mark 2 index 2 add 2 roll
index 3 get exec
counttomark 2 add -2 roll pop}bind def
colorspacedict/DeviceN
mark/cs_potential_indexed_base true/cs_potential_pattern_base true/cs_potential_alternate false
/cs_potential_icc_alternate false/cs_get_ncomps{1 get length}bind/cs_get_range{1 get length[exch{0 1}repeat]}bind
/cs_get_default_color{1 get length{1}repeat}bind/cs_get_currentgray
{//apply_devn_tint_xform exec 2 get//.cs_get_currentgray exec}bind/cs_get_currentrgb
{//apply_devn_tint_xform exec 2 get//.cs_get_currentrgb exec}bind/cs_get_currentcmyk
{//apply_devn_tint_xform exec 2 get//.cs_get_currentcmyk exec}bind/cs_validate{//check_array exec
dup 1 get//check_array exec{type dup/nametype ne exch/stringtype ne and//setcspace_typecheck
if}forall
dup 2 get//.cs_validate exec//.cs_potential_alternate exec not//setcspace_rangecheck
if
dup 3 get//check_array exec xcheck not//setcspace_typecheck
if}bind/cs_substitute{dup 2 get//.cs_substitute exec 2 copy eq{pop pop dup}{exch pop
.currentglobal 3 1 roll//false .setglobal
1 index dup length array copy dup 2 4 -1 roll put
3 -1 roll .setglobal}ifelse}bind/cs_prepare//converttinttransform/cs_install{currentcolorspace
1 index 2 get//forcesetcolorspace
mark 2 index
dup 1 get dup length 1 eq exch 0 get/All eq and{dup length array copy
dup 0/Separation put
dup 1/All put{.setseparationspace}}{{dup .setdevicenspace
dup length 4 gt{dup 4 get/Colorants .knownget{{gsave{//forcesetcolorspace .attachdevicenattributespace}stopped pop
grestore}forall}if}if
pop}}ifelse
stopped{cleartomark setcolorspace stop}{pop pop pop}ifelse}bind
/cs_prepare_color{dup 1 get length//check_num_stack exec pop}bind/cs_complete_setcolor{.usealternate{pop
currentcolor
currentcolorspace 3 get exec
currentcolorspace 2 get//clear_setcolor_operands exec}{pop}ifelse}bind
.dicttomark
put
end
.setglobal
/setoverprintmode{{1}{0}ifelse//.setoverprintmode}odef/currentoverprintmode{//.currentoverprintmode
0 ne}odef/HalftoneMode 0 .definepsuserparam/MaxSuperScreen 1016 .definepsuserparam
pssystemparams begin/MaxDisplayAndSourceList 160000 .forcedef
end{/IdiomSet}{/Generic/Category findresource dup maxlength 3 add dict .copydict begin/InstanceType/dicttype def
currentdict end/Category defineresource pop}forall/languagelevel 3 def/version(3010)readonly def
.setlanguagelevel
end
/currentglobal where{pop currentglobal{setglobal}true setglobal}{{}}ifelse/MacExpertEncoding
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclamsmall/Hungarumlautsmall/centoldstyle/dollaroldstyle/dollarsuperior/ampersandsmall/Acutesmall
/parenleftsuperior/parenrightsuperior/twodotenleader/onedotenleader/comma/hyphen/period/fraction
/zerooldstyle/oneoldstyle/twooldstyle/threeoldstyle/fouroldstyle/fiveoldstyle/sixoldstyle/sevenoldstyle
/eightoldstyle/nineoldstyle/colon/semicolon/.notdef/threequartersemdash/.notdef/questionsmall
/.notdef/.notdef/.notdef/.notdef/Ethsmall/.notdef/.notdef/onequarter
/onehalf/threequarters/oneeighth/threeeighths/fiveeighths/seveneighths/onethird/twothirds
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/ff/fi
/fl/ffi/ffl/parenleftinferior/.notdef/parenrightinferior/Circumflexsmall/hypheninferior
/Gravesmall/Asmall/Bsmall/Csmall/Dsmall/Esmall/Fsmall/Gsmall/Hsmall/Ismall/Jsmall/Ksmall/Lsmall/Msmall/Nsmall/Osmall
/Psmall/Qsmall/Rsmall/Ssmall/Tsmall/Usmall/Vsmall/Wsmall/Xsmall/Ysmall/Zsmall/colonmonetary/onefitted/rupiah/Tildesmall/.notdef
/.notdef/asuperior/centsuperior/.notdef/.notdef/.notdef/.notdef/Aacutesmall
/Agravesmall/Acircumflexsmall/Adieresissmall/Atildesmall/Aringsmall/Ccedillasmall/Eacutesmall/Egravesmall
/Ecircumflexsmall/Edieresissmall/Iacutesmall/Igravesmall/Icircumflexsmall/Idieresissmall/Ntildesmall/Oacutesmall
/Ogravesmall/Ocircumflexsmall/Odieresissmall/Otildesmall/Uacutesmall/Ugravesmall/Ucircumflexsmall/Udieresissmall
/.notdef/eightsuperior/fourinferior/threeinferior/sixinferior/eightinferior/seveninferior/Scaronsmall
/.notdef/centinferior/twoinferior/.notdef/Dieresissmall/.notdef/Caronsmall/osuperior
/fiveinferior/.notdef/commainferior/periodinferior/Yacutesmall/.notdef/dollarinferior/.notdef
/.notdef/Thornsmall/.notdef/nineinferior/zeroinferior/Zcaronsmall/AEsmall/Oslashsmall
/questiondownsmall/oneinferior/Lslashsmall/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/Cedillasmall/.notdef/.notdef/.notdef/.notdef/.notdef/OEsmall
/figuredash/hyphensuperior/.notdef/.notdef/.notdef/.notdef/exclamdownsmall/.notdef
/Ydieresissmall/.notdef/onesuperior/twosuperior/threesuperior/foursuperior/fivesuperior/sixsuperior
/sevensuperior/ninesuperior/zerosuperior/.notdef/esuperior/rsuperior/tsuperior/.notdef
/.notdef/isuperior/ssuperior/dsuperior/.notdef/.notdef/.notdef/.notdef
/.notdef/lsuperior/Ogoneksmall/Brevesmall/Macronsmall/bsuperior/nsuperior/msuperior
/commasuperior/periodsuperior/Dotaccentsmall/Ringsmall/.notdef/.notdef/.notdef/.notdef
256 packedarray
6 1 index .registerencoding
.defineencoding
exec
/currentglobal where{pop currentglobal{setglobal}true setglobal}{{}}ifelse/MacRomanEncoding
StandardEncoding 0 39 getinterval aload pop/quotesingle
StandardEncoding 40 56 getinterval aload pop/grave
StandardEncoding 97 31 getinterval aload pop/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave/ecircumflex/edieresis/iacute/igrave
/icircumflex/idieresis/ntilde/oacute/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/.notdef/AE/Oslash/.notdef/plusminus/.notdef/.notdef/yen/mu/.notdef/.notdef
/.notdef/.notdef/.notdef/ordfeminine/ordmasculine/.notdef/ae/oslash/questiondown/exclamdown/logicalnot/.notdef
/florin/.notdef/.notdef/guillemotleft/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/.notdef/ydieresis/Ydieresis/fraction/currency
/guilsinglleft/guilsinglright/fi/fl/daggerdbl/periodcentered/quotesinglbase/quotedblbase
/perthousand/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave/Oacute/Ocircumflex
/.notdef/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
256 packedarray
5 1 index .registerencoding
.defineencoding
exec
/currentglobal where{pop currentglobal{setglobal}true setglobal}{{}}ifelse/PDFDocEncoding
ISOLatin1Encoding 0 24 getinterval aload pop/breve/caron/circumflex/dotaccent/hungarumlaut/ogonek/ring/tilde
ISOLatin1Encoding 32 7 getinterval aload pop/quotesingle
ISOLatin1Encoding 40 5 getinterval aload pop/hyphen
ISOLatin1Encoding 46 50 getinterval aload pop/grave
ISOLatin1Encoding 97 31 getinterval aload pop/bullet/dagger/daggerdbl/ellipsis/emdash/endash/florin/fraction
/guilsinglleft/guilsinglright/minus/perthousand/quotedblbase/quotedblleft/quotedblright/quoteleft
/quoteright/quotesinglbase/trademark/fi/fl/Lslash/OE/Scaron/Ydieresis/Zcaron/dotlessi/lslash/oe/scaron/zcaron/.notdef/Euro
ISOLatin1Encoding 161 12 getinterval aload pop/.notdef
ISOLatin1Encoding 174 82 getinterval aload pop
256 packedarray .defineencoding
exec
/currentglobal where{pop currentglobal{setglobal}true setglobal}{{}}ifelse/WinAnsiEncoding
ISOLatin1Encoding 0 39 getinterval aload pop/quotesingle
ISOLatin1Encoding 40 5 getinterval aload pop/hyphen
ISOLatin1Encoding 46 50 getinterval aload pop/grave
ISOLatin1Encoding 97 30 getinterval aload pop/bullet/Euro/bullet/quotesinglbase/florin/quotedblbase/ellipsis/dagger/daggerdbl
/circumflex/perthousand/Scaron/guilsinglleft/OE/bullet/Zcaron/bullet/bullet/quoteleft/quoteright/quotedblleft
/quotedblright/bullet/endash/emdash/tilde/trademark/scaron/guilsinglright/oe/bullet/zcaron/Ydieresis
ISOLatin1Encoding 160 96 getinterval aload pop
256 packedarray
4 1 index .registerencoding
.defineencoding
exec
.currentglobal true .setglobal
systemdict/pdfmark known not{userdict/pdfmark{cleartomark}bind put}if
userdict/GS_PDF_ProcSet 127 dict dup begin/bdef{bind def}bind def/nodict 1 dict def
nodict/self{//nodict}executeonly put
nodict readonly pop/dictbeginpage{//nodict 20 dict .copydict begin{def}forall
graphicsbeginpage textbeginpage}bdef/endpage{showpage end}bdef/graphicsbeginpage{initgraphics//true .setaccuratecurves
currentdict/ClipRect knownoget{aload pop rectclip}if
0 g 0 G false op false OP 0 OPM
1 ca 1 CA null SMask false AIS/Compatible BM true TK}bdef/gput
{exch currentdict//nodict eq{/self dup load end 5 dict begin def}if
currentdict length currentdict maxlength ge{currentdict dup length 3 mul 2 idiv 1 add dict .copydict end begin}if def}bdef
/grestore_nopath{matrix setmatrix .getpath
grestore matrix currentmatrix matrix setmatrix
exch newpath{exec}forall setmatrix}bdef/q{gsave//nodict begin}bdef/Q{currentdict/self .knownget{
exec//nodict eq{end grestore_nopath false}{true}ifelse}{true}ifelse
{(\n   **** File has imbalanced q/Q operators \(too many Q's\) ****\n)pdfformaterror}if}bdef/qstate{gstate}bdef/setqstate{
{matrix setmatrix//false upath}stopped{pop setgstate newpath}{exch setgstate matrix currentmatrix matrix setmatrix
exch newpath uappend setmatrix}ifelse}bdef/fcput{/FillColorSpace gput/FillColor gput}bdef/scput
{/StrokeColorSpace gput/StrokeColor gput}bdef/csput{csset 2 copy fcput scput}bdef/csdevgray[/DeviceGray]readonly def
/csdevrgb[/DeviceRGB]readonly def/csdevcmyk[/DeviceCMYK]readonly def/cspattern[/Pattern]readonly def/nullpattern1 mark
/PatternType 1/PaintType 1/TilingType 3/BBox[0 0 1 1]/XStep 1/YStep 1/PaintProc{pop}bind
.dicttomark readonly def/nullpattern2 nullpattern1 dup length dict copy readonly def/CSdict mark
/DeviceGray{pop//csdevgray 0}bind/DeviceRGB{pop//csdevrgb[0 0 0]cvx}bind/DeviceCMYK{pop//csdevcmyk[0 0 0 1]cvx}bind
/CIEBasedA{0}bind/CIEBasedABC{[0 0 0]cvx}bind/ICCBased{[1 index 1 oget/N get{0}repeat]cvx}bind/Separation{1}bind/DeviceN{
[1 index 1 get length{1}repeat]cvx}bind/Indexed{0}bind/Pattern{dup type/nametype eq 1 index length 1 eq or{
pop//cspattern//nullpattern1 matrix makepattern}{//nullpattern2 matrix makepattern 1 index 1 get csset
pop[3 1 roll dup type/arraytype eq{aload pop}if
counttomark -1 roll]cvx}ifelse}bind
.dicttomark readonly def/csset{dup dup type/nametype ne{0 get}if//CSdict exch get exec exch}bdef/g{//csdevgray fcput}bdef
/G{//csdevgray scput}bdef/rg{3 array astore cvx//csdevrgb fcput}bdef/RG{3 array astore cvx//csdevrgb scput}bdef
/k{4 array astore cvx//csdevcmyk fcput}bdef/K{4 array astore cvx//csdevcmyk scput}bdef/cs{csset fcput}bdef/CS{csset scput}bdef
/ri{//.renderingintentdict exch .knownget{.setrenderingintent}if}bdef/sc1{/FillColor gput}bdef/SC1{/StrokeColor gput}bdef/sc*{
currentdict/FillColor .knownget{astore pop}{/FillColor load
dup type/arraytype eq{length}{pop 1}ifelse
array astore cvx/FillColor gput}ifelse}bdef/SC*{currentdict/StrokeColor .knownget{astore pop}{/StrokeColor load
dup type/arraytype eq{length}{pop 1}ifelse
array astore cvx/StrokeColor gput}ifelse}bdef/op{/FillOverprint gput}bdef/OP{/StrokeOverprint gput}bdef/OPM{
/.setoverprintmode where{pop .setoverprintmode}{pop}ifelse}bdef/ca{/FillConstantAlpha gput}bdef
/CA{/StrokeConstantAlpha gput}bdef/SMask{/SoftMask gput}bdef/AIS{/AlphaIsShape gput}bdef/BM{/.setblendmode where{
pop[exch dup type/nametype ne{aload pop}if/Normal]{{.setblendmode}.internalstopped not{exit}if pop}forall}{pop}ifelse}bdef/TK{
/.settextknockout where{pop .settextknockout}{pop}ifelse}bdef/.settransparencyparams{PDFusingtransparency{
/.inittransparencymask where{pop AlphaIsShape{1 .setopacityalpha 0 .inittransparencymask exch .setshapealpha 1}{
1 .setshapealpha 1 .inittransparencymask exch .setopacityalpha 0}ifelse
.settransparencymask}{pop pop}ifelse}{pop pop}ifelse}bdef/.settransparencymask{exch dup null eq{PDFusingtransparency{
pop .inittransparencymask}{dup/Draw get exec}ifelse}{dup/Draw get exec}ifelse}bdef/setfillblend{FillOverprint setoverprint
FillConstantAlpha SoftMask .settransparencyparams}def/setfillstate{FillColor FillColorSpace setgcolor setfillblend}def
/setstrokestate{StrokeColor StrokeColorSpace setgcolor StrokeOverprint setoverprint
StrokeConstantAlpha SoftMask .settransparencyparams}def/Cdict 15 dict dup begin/DeviceGray{pop setgray}bdef
/DeviceRGB{pop setrgbcolor}bdef/DeviceCMYK{pop setcmykcolor}bdef/CIEBasedA{setgcolorspace setcolor}bdef
/CIEBasedABC/CIEBasedA load def/CIEBasedDEF/CIEBasedA load def/CIEBasedDEFG/CIEBasedA load def/ICCBased/CIEBasedA load def
/Separation/CIEBasedA load def/DeviceN/CIEBasedA load def/Indexed/CIEBasedA load def/Pattern{setgcolorspace
dup/Shading knownoget{dup/ShadingType oget 4 ge{/DataSource knownoget{dup type/filetype eq{0 setfileposition}{pop}ifelse}if}{
pop}ifelse}if
dup/Matrix knownoget not{matrix}if
gsave DefaultQstate setqstate makepattern grestore setcolor}bdef
end def/setgcolor{1 index null eq{pop pop}{dup 0 get//Cdict exch get exec}ifelse}bdef/PCSdict 15 dict dup begin
/CIEBasedA{dup 1 get/PDFColorSpace .knownget{exch pop}if}bdef/CIEBasedABC/CIEBasedA load def/CIEBasedDEF/CIEBasedA load def
/CIEBasedDEFG/CIEBasedA load def/Indexed{dup 1 get dup pdfcolorspace 2 copy ne{3 1 roll}if pop pop}bdef
end def/pdfcolorspace{dup type/arraytype eq{//PCSdict 1 index 0 get .knownget{exec}if}if}bdef/setgcolorspace{
dup pdfcolorspace currentcolorspace pdfcolorspace eq{pop}{setcolorspace}ifelse}bdef/fsexec{{currentpoint}stopped
{$error/newerror false put cvx exec}{3 -1 roll cvx exec moveto}ifelse}bdef/S{setstrokestate/stroke fsexec}bdef
/f{setfillstate/fill fsexec}bdef/f*{setfillstate/eofill fsexec}bdef/n{newpath}bdef/s{closepath S}bdef
/B{gsave setfillstate fill grestore S}bdef/b{closepath B}bdef/B*{gsave setfillstate eofill grestore S}bdef/b*{closepath B*}bdef
/Wdict 4 dict dup begin/S{gsave setstrokestate stroke grestore n}bdef/f{gsave setfillstate fill grestore n}bdef
/f*{gsave setfillstate eofill grestore n}bdef/n{end clip newpath}bdef
end readonly def/W{//Wdict begin}bdef/W*dict 4 dict dup begin
Wdict{def}forall/n{end eoclip newpath}bdef
end readonly def/W*{//W*dict begin}bdef/textbeginpage{/TextSpacing 0 def/TextLeading 0 def/TextRenderingMode 0 def
/TextRise 0 def/WordSpacing 0 def/TextHScaling 1.0 def/TextFont null def/FontMatrixNonHV//false def/Show{showfirst}def}bdef
/settextmatrix{TextMatrix concat
TextHScaling 1 ne{TextHScaling 1 scale}if
TextRise 0 ne{0 TextRise translate}if
TextFont dup null eq{pop}{setfont}ifelse}bdef/settextstate{currentdict/TextSaveMatrix known{
TextSaveMatrix setmatrix settextmatrix}if}bdef/settextposition{gsave TextSaveMatrix setmatrix
currentpoint TextRise sub TextMatrix 4 2 getinterval astore pop
TextTempMatrix identmatrix setmatrix currentpoint
grestore
TextTempMatrix currentmatrix 4 2 getinterval astore pop
TextTempMatrix setmatrix}bdef/BT{currentdict/TextLineMatrix .knownget{identmatrix pop TextMatrix identmatrix pop}
{matrix/TextLineMatrix gput matrix/TextMatrix gput}ifelse{showfirst}/Show gput
currentdict/TextSaveMatrix .knownget not{matrix dup/TextSaveMatrix gput}if currentmatrix pop settextmatrix
matrix/TextTempMatrix gput}bdef/ET{TextRenderingMode 4 ge{clip newpath}if
TextSaveMatrix setmatrix
currentdict/TextSaveMatrix undef}bdef/Tc{/TextSpacing gput{showfirst}/Show gput}bdef/TL{/TextLeading gput}bdef
/Tr{dup .settextrenderingmode/TextRenderingMode gput{showfirst}/Show gput}bdef/Ts{/TextRise gput settextstate}bdef
/Tw{/WordSpacing gput{showfirst}/Show gput}bdef/Tz{100 div/TextHScaling gput settextstate}bdef/?FontMatrixNonHV{
/FontMatrix .knownget{1 index{1}{2}ifelse get 0 ne}{//false}ifelse}bdef/?FontMatrixNonHV{2 copy//?FontMatrixNonHV exec{
pop pop//true}{pop
dup/FontType get
dup 0 eq{pop/FDepVector get 2 index}{9 eq{/FDArray get//?FontMatrixNonHV}{pop{}{}}ifelse}ifelse//false 5 2 roll{4 index exec{
4 -1 roll pop//true 4 1 roll
exit}if}forall
4 2 roll exch pop}ifelse}bdef/?FontMatrixNonHV{//?FontMatrixNonHV exch
dup/WMode .knownget{0 eq}{//true}ifelse
exch//?FontMatrixNonHV exec
exch pop exch pop}bdef/Tf{dup 0 eq{(\n   **** Warning: Invalid 0.0 font scale given for Tf ****\n)pdfformaterror
pop 0.00000001}if
1 index type/dicttype ne{selectfont currentfont}{dup 1 eq{pop}{scalefont}ifelse}ifelse
dup ?FontMatrixNonHV dup FontMatrixNonHV ne{/FontMatrixNonHV gput{showfirst}/Show gput}{pop}ifelse/TextFont gput settextstate
}bdef/FRD{/FontSetInit/ProcSet findresource begin//true ReadData}bdef/.copyfontdict{1 index/FID known
1 index{2 index/UniqueID known or 2 index/XUID known or}if{exch dup length 1 add dict exch{1 index/FID eq 4 index
{2 index/UniqueID eq or 2 index/XUID eq or}if not{3 copy put}if pop pop}forall exch}if pop}bdef/.updatefontmetrics{
dup//null ne{exch//true .copyfontdict dup/Metrics 4 -1 roll put//true}{pop//false}ifelse}bdef/.updatefontencoding{
dup//null ne{dup 2 index/Encoding get ne}{//false}ifelse{exch//false .copyfontdict dup/Encoding 4 -1 roll put//true}{pop//false
}ifelse}bdef/.update_charstring{dup//null ne{exch//true .copyfontdict
dup dup/CharStrings get
dup length
4 index length add
dict copy dup begin/CharStrings exch put
exch{currentdict exch .knownget{def}{currentdict/.notdef .knownget{def}{pop}ifelse}ifelse}forall
end//true}{pop//false}ifelse}bdef/.updatefont{4 2 roll
.updatefontencoding
4 1 roll exch
.update_charstring
3 1 roll exch
.updatefontmetrics
4 2 roll or or}bdef/Td{TextLineMatrix transform TextLineMatrix 4 2 getinterval astore pop
TextLineMatrix TextMatrix copy pop settextstate}bdef/TD{dup neg/TextLeading gput Td}bdef/T*{0 TextLeading neg Td}bdef/Tm{
TextLineMatrix astore TextMatrix copy pop settextstate}bdef/Vexch{rootfont/WMode knownoget{1 eq{exch}if}if}bind def
/textrenderingprocs[{tf}{tS}{tB}{tn}{gsave tf grestore tW}{gsave tS grestore tW}{gsave tB grestore tW}{tW}]readonly def
/setshowstate{WordSpacing 0 eq TextSpacing 0 eq and FontMatrixNonHV not and
{TextRenderingMode 0 eq currentdevice .devicename/pdfwrite eq or{{setfillstate show}}{TextRenderingMode 3 eq{{
matrix currentmatrix dup dup
dup 0 get 0 eq 1 index 1 get 0 eq and{dup dup 2 get 0 eq{0}{1}ifelse 1 put}if
dup 2 get 0 eq 1 index 3 get 0 eq and{dup dup 1 get 0 eq{3}{2}ifelse 1 put}if
setmatrix
2 index setfillstate show
setmatrix
gsave nulldevice
setmatrix
false charpath currentpoint newpath
grestore
moveto}}{{false charpath textrenderingprocs TextRenderingMode get exec}}ifelse}ifelse}
{TextRenderingMode 0 eq TextRenderingMode 3 eq or currentdevice .devicename/pdfwrite eq or{FontMatrixNonHV{{setfillstate
[TextSpacing WordSpacing 3 index{exch
Vexch pop
3 index add exch 32 eq{1 index add}if
3 1 roll}currentfont/FontMatrix get 0 3 Vexch pop get 0 ne{1 1 index length 1 sub getinterval cvx}if
cshow pop pop]{xshow}{yshow}Vexch pop exec}}{WordSpacing 0 eq{{setfillstate TextSpacing 0 Vexch 3 -1 roll ashow}}
{TextSpacing 0 eq{{setfillstate WordSpacing 0 Vexch 32 4 -1 roll widthshow}}{{setfillstate WordSpacing 0 Vexch 32
TextSpacing 0 Vexch 6 -1 roll awidthshow}}ifelse}ifelse}ifelse}{{WordSpacing TextSpacing{exch
Vexch pop currentpoint 6 3 roll(x)dup 0 3 index put//false charpath
3 copy 32 eq{add}{exch pop}ifelse
7 -3 roll moveto add
0 Vexch rmoveto pop}FontMatrixNonHV dup not exch{currentfont/FontMatrix get 0 3 Vexch pop get 0 ne}if{
1 1 index length 1 sub getinterval cvx}if
4 -1 roll cshow pop pop
textrenderingprocs TextRenderingMode get exec}}ifelse}ifelse/Show gput}bdef/showfirst{setshowstate Show}def/Tj{
0 0 moveto Show settextposition}bdef/'{T* Tj}bdef/"{exch Tc exch Tw T* Tj}bdef/TJ{0 0 moveto{dup type/stringtype eq{Show
}{-1000 div
currentfont/ScaleMatrix .knownget{0 get mul}if
0 Vexch rmoveto}ifelse}forall settextposition}bdef/tf{setfillstate currentpoint fill moveto}bdef
/tn{currentpoint newpath moveto}bdef/Tmatrix matrix def/tS{setstrokestate
currentpoint//Tmatrix currentmatrix TextSaveMatrix setmatrix stroke
setmatrix moveto}bdef/tB{gsave tf grestore tS}bdef/tW{}bdef/Tform{clippath pathbbox 4 2 roll pop pop
currentfont/ScaleMatrix .knownget{3 get}{1}ifelse
currentfont/FontBBox get dup 1 get neg exch 3 get
dup 0 ne{div}{pop pop 0}ifelse
1 index mul
4 index 16#1000 and 0 ne{8{pop}repeat(Multiline form fields are not yet implemented.)=}{4 index 16#1000000 and 0 ne{
8{pop}repeat(Combed form fields are not yet implemented.)=}{3 1 roll sub add 2 div
0 exch moveto
1 index 0 ne{3 index stringwidth pop
sub exch 1 eq{2 div}{2 sub}ifelse
0 rmoveto
pop}{pop pop pop
2 0 rmoveto}ifelse
exch pop Show}ifelse}ifelse}bdef
end readonly put
.setglobal
/currentglobal where{pop currentglobal{setglobal}true setglobal}{{}}ifelse/packedarray where{pop}
{/packedarray{array astore readonly}bind def}ifelse
11 dict/.csncompdict 1 index def begin/DeviceGray{1/setgray load}bind def/DeviceRGB{3/setrgbcolor load}bind def
/DeviceCMYK{4/setcmykcolor load}bind def/Indexed{dup 1 index 1 get//.csncompdict exch get exec
3 -1 roll 3 get mark 3 1 roll
dup type/stringtype eq{{-{exch round cvi get 255 div}-{exch round cvi 3 mul 2 copy 2 copy get 255 div
3 1 roll 1 add get 255 div
4 2 roll 2 add get 255 div}{exch round cvi 4 mul 2 copy 2 copy 2 copy get 255 div
3 1 roll 1 add get 255 div
4 2 roll 2 add get 255 div
5 3 roll 3 add get 255 div}}4 index get aload pop counttomark -1 roll}{/exec load 3 -1 roll}ifelse .packtomark cvx
exch pop 1 exch}bind def/Separation{dup 2 index//.csncompdict exch get exec
3 -1 roll 3 get/exec load 3 -1 roll 3 array astore readonly cvx
exch pop 1 exch}bind def/CIEBasedA/DeviceGray load def/CIEBasedABC/DeviceRGB load def/CIEBasedDEF/DeviceRGB load def
/CIEBasedDEFG/DeviceCMYK load def
end/.packtomark{counttomark packedarray exch pop}bind def/.csinextbits{/nnb nnb BitsPerComponent add{dup 0 le{exit}if
/b b 8 bitshift row i get add def/i i 1 add def 8 sub}loop def
b nnb bitshift mask and}bind def/.colorspaceimage{save exch
dup length 15 add dict begin{cvlit def}forall
ColorSpace dup dup type/nametype ne{0 get}if
.csncompdict exch get exec/setpixelcolor exch def/ncomp exch def pop
/row ncomp BitsPerComponent mul Width mul 7 add 8 idiv string def/mask 1 BitsPerComponent bitshift 1 sub def
/nextbits BitsPerComponent 8 eq{{row i get/i i 1 add def}}{/.csinextbits load}ifelse def/nextpixel mark 0 2 ncomp 1 sub 2 mul
{/nextbits cvx exch
Decode exch 2 getinterval
dup aload pop exch sub
dup mask eq{pop}{mask div/mul load 3 -1 roll}ifelse
0 get dup 0 eq{pop}{/sub load 3 -1 roll}ifelse}for/setpixelcolor load dup type/operatortype ne{/exec load}if
.packtomark cvx def/readrow/DataSource load dup type
dup/arraytype eq exch/packedarraytype eq or{aload length 1 add array/pop load exch astore
dup 1 row put cvx}{pop
row length 0 eq{{}}{{DataSource row readstring pop pop}}ifelse}ifelse def
ImageMatrix matrix invertmatrix concat/imat matrix def
0 1 Height 1 sub{imat 5 3 -1 roll neg put
readrow/b 0 def/nnb 0 def/i 0 def
0 1 Width 1 sub{imat 4 3 -1 roll neg put nextpixel
1 1 true imat{<80>}imagemask}for}for
end restore}bind def
%END
exec
/dup_obj_gen_num false def/setxrefentry{5 1 roll
1 add
dup 255 gt{Generations ltype/stringtype eq{larray Generations llength lgrowto dup
0 1 2 index llength 1 sub{Generations 1 index lget lput dup}for
pop/Generations exch store}if}if
Objects 4 index lget null eq{ObjectStream 4 index 4 index cvx lput
Objects 4 index 3 index cvx lput
Generations 4 index 2 index lput}{Generations 4 index lget 1 index le{ObjectStream 4 index 4 index cvx lput
Objects 4 index 3 index cvx lput
Generations 4 index 2 index lput}if
Generations 4 index lget 1 index eq{/dup_obj_gen_num true def}if}8 -1 roll{ifelse}{pop if}ifelse}bind def/print_xref
{0 1 Objects llength 1 sub{dup =only(  )print
dup Generations exch lget 1 sub =only(  )print
dup ObjectStream exch lget ==only(  )print
Objects exch lget ===}for
flush}bind def/typed_token{exch
token_nofail{dup type
4 -1 roll eq{exch true}{pop pop false}ifelse}{pop false}ifelse}bind def/post_eof_count 0 def/search_start_trailer{
PDFfile 0 setfileposition
PDFfile bytesavailable post_eof_count sub
300 .min
dup string 0 1 4 -1 roll 1 sub{2 copy PDFfile read pop put pop}for(xref)search{
exch pop exch pop length 4 add PDFfile exch setfileposition
PDFfile token pop(trailer)ne{PDFfile token pop
PDFfile token pop pop
25 string exch{PDFfile 1 index readline pop pop}repeat
pop
PDFfile token pop pop
PDFfile fileposition}if}{pop search_end_trailer}ifelse}bind def/search_end_trailer{PDFfile 0 setfileposition
PDFfile bytesavailable post_eof_count sub
dup 65535 .min
2 copy sub PDFfile exch setfileposition
dup string 0 1 4 -1 roll 1 sub{2 copy PDFfile read pop put pop}for(trailer){search not{exit}if pop}loop
length sub}bind def/search_trailer{PDFfile 0 setfileposition
PDFfile bytesavailable
post_eof_count sub dup
dup 4096 .min
2 copy sub PDFfile exch setfileposition
dup string 0 1 4 -1 roll 1 sub{2 copy PDFfile read pop put pop}for
false
exch(startxref){search not{exit}if
pop 3 -1 roll pop true 3 1 roll}loop
exch{length sub 9 sub
PDFfile exch setfileposition PDFfile token
pop pop PDFfile token pop}{pop pop PDFfilelen}ifelse
exch 2 div lt{search_start_trailer}{search_end_trailer}ifelse
PDFfile exch setfileposition/dictlevelcount 0 def
PDFfile traileropdict .pdfrun/Trailer exch def}bind def/determine_post_eof_count{PDFfilelen
dup 4096 .min
2 copy sub PDFfile exch setfileposition
dup string 0 1 4 -1 roll 1 sub{2 copy PDFfile read pop put pop}for(%%EOF){search not{exit}if pop}loop
length exch pop}bind def/search_objects{initPDFobjects/dup_obj_gen_num false def/post_eof_count determine_post_eof_count def
PDFfile 0 setfileposition
65535 dup string{PDFfile fileposition
PDFfile bytesavailable post_eof_count sub 10 sub dup 4 index lt{2 index 0 3 -1 roll getinterval}{pop 1 index}ifelse
PDFfile exch{readline}.internalstopped{pop pop false}if{/integertype typed_token{/integertype typed_token{
/nametype typed_token{pop/obj eq{1 index 20 add 20 idiv 20 mul
growPDFobjects
1 index 0
4 index PDFoffset sub 3 index//true setxrefentry
pop pop pop pop}if}if
pop}if
pop}if}if
pop
PDFfile bytesavailable post_eof_count sub 20 lt{exit}if}loop
pop pop
dup_obj_gen_num{(   **** Warning:  There are objects with matching object and generation\n)pdfformaterror
(   **** numbers.  The accuracy of the resulting image is unknown.\n)pdfformaterror}if}bind def/print_xref_warning
{(   **** Warning:  An error occurred while reading an XREF table.\n)pdfformaterror
(   **** The file has been damaged.  This may have been caused\n)pdfformaterror
(   **** by a problem while converting or transfering the file.\n)pdfformaterror
(   **** Ghostscript will attempt to recover the data.\n)pdfformaterror}bind def/recover_xref_data{print_xref_warning
count pdfemptycount sub{pop}repeat
search_objects}bind def
/.setlanguagelevel where{pop 2 .setlanguagelevel}if
.currentglobal true .setglobal/pdfdict where{pop}{/pdfdict 100 dict def}ifelse
pdfdict begin/valueopdict mark(<<)cvn{mark}bind(>>)cvn{{.dicttomark}stopped{
(   **** File has an unbalanced >> \(close dictionary\).\n)pdfformaterror}if}bind([)cvn{mark}bind(])cvn dup load/F dup cvx
/R dup cvx/stream dup cvx
.dicttomark readonly def/pdfstring 1024 string def/prevline{PDFfile fileposition dup()pdfstring
2 index 257 sub 0 .max PDFfile exch setfileposition{PDFfile fileposition
PDFfile 2 index readline pop
dup length 0 gt{3 2 roll 5 -2 roll pop pop 2 index}{pop}ifelse
PDFfile fileposition 5 index ge{exit}if
pop}loop pop pop 3 -1 roll pop}bind def/.pdffixname{PDFversion 1.2 ge{dup .namestring(#)search{name#escape cvn exch pop}{pop
}ifelse}if}bind def/name#escape{exch pop
1 index 2()/SubFileDecode filter dup(x)readhexstring
not{pop closefile(#)concatstrings exch(   **** Warning: Invalid hex following '#' name escape, using literal '#' in name.\n)
pdfformaterror}{exch closefile concatstrings
exch 2 1 index length 2 sub getinterval}ifelse(#)search{name#escape}if concatstrings}bind def/.pdftokenerror{BXlevel 0 le{
(   **** Unknown operator: ')pdfformaterror
dup =string cvs pdfformaterror
<</PDFScanInvNum true >>setuserparams
=string cvs
token pop exch pop dup type
dup/integertype eq exch/realtype eq or{exch pop exch pop(', processed as number, value: )pdfformaterror
dup =string cvs pdfformaterror(\n)pdfformaterror
<</PDFScanInvNum null >>setuserparams
false}{('\n)pdfformaterror
true}ifelse}{true}ifelse{pop pop count exch sub{pop}repeat}if}bind def/.pdfexectoken{PDFDEBUG{
pdfdict/PDFSTEPcount known not{pdfdict/PDFSTEPcount 1 .forceput}if
PDFSTEP{pdfdict/PDFtokencount 2 copy .knownget{1 add}{1}ifelse .forceput
PDFSTEPcount 1 gt{pdfdict/PDFSTEPcount PDFSTEPcount 1 sub .forceput}{dup ==only(    step # )print PDFtokencount =only
( ? )print flush 1 false .outputpage(%stdin)(r)file 255 string readline{token{exch pop pdfdict/PDFSTEPcount 3 -1 roll .forceput
}{pdfdict/PDFSTEPcount 1 .forceput}ifelse}{pop/PDFSTEP false def}ifelse}ifelse}{dup ==only()= flush}ifelse}if
2 copy .knownget{exch pop exch pop exch pop exec}{dup dup dup/true eq exch/false eq or exch/null eq or{
exch pop exch pop//systemdict exch get}{256 string cvs(endobj)anchorsearch{
(   **** Missing whitespace after 'endobj'.\n)pdfformaterror
exch pop cvn get exch pop exec}{.pdftokenerror}ifelse}ifelse}ifelse}bind def/PDFScanRules_true<</PDFScanRules true >>def
/PDFScanRules_null<</PDFScanRules null >>def/.pdfrun{1 index cvlit count 2 sub 3 1 roll mark
/PDFScanRules .getuserparam//null eq{//PDFScanRules_true{setuserparams}0 get
mark 7 4 roll}{mark 5 2 roll}ifelse{{token}stopped{dup type/filetype eq{pop}if
(   **** Error reading a content stream. The page may be incomplete.\n)pdfformaterror//false}if{dup type/nametype eq{
dup xcheck{.pdfexectoken}{.pdffixname
exch pop exch pop PDFDEBUG{PDFSTEPcount 1 le{dup ==only( )print flush}if}if}ifelse}{exch pop exch pop PDFDEBUG{
PDFSTEPcount 1 le{dup ==only( )print flush}if}if}ifelse}{(%%EOF)cvn cvx .pdfexectoken}ifelse}aload pop .packtomark cvx
{loop}0 get 2 packedarray cvx{stopped}0 get/PDFScanRules .getuserparam//null eq{//PDFScanRules_null{setuserparams}0 get}if
/PDFsource PDFsource{store{stop}if}aload pop .packtomark cvx/PDFsource 3 -1 roll store exec}bind def
currentdict/PDFScanRules_true undef
currentdict/PDFScanRules_null undef/.pdfruncontext{/.pdfrun load LocalResources DefaultQstate/LocalResources 7 -1 roll store
/DefaultQstate qstate store
3 .execn/DefaultQstate exch store/LocalResources exch store}bind def/.pdfcount{count pdfemptycount sub}bind def
/token_nofail_dict mark( ){dup( )readstring pop pop}bind(\t)1 index(\r)1 index(\n)1 index(\000)1 index
({){//null//true exit}bind
.dicttomark def/token_nofail{dup type/filetype eq{{dup( ).peekstring not{({)}if//token_nofail_dict exch .knownget not{
//null 1 index{token}.internalstopped exit}if
exec}loop{//null ne{pop}if pop//false}{{3 1 roll pop pop//true}{pop pop//false}ifelse}ifelse}{//null 1 index
{token}.internalstopped{//null ne{pop}if pop//false}{{4 2 roll pop pop//true}{pop pop//false}ifelse}ifelse}ifelse}bind def
currentdict/token_nofail_dict .undef/lshift 9 def/lnshift lshift neg def/lsubmask 1 lshift bitshift 1 sub def
/lsublen lsubmask 1 add def/larray{[[]]}bind def/lstring{[()]}bind def/ltype{0 get type}bind def/lget{
dup//lsubmask and 3 1 roll//lnshift bitshift get exch get}bind def/lput{3 1 roll
dup//lsubmask and 4 1 roll//lnshift bitshift get
3 1 roll put}bind def/llength{dup length 1 sub dup//lshift bitshift
3 1 roll get length add}bind def/growto{1 index type/stringtype eq{string}{array}ifelse
2 copy copy pop exch pop}bind def/lgrowto{dup//lsubmask add//lnshift bitshift dup 3 index length gt{
3 -1 roll dup llength 1 sub//lsubmask or 1 add lgrowto[exch aload pop
counttomark 2 add -1 roll
counttomark sub{dup 0 0 getinterval lsublen growto}repeat
dup 0 0 getinterval]exch}{pop}ifelse
1 sub//lsubmask and 1 add
exch dup dup length 1 sub 2 copy
get 5 -1 roll growto put}bind def/lforall{/forall cvx 2 packedarray cvx forall}bind def/initPDFobjects{/ObjectStream larray def
/Objects larray def/Generations lstring def
.currentglobal true .setglobal/GlobalObjects 20 dict def
.setglobal/IsGlobal lstring def}bind def/growPDFobjects{dup ObjectStream llength gt{
dup ObjectStream exch lgrowto/ObjectStream exch def}if
dup Objects llength gt{dup Objects exch lgrowto/Objects exch def}if
dup Generations llength gt{dup Generations exch lgrowto/Generations exch def}if
dup IsGlobal llength gt{dup IsGlobal exch lgrowto/IsGlobal exch def}if
pop}bind def/resolved?{Objects 1 index lget dup xcheck{dup type/integertype eq{pop IsGlobal 1 index lget 0 eq{pop false}{
PDFDEBUG{(%Global=>local: )print dup ==}if
GlobalObjects 1 index get dup Objects 4 1 roll lput true}ifelse}{exch pop true}ifelse}{exch pop true}ifelse}bind def
/oforce/exec load def/oget{get oforce}bind def/oforce_array{[exch{oforce}forall]}bind def/oforce_elems{{oforce}forall}bind def
/oforce_recursive{oforce dup type dup/arraytype eq{pop[exch{oforce_recursive}forall]}{/dicttype eq{
<< exch{oforce_recursive exch oforce exch}forall >>}if}ifelse}bind def/knownoget{.knownget{
oforce dup//null eq{pop//false}{//true}ifelse}{//false}ifelse}bind def/F{.pdfcount 3 lt{f}{pop pop pop null}ifelse}bind def
/checkgeneration{Generations 2 index lget 1 sub 1 index eq{pop true}{QUIET not{Generations 2 index lget 0 eq{
(   **** Warning: reference to free object: )2 index =string cvs concatstrings( )concatstrings
exch =string cvs concatstrings( R\n)concatstrings}{(   **** Warning: wrong generation: )
2 index =string cvs concatstrings( )concatstrings
exch =string cvs concatstrings(, xref gen#: )concatstrings 1 index Generations
exch lget 1 sub =string cvs concatstrings(\n)concatstrings}ifelse
pdfformaterror}{pop}ifelse
true}ifelse}bind def/R{/resolveR cvx 3 packedarray cvx}bind def/objopdict mark
valueopdict{}forall/endobj dup cvx
.dicttomark readonly def/obj{PDFfile objopdict .pdfrun}bind def/endobj{3 1 roll
1 index resolved?{pop}if
checkgeneration{1 index dup gcheck exch type/dicttype eq and{PDFDEBUG{(%Local=>global: )print dup ==}if
GlobalObjects 1 index 3 index put
IsGlobal 1 index 1 put}if
Objects exch 2 index lput}{pop pop null}ifelse}bind def/resolveobjstreamopdict mark
valueopdict{}forall(%%EOF)cvn{exit}bind
.dicttomark readonly def/resolveobjectstream{PDFDEBUG{(%Resolving object stream: )print}if
0 resolveR
dup/First get
1 index/N get
2 index false resolvestream/ReusableStreamDecode filter
1 index array
2 index array
0 1 5 index 1 sub{2 index 1 index
5 index token pop put
1 index 1 index
5 index token pop put
pop}for
0 0
2 index{dup 4 1 roll
exch sub
.max
exch}forall
pop
.bigstring
3 index 6 index
setfileposition
0 1 6 index 2 sub{dup 4 index exch get
dup resolved?{(yyy)= pstack(yyy)= flush xxx
pop pop
1 add 2 index exch get
6 index add 6 index exch
setfileposition}{2 index 0
5 index 4 index 1 add get
6 index 5 index get
sub
getinterval
6 index exch readstring pop/ReusableStreamDecode filter
resolveobjstreamopdict .pdfrun
Objects exch 2 index exch lput
pop pop}ifelse}for
pop pop
2 index 1 sub get
dup resolved? not{exch
resolveobjstreamopdict .pdfrun
Objects exch 2 index exch lput}if
pop pop pop pop}bind def/resolveobjectstream{PDFDEBUG{(%Resolving object stream: )print}if
0 resolveR
dup/Type get/ObjStm ne{(   **** Incorrect Type in object stream dictionary.\n)pdfformaterror
/resolveobjectstream cvx/typecheck signalerror}if
dup/N get
1 index false resolvestream/ReusableStreamDecode filter
1 index array
0 1 4 index 1 sub{1 index 1 index
4 index token pop put
2 index token pop pop pop}for
1 index 4 index/First get
setfileposition
PDFDEBUG/PDFDEBUG false def
mark 4 -1 roll
count 5 index add/PDFObjectStkCount exch def
resolveobjstreamopdict .pdfrun
PDFObjectStkCount count ne{(   **** Incorrect object count in object stream.\n)pdfformaterror
/resolveobjectstream cvx/rangecheck signalerror}if
counttomark array astore
exch pop
exch/PDFDEBUG exch def
0 1 2 index length 1 sub{dup 3 index exch get
dup resolved?{pop pop}{PDFDEBUG{(%Resolving compressed object: [)print dup =only( 0])=}if
Objects exch 3 index
3 index get
PDFDEBUG{dup === flush}if
lput}ifelse
pop}for
pop pop pop pop}bind def/resolveopdict mark
valueopdict{}forall/endstream{endobj exit}bind/endobj{endobj exit}bind/obj{pop pop endobj exit}bind
.dicttomark readonly def/resolveR{PDFDEBUG{PDFSTEPcount 1 le{(%Resolving: )print 2 copy 2 array astore ==}if}if
1 index resolved?{exch pop exch pop}{PDFfile fileposition 3 1 roll
1 index Objects exch lget
3 1 roll checkgeneration{ObjectStream 1 index lget dup 0 eq{pop exch PDFoffset add PDFfile exch setfileposition
PDFfile token pop 2 copy ne{(   **** Unrecoverable error in xref!\n)pdfformaterror/resolveR cvx/rangecheck signalerror}
if pop PDFfile token pop
PDFfile token pop/obj ne{(   **** Unrecoverable error in xref!\n)pdfformaterror/resolveR cvx/rangecheck signalerror}if
pdf_run_resolve}{resolveobjectstream
resolved?{exch pop}{pop pop null}ifelse}ifelse}{pop pop null}ifelse
exch PDFfile exch setfileposition}ifelse}bind def/stream{dup/Length oget 0 eq{dup/Filter undef}if
dup/F known dup PDFsource PDFfile eq or{not{dup/File PDFfile put
PDFfile dup fileposition 1 sub setfileposition
PDFfile read pop
dup 13 eq{(   **** Warning: stream operator not terminated by valid EOL.\n)pdfformaterror
pop}{{10 eq{exit}if
PDFfile read pop}loop}ifelse
dup/FilePosition PDFfile fileposition put
PDFDEBUG{PDFSTEPcount 1 le{(%FilePosition: )print dup/FilePosition get ==}if}if}if
dup/Length oget
dup PDFfile bytesavailable lt{PDFfile fileposition
add PDFfile exch setfileposition}{pop}ifelse}{pop
dup/Length oget string PDFsource exch readstring
not{(   **** Warning: Unexpected EOF in stream!\n)pdfformaterror/stream cvx/rangecheck signalerror}if
1 index exch/File exch put}ifelse
PDFsource token_nofail not{null}if
dup/endobj eq{(   **** Warning: stream missing 'endstream'.\n)pdfformaterror
pop/endstream}if/endstream ne{(   **** Warning: stream Length incorrect.\n)pdfformaterror
dup/Length undef
cvx endobj exit}if
cvx}bind def/endstream{exit}bind def/unabbrevfilterdict mark/AHx/ASCIIHexDecode/A85/ASCII85Decode/CCF/CCITTFaxDecode
/DCT/DCTDecode/Fl/FlateDecode/LZW/LZWDecode/RL/RunLengthDecode
.dicttomark readonly def/filterparms{2 index exch knownoget{oforce_recursive
exch 2 index exch knownoget{oforce_recursive
exch dup type/nametype eq{1 array astore exch
dup type/arraytype ne{1 array astore}if exch}if}{//null exch
dup type/nametype eq{1 array astore}if}ifelse}{pop//null{}}ifelse}bind def/filtername{
//unabbrevfilterdict 1 index .knownget{exch pop}if
dup/Filter resourcestatus{pop pop}{Repaired exch(   **** ERROR: Unable to process )pdfformaterror
64 string cvs pdfformaterror( data. Page will be missing data.\n)pdfformaterror/Repaired exch store/.EOFDecode}ifelse}bind def
/applyfilters{2 index null eq{{filtername filter}}{{2 index 0 oget dup null eq{pop}{
exch filtername dup/JBIG2Decode eq{exch jbig2cachectx exch}if}ifelse filter
exch dup length 1 sub 1 exch getinterval exch}}ifelse forall exch pop}bind def/jbig2cachectx{dup/JBIG2Globals knownoget{
PDFfile fileposition exch
true resolvestream[{counttomark 1 add index 60000 string readstring not{exit}if}loop]exch pop 0 1 index{length add}forall
.bytestring exch 0 exch{3 copy putinterval length add}forall pop
.jbig2makeglobalctx
PDFfile 3 -1 roll setfileposition
1 index exch/.jbig2globalctx exch put}if}bind def/jpxparmfix{1 index/Filter .knownget{/JPXDecode eq{
1 index/ColorSpace knownoget{2 index/DecodeParms knownoget{/ColorSpace 3 -1 roll put}{1 dict
dup/ColorSpace 4 -1 roll put
2 index exch/DecodeParms exch put}ifelse}if}if}if}bind def/resolvestream{jpxparmfix
1 index/F knownoget{(r)file 3 -1 roll/FDecodeParms/FFilter filterparms
4 -1 roll exch
pdf_decrypt_stream
applyfilters}{exch
dup/Length knownoget{0 eq}{//false}ifelse{()0()/SubFileDecode filter}{dup/FilePosition .knownget{
1 index/File get exch setfileposition}if/DecodeParms/Filter filterparms
2 index/File get exch
dup length 0 eq{exch dup type/filetype eq 5 index or{3 index/Length knownoget not{0}if}{0}ifelse
4 index/IDFlag known{pop}{()/SubFileDecode filter}ifelse
exch
pdf_decrypt_stream
pop exch pop}{exch 3 index/Length knownoget{()/SubFileDecode filter}if exch
pdf_decrypt_stream
applyfilters}ifelse}ifelse}ifelse
exch pop exch pop}bind def/nameoget{exch/Names exch .treeget}bind def/numoget{exch/Nums exch .treeget}bind def/.treeget{
dup/Kids knownoget{exch pop .branchget}{exch get .leafget}ifelse}bind def/.branchget{dup length 0 eq{pop pop pop null}{
dup length -1 bitshift 2 copy oget
dup/Limits oget aload pop
6 index lt{pop pop
1 add 1 index length 1 index sub getinterval .branchget}{5 index gt{pop
0 exch getinterval .branchget}{exch pop exch pop .treeget}ifelse}ifelse}ifelse}bind def/.leafget{dup length 2 eq{
dup 0 get 2 index eq{1 oget}{pop null}ifelse
exch pop}{dup length -1 bitshift -2 and 2 copy oget
3 index gt{0 exch}{1 index length 1 index sub}ifelse
getinterval .leafget}ifelse}bind def
end
.setglobal
/.setlanguagelevel where{pop 2 .setlanguagelevel}if
.currentglobal true .setglobal/pdfdict where{pop}{/pdfdict 100 dict def}ifelse
GS_PDF_ProcSet begin
pdfdict begin/drawopdict 100 dict def/fnrdict mark
0{.resolvefn0}2{.resolvefn2}3{.resolvefn3}4{.resolvefn4}.dicttomark readonly def/.resolvefn0{dup length 1 add dict .copydict
dup/Size 2 copy knownoget{put}{pop pop}ifelse
dup/BitsPerSample 2 copy knownoget{put}{pop pop}ifelse
dup/Order 2 copy knownoget{put}{pop pop}ifelse
dup/Encode 2 copy knownoget{put}{pop pop}ifelse
dup/Decode 2 copy knownoget{put}{pop pop}ifelse
PDFfile fileposition exch
dup true resolvestream
1 index/Range get length 2 idiv 2 index/BitsPerSample get mul
2 index/Size get{mul}forall
7 add 8 idiv string
1 index exch readstring pop exch closefile
exch dup/DataSource 4 -1 roll put
exch PDFfile exch setfileposition}bdef/.resolvefn2{dup length dict .copydict
dup/C0 2 copy knownoget{put}{pop pop}ifelse
dup/C1 2 copy knownoget{put}{pop pop}ifelse
dup/N 2 copy knownoget{put}{pop pop}ifelse}bdef/.resolvefn3{dup length dict .copydict
dup/Bounds 2 copy knownoget{put}{pop pop}ifelse
dup/Encode 2 copy knownoget{put}{pop pop}ifelse
dup/Functions 2 copy oget mark exch dup{oforce .resolvefn}forall
counttomark -1 roll astore exch pop put}bdef/.resolvefn4{PDFfile fileposition exch
dup true resolvestream
exch dup length dict copy
dup/Function undef
exch dup token not{()/rangecheck cvx signalerror}if
exch token{/rangecheck cvx signalerror}if
.bind
1 index/Function 3 -1 roll put
exch PDFfile exch setfileposition}bdef/.resolvefn{dup length dict .copydict
dup/Domain 2 copy knownoget{put}{pop pop}ifelse
dup/Range 2 copy knownoget{put}{pop pop}ifelse
dup/FunctionType oget//fnrdict exch get exec}bdef/resolvefunction{.resolvefn
PDFDEBUG{pdfdict/PDFSTEPcount .knownget{1 le}{true}ifelse{(%Function: )print dup === flush}if}if}bdef/resolvefnproc{
resolvefunction .buildfunction}bdef/resolveidfnproc{dup/Identity eq{pop{}}{resolvefnproc}ifelse}bdef/resolvedefaultfnproc{
1 index/Default eq{exch pop}{pop resolveidfnproc}ifelse}bdef/shrdict mark/BBox{dup dup dup aload pop normrect_elems
5 -1 roll astore}bind/ColorSpace{resolvecolorspace}bind/Function{dup type/dicttype eq{resolvefunction}{
[exch{oforce resolvefunction}forall]}ifelse}bind
.dicttomark readonly def/resolveshading{dup/.shading_dict .knownget{exch pop
dup/ShadingType get 4 ge{dup/DataSource get 0 setfileposition}if}{dup
PDFfile fileposition exch
mark exch{oforce//shrdict 2 index .knownget{exec}if}forall .dicttomark
dup/ShadingType get 4 ge{dup dup true resolvestream/ReusableStreamDecode filter/DataSource exch put}if
exch PDFfile exch setfileposition
dup 3 1 roll/.shading_dict exch put}ifelse}bdef/resolvesh{Page/Shading rget{resolveshading}{null}ifelse}bdef/spotfunctions mark
/Round{abs exch abs 2 copy add 1 le{dup mul exch dup mul add 1 exch sub}{1 sub dup mul exch 1 sub dup mul add 1 sub}ifelse}
/Diamond{abs exch abs 2 copy add .75 le{dup mul exch dup mul add 1 exch sub}{2 copy add 1.23 le{.85 mul add 1 exch sub}{
1 sub dup mul exch 1 sub dup mul add 1 sub}ifelse}ifelse}/Ellipse{abs exch abs 2 copy 3 mul exch 4 mul add 3 sub dup 0 lt{
pop dup mul exch .75 div dup mul add 4 div 1 exch sub}{dup 1 gt{pop 1 exch sub dup mul exch 1 exch sub
.75 div dup mul add 4 div 1 sub}{.5 exch sub exch pop exch pop}ifelse}ifelse}
/EllipseA{dup mul .9 mul exch dup mul add 1 exch sub}/InvertedEllipseA{dup mul .9 mul exch dup mul add 1 sub}
/EllipseB{dup 5 mul 8 div mul exch dup mul exch add sqrt 1 exch sub}/EllipseC{dup mul .9 mul exch dup mul add 1 exch sub}
/InvertedEllipseC{dup mul .9 mul exch dup mul add 1 sub}/Line{exch pop abs neg}/LineX{pop}/LineY{exch pop}
/Square{abs exch abs 2 copy lt{exch}if pop neg}/Cross{abs exch abs 2 copy gt{exch}if pop neg}
/Rhomboid{abs exch abs 0.9 mul add 2 div}/DoubleDot{2{360 mul sin 2 div exch}repeat add}
/InvertedDoubleDot{2{360 mul sin 2 div exch}repeat add neg}/SimpleDot{dup mul exch dup mul add 1 exch sub}
/InvertedSimpleDot{dup mul exch dup mul add 1 sub}/CosineDot{180 mul cos exch 180 mul cos add 2 div}
/Double{exch 2 div exch 2{360 mul sin 2 div exch}repeat add}/InvertedDouble{
exch 2 div exch 2{360 mul sin 2 div exch}repeat add neg}.dicttomark readonly def/htrdict mark
1{.resolveht1}5{.resolveht5}.dicttomark readonly def/.resolveht1{mark exch{oforce
1 index/SpotFunction eq{dup type/nametype eq{//spotfunctions exch get}{resolvefnproc}ifelse}{1 index/TransferFunction eq{
resolveidfnproc}if}ifelse}forall .dicttomark}bdef/.resolveht5{mark exch{oforce dup type/dicttype eq{resolvehalftone}if
}forall .dicttomark}bdef/resolvehalftone{dup/HalftoneType get
dup//htrdict exch .knownget{exch pop exec}{(\n\n   **** Unsupported HalftoneType )pdfformaterror
=string cvs pdfformaterror(. ***\n\n)pdfformaterror/resolvehalftone cvx/unregistered signalerror}ifelse}bdef
/cmmatrix matrix def
drawopdict begin/q{q}def/Q{Q}def/cm{//cmmatrix astore
.getpath
exch concat
newpath{exec}forall
currentdict/TextSaveMatrix .knownget{//cmmatrix exch dup concatmatrix pop}if}bdef/i{1 .min setflat}bdef/J/setlinecap load def
/d/setdash load def/j/setlinejoin load def/w/setlinewidth load def/M{1 .max setmiterlimit}bdef/gs{gs}def
end/gsbg{/BGDefault load resolvedefaultfnproc setblackgeneration}bdef/gsucr{
/UCRDefault load resolvedefaultfnproc setundercolorremoval}bdef/gstr{dup type/arraytype eq{
{oforce/TRDefault load resolvedefaultfnproc}forall
setcolortransfer}{/TRDefault load resolvedefaultfnproc settransfer}ifelse}bdef/gsparamdict mark/SA{setstrokeadjust}
/OP{1 index/op known not{dup op}if OP}/BG{1 index/BG2 known{pop}{gsbg}ifelse}/UCR{1 index/UCR2 known{pop}{gsucr}ifelse}
/TR{1 index/TR2 known{pop}{gstr}ifelse}/HT{dup/Default eq{pop .setdefaulthalftone}{resolvehalftone sethalftone}ifelse
dup/TR2 .knownget{dup/Default eq{oforce gsparamdict/TR2 get exec}{pop}ifelse}{dup/TR .knownget{
/dup/Default eq{oforce gsparamdict/TR get exec}{pop}ifelse}if}ifelse}/HTP{
/sethalftonephase where{pop aload pop sethalftonephase}{pop}ifelse}/Font{aload pop Tf}/LW{setlinewidth}/LC{setlinecap}
/LJ{setlinejoin}/ML{1 .max setmiterlimit}/D{aload pop setdash}/RI{ri}/op{op}/OPM{OPM}/BG2{gsbg}/UCR2{gsucr}/TR2{gstr}
/FL{1 .min setflat}/SM{/setsmoothness where{pop setsmoothness}{pop}ifelse}/ca{ca}/CA{CA}/SMask{gssmask}/AIS{AIS}/BM{BM}/TK{TK}
.dicttomark readonly def/gs{Page/ExtGState rget{dup{oforce exch gsparamdict exch .knownget{exec}{pop}ifelse}forall pop}if}bdef
/gssmask{dup/None eq PDFusingtransparency not or{pop null}{mark exch
dup/S oget/Subtype exch 3 2 roll
dup/BC knownoget{dup/Background exch 4 2 roll
gsave
1 index/G oget/Group oget/CS knownoget{csresolve dup setgcolorspace csput}if
aload pop setcolor[currentgray]grestore/GrayBackground exch 3 2 roll}if
dup/TR knownoget{resolveidfnproc/TransferFunction exch 3 2 roll}if
dup/G oget dup/BBox oget/BBox exch 4 2 roll/.execmaskgroup cvx 2 packedarray cvx/Draw exch 3 2 roll
pop .dicttomark}ifelse SMask}bdef/.execmaskgroup{currentcolorspace 4 1 roll
PDFfile fileposition 4 1 roll
dup/Group oget/CS knownoget{csresolve dup setgcolorspace csput}if
exch dup/BBox get aload pop .begintransparencymaskgroup{dup/Resources knownoget{oforce}{0 dict}ifelse
exch false resolvestream
.execgroup .endtransparencymask}stopped{.discardtransparencymask stop}if
PDFfile exch setfileposition
setcolorspace}bdef/.execgroup{gsave//nodict begin
null SMask
1 .setopacityalpha 1 .setshapealpha
0 .inittransparencymask 1 .inittransparencymask/Compatible .setblendmode
pdfopdict .pdfruncontext
end grestore}bdef/.beginformgroup{exch mark exch
dup/CS knownoget{csresolve setgcolorspace}if
dup/I knownoget{/Isolated exch 3 2 roll}if
dup/K knownoget{/Knockout exch 3 2 roll}if
pop .dicttomark
exch aload pop
.begintransparencygroup}bdef/.paintgroupform{dup/Group oget exch/BBox oget
.beginformgroup{.execgroup}stopped{.discardtransparencygroup stop}if .endtransparencygroup}bdef/makesoftmaskimage{
PDFfile fileposition exch
dup/Matte knownoget{/Matte exch def}if
dup length dict makeimagedict pop/DataSource DataSource mark/Intent 1/AsyncRead true
.dicttomark .reusablestreamdecode def
PDFfile exch setfileposition
currentdict end currentdict end
5 dict begin/ImageType 103 def/DataDict exch def
dup/InterleaveType 3 put
DataDict/Matte knownoget{/Matte exch def}if
AlphaIsShape{/ShapeMaskDict}{/OpacityMaskDict}ifelse exch def/ColorSpace DataDict/ColorSpace get def}bdef/01_1[0 1]readonly def
/01_3[0 1 0 1 0 1]readonly def/01_4[0 1 0 1 0 1 0 1]readonly def/csncompdict mark/DeviceGray{pop 1}/DeviceRGB{pop 3}
/DeviceCMYK{pop 4}/CIEBasedA{pop 1}/CIEBasedABC{pop 3}/ICCBased{1 oget/N oget}/Separation{pop 1}/DeviceN{1 oget length}
.dicttomark readonly def/csrdict mark/DeviceGray{}/DeviceRGB{}/DeviceCMYK{}/CalGray{1 oget 6 dict begin
dup/Gamma knownoget{/exp load 2 packedarray cvx/DecodeA exch def}if
dup/BlackPoint knownoget{/BlackPoint exch def}if
dup/WhitePoint knownoget{dup/WhitePoint exch def
dup/MatrixA exch def/RangeLMN[3 2 roll{0 exch}forall]def}if/PDFColorSpace exch def[/CIEBasedA currentdict end]}/CalRGB{
1 oget 6 dict begin
dup/Gamma knownoget{[exch{/exp load 2 packedarray cvx}forall]/DecodeABC exch def}if
dup/Matrix knownoget{/MatrixABC exch def}if
dup/BlackPoint knownoget{/BlackPoint exch def}if
dup/WhitePoint knownoget{/WhitePoint exch def}if/PDFColorSpace exch def[/CIEBasedABC currentdict end]}/CalCMYK{pop/DeviceCMYK}
/Lab{1 oget 6 dict begin
dup/Range knownoget not{[-100 100 -100 100]}if[0 100 null null null null]dup 2 4 -1 roll putinterval/RangeABC exch def
/DecodeABC[{16 add 116 div}bind{500 div}bind{200 div}bind]def/MatrixABC[1 1 1 1 0 0 0 0 -1]def
dup/BlackPoint knownoget{/BlackPoint exch def}if
dup/WhitePoint knownoget{/WhitePoint exch def}{(   **** Warning: Lab colorspace is missing WhitePoint.\n)pdfformaterror
/WhitePoint[0.9505 1 1.089]def}ifelse{dup 6 29 div ge{dup dup mul mul}{4 29 div sub 108 841 div mul}ifelse}/DecodeLMN[
[3 index aload pop WhitePoint 0 get/mul .systemvar]cvx bind[4 index aload pop WhitePoint 1 get/mul .systemvar]cvx bind
[5 index aload pop WhitePoint 2 get/mul .systemvar]cvx bind]def pop/PDFColorSpace exch def[/CIEBasedABC currentdict end]}
/ICCBased{dup 1 get type/dicttype ne{PDFfile fileposition exch
dup dup 1 oget
mark exch{oforce}forall .dicttomark
dup dup true resolvestream/ReusableStreamDecode filter/DataSource exch put
1 exch put
exch PDFfile exch setfileposition
dup 1 get
dup/Alternate .knownget{oforce resolvecolorspace/Alternate exch put}{pop}ifelse}if}bind/Separation{
aload pop exch oforce resolvecolorspace
exch oforce resolveidfnproc
4 array astore}/DeviceN{[exch aload pop]dup dup 1 oget[exch{oforce}forall]1 exch put
dup dup 2 oget resolvecolorspace
2 exch put
dup dup 3 oget resolvefnproc
3 exch put
dup length 4 gt{dup dup 4 oget
dup/Colorants knownoget{exch pop
<< exch
<< exch{oforce resolvecolorspace}forall >>/Colorants exch >>}if
4 exch put}if}/Indexed{aload pop 3 -1 roll oforce resolvecolorspace
dup dup type/arraytype eq{0 get}if/CIEBasedABC eq{dup 1 get/DecodeLMN known{1 get dup length dict copy
begin/DecodeABC[0 2 4{RangeABC 1 index 1 add get RangeABC 2 index get sub/mul load
RangeABC 3 index get/add load
DecodeABC 6 -1 roll 2 idiv get[6 1 roll aload pop]cvx}for]def/RangeABC//01_3 def
currentdict end/CIEBasedABC exch 2 array astore}if}if
3 1 roll
oforce dup type/stringtype ne{PDFfile fileposition 5 1 roll true resolvestream
1 index 1 add
3 index
dup dup type/arraytype eq{0 get}if//csncompdict exch get exec mul
string dup 3 1 roll readstring pop
length 1 index length lt{(   **** Warning: Short look-up table in the Indexed color space was padded with 0's.\n)pdfformaterror
}if
5 -1 roll PDFfile exch setfileposition}if 4 array astore
dup 1 get
dup type/arraytype eq{dup length 2 ge{dup 1 get type/dicttype eq{dup 1 get/PDFColorSpace known{
dup 1 get/PDFColorSpace 3 index put}if}if}if}if pop}/Pattern{dup type/nametype ne{dup length 1 gt{1 oget resolvecolorspace
/Pattern exch 2 array astore}if}if}.dicttomark readonly def/cssubst{dup resolvecolorspace
dup 1 index ne{exch pop true}{pop pop false}ifelse}bdef/csnames mark/DeviceGray dup/DeviceRGB dup/DeviceCMYK dup/Pattern dup
.dicttomark readonly def/csresolve{dup type/nametype ne{
(\n   **** Warning: CS/cs (setcolorspace) operand not a name: )pdfformaterror
dup stderrfile dup 3 -1 roll write==only flushfile( ****\n)pdfformaterror
dup type/arraytype eq{resolvecolorspace}if}{dup Page/ColorSpace rget{exch pop resolvecolorspace}{
//csnames 1 index known not{/undefined cvx signalerror}if}ifelse}ifelse}bdef/resolvecolorspace{
dup dup type/arraytype eq{0 get}if//csrdict exch .knownget{exec dup type/nametype ne{dup length 1 eq{0 get}if}if}{
dup type/nametype eq{csresolve}{csset exch pop}ifelse}ifelse}bdef/scresolve{dup type/nametype eq
{Page/Pattern rget{resolvepattern}{null}ifelse}if
dup type/dicttype eq{dup/PaintType knownoget{2 eq}{false}ifelse}{.pdfcount 1 gt}ifelse}bdef/.pdfpaintproc{
PDFDEBUG{pdfdict/PDFSTEPcount .knownget{1 le}{true}ifelse{(%Begin PaintProc)print dup === flush}if}if
PDFfile fileposition 3 1 roll
q//null sc1//null SC1
pdfemptycount/pdfemptycount count 3 sub def 3 1 roll
countdictstack 3 1 roll
exch//false resolvestream pdfopdict .pdfruncontext
countdictstack exch sub dup 0 gt{(   **** Warning: Pattern stream has imbalanced q/Q operators (too many q's)\n)pdfformaterror
{Q}repeat}{pop}ifelse/pdfemptycount exch def
Q
PDFDEBUG{pdfdict/PDFSTEPcount .knownget{1 le}{//true}ifelse{(%End PaintProc)print dup === flush}if}if
PDFfile exch setfileposition}bdef/resolvepattern{dup length dict copy
dup/FilePosition .knownget{1 index/File get dup fileposition 3 1 roll
dup 3 -1 roll setfileposition
dup 3 index/Length oget
dup 65535 le{dup 0 eq{pop pop()}{string readstring pop}ifelse}{()/SubFileDecode filter/ReusableStreamDecode filter}ifelse
3 1 roll exch setfileposition
1 index/File 3 -1 roll put
dup/FilePosition undef}if
dup/Shading knownoget{resolveshading 1 index/Shading 3 -1 roll put}if
dup/PaintProc[2 index/Resources knownoget{oforce}{0 dict}ifelse/.pdfpaintproc cvx]cvx put
PDFDEBUG{pdfdict/PDFSTEPcount .knownget{1 le}{true}ifelse{(%Pattern: )print dup === flush}if}if}bdef
/ignore_color_op(   **** Warning: Ignoring a color operation in a cached context.\n)readonly def
drawopdict begin/g{.incachedevice{pop//ignore_color_op pdfformaterror}{/DeviceGray cssubst{cs sc1}{g}ifelse}ifelse}bdef
/rg{.incachedevice{pop pop pop//ignore_color_op pdfformaterror}{/DeviceRGB cssubst{cs sc*}{rg}ifelse}ifelse}bdef
/k{.incachedevice{pop pop pop pop//ignore_color_op pdfformaterror}{k}ifelse}bdef/cs{.incachedevice{
pop//ignore_color_op pdfformaterror}{csresolve cs}ifelse}bdef/sc{.incachedevice{
.pdfcount{pop}repeat//ignore_color_op pdfformaterror}{scresolve{sc*}{sc1}ifelse}ifelse}bdef/scn/sc load def/G{.incachedevice{
pop//ignore_color_op pdfformaterror}{/DeviceGray cssubst{CS SC1}{G}ifelse}ifelse}bdef/RG{.incachedevice{
pop pop pop//ignore_color_op pdfformaterror}{/DeviceRGB cssubst{CS SC*}{RG}ifelse}ifelse}bdef/K{.incachedevice{
pop pop pop pop//ignore_color_op pdfformaterror}{K}ifelse}bdef/CS{.incachedevice{pop//ignore_color_op pdfformaterror}{
csresolve CS}ifelse}bdef/ri{.incachedevice{pop//ignore_color_op pdfformaterror}{ri}ifelse}bdef/SC{.incachedevice{
.pdfcount{pop}repeat//ignore_color_op pdfformaterror}{scresolve{SC*}{SC1}ifelse}ifelse}bdef/SCN/SC load def
end
currentdict/ignore_color_op undef
drawopdict begin/m/moveto load def/l/lineto load def/c/curveto load def/v{currentpoint 6 2 roll curveto}def
/y{2 copy curveto}def/re{4 2 roll moveto exch dup 0 rlineto 0 3 -1 roll rlineto neg 0 rlineto
closepath}def/h/closepath load def/n{n}def/S{S}def/s{s}def/f{f}def/f*{f*}def/B{B}def/b{b}def/B*{B*}def/b*{b*}def/W{W}def
/W*{W*}def/sh{setfillstate resolvesh
gsave 0 .setoverprintmode
dup/.shading .knownget{exch
pop}{dup
.buildshading
dup 3 1 roll/.shading exch put}ifelse
.shfill grestore}def
end/xobjectprocs mark/Image{DoImage}/Form{DoForm}/PS{DoPS}.dicttomark readonly def/defaultdecodedict mark
/DeviceGray{pop//01_1}bind/DeviceRGB{pop//01_3}bind/DeviceCMYK{pop//01_4}bind
/CIEBasedA{1 get/RangeA knownoget not{//01_1}if}bind/CIEBasedABC{1 get/RangeABC knownoget not{//01_3}if}bind/ICCBased{
1 oget dup/Range knownoget{exch pop}{/N get[exch{0 1}repeat]readonly}ifelse}bind/Separation{pop//01_1}bind/DeviceN{
1 oget length[exch{0 1}repeat]readonly}bind/Indexed{pop[0 1 BitsPerComponent bitshift 1 sub]}bind
.dicttomark readonly def/checkaltimage{Printed{dup/Alternates knownoget{{dup/DefaultForPrinting knownoget{{
/Image oget exch pop exit}{pop}ifelse}{pop}ifelse}forall}if}if}bdef/makeimagedict{begin/Width 2 copy oget def
/Height 2 copy oget def/BitsPerComponent 2 copy knownoget{def}{pop}ifelse/Interpolate 2 copy knownoget{def}{pop}ifelse
makeimagekeys}bdef/makeimagekeys{/ImageType 1 def/ImageMatrix Width 0 0
Height dup 0 eq{pop 1}if neg 0 1 index neg
6 array astore def
dup/ImageMask knownoget dup{and}if{/Decode 2 copy knownoget{0 2 getinterval}{//01_1}ifelse def
/BitsPerComponent 2 copy known{pop}{1 def}ifelse
true}{dup/ColorSpace oget resolvecolorspace/ColorSpace exch def/Decode 2 copy knownoget not{ColorSpace//defaultdecodedict
ColorSpace dup type/arraytype eq{0 get}if get exec}if def
false}ifelse
exch false resolvestream/DataSource exch def}bdef/DoImage{checkaltimage dup length 6 add dict
1 index/SMask knownoget{1 index exch/SMask exch put}if
1 index/Mask knownoget{1 index exch/Mask exch put}if
makeimagedict doimagesmask}bdef/makemaskimage{dup type/arraytype eq{/ImageType 4 def//false 1 index{type/integertype ne or
}forall{(\n   **** Warning: Some elements of Mask array are not integers.\n)pdfformaterror[exch{0.5 add cvi}forall]}if
2 BitsPerComponent exp cvi 1 sub//false 2 index{dup 0 lt exch 3 index gt or or}forall exch pop{
(\n   **** Warning: Some elements of Mask array are out of range.\n)pdfformaterror
pop/ImageType 1 def}{/MaskColor exch def}ifelse}{PDFfile fileposition exch
dup length dict makeimagedict pop/DataSource DataSource mark/Intent 1/AsyncRead true
.dicttomark .reusablestreamdecode def
PDFfile exch setfileposition
currentdict end currentdict end
5 dict begin/ImageType 3 def/InterleaveType 3 def/DataDict exch def/MaskDict exch def/ColorSpace DataDict/ColorSpace get def
}ifelse}bdef/doimagesmask{PDFusingtransparency{currentdict/SMask knownoget}{false}ifelse{.begintransparencymaskimage
PDFfile fileposition exch
gsave//nodict begin
null/SoftMask gput
1 .setopacityalpha 1 .setshapealpha
0 .inittransparencymask 1 .inittransparencymask/Compatible .setblendmode
DoImage
end grestore
PDFfile exch setfileposition
0 .endtransparencymask
<</Subtype/Group/Isolated true/.image_with_SMask true
>>0 0 1 1 .begintransparencygroup
doimage
.endtransparencygroup}{doimage}ifelse}bdef/doimage{DataSource exch
PDFusingtransparency{currentdict/SMask knownoget}{false}ifelse{makesoftmaskimage}{currentdict/Mask knownoget{makemaskimage}if
}ifelse{currentdict end setfillstate{imagemask}}{ColorSpace setgcolorspace currentdict end setfillblend{image}}ifelse
stopped{dup type/dicttype eq{pop}if
$error/errorname get dup/ioerror eq{pop(\n   **** Warning: File has insufficient data for an image.\n)pdfformaterror}{
(\n   **** Warning: File encountered ')exch 40 string cvs concatstrings(' error while processing an image.\n)concatstrings
pdfformaterror}ifelse}if
dup dup PDFfile eq exch PDFsource eq or{pop}{closefile}ifelse}bdef/.paintform{
3 -1 roll dup/Group known PDFusingtransparency and{.paintgroupform}{pop pdfopdict .pdfruncontext}ifelse}bdef/DoForm{begin<<
currentdict/FormType known not{/FormType 1}if
currentdict/Matrix known not{/Matrix{1 0 0 1 0 0}cvlit}if
currentdict end{oforce}forall
>>
dup[2 index/Resources knownoget{oforce}{0 dict}ifelse
3 index false/resolvestream cvx/.paintform cvx]cvx/PaintProc exch put
pdfemptycount exch/pdfemptycount where pop count 2 sub/pdfemptycount exch put
q execform Q/pdfemptycount where pop exch/pdfemptycount exch put}bdef/_dops_save 1 array def/DoPS{DOPS{//_dops_save 0 save put
true resolvestream cvx exec//_dops_save 0 get restore}{pop}ifelse}bdef
currentdict/_dops_save undef
drawopdict begin/Do{setfillblend
PDFfile fileposition exch
dup Page/XObject rget{exch pop dup/Subtype get xobjectprocs exch get
3 -1 roll 2 .execn}{(   **** Undefined XObject resource: )exch =string cvs concatstrings(\n)concatstrings
pdfformaterror}ifelse
PDFfile exch setfileposition}bdef
end/unabbrevkeydict mark/BPC/BitsPerComponent/CS/ColorSpace/D/Decode/DP/DecodeParms
/F/Filter/H/Height/I/Interpolate/IM/ImageMask/W/Width
.dicttomark readonly def/unabbrevvaluedict mark/AHx/ASCIIHexDecode/A85/ASCII85Decode/CC/CalCMYK
/CCF/CCITTFaxDecode/CG/CalGray/CR/CalRGB/DCT/DCTDecode/CMYK/DeviceCMYK/Fl/FlateDecode/G/DeviceGray/RGB/DeviceRGB
/I/Indexed/LZW/LZWDecode/RL/RunLengthDecode
.dicttomark readonly def/unabbrevtypedict mark/nametype{//unabbrevvaluedict 1 index .knownget{exch pop}if}/arraytype{
dup 0 1 2 index length 1 sub{2 copy get unabbrevvalue put dup}for pop}.dicttomark readonly def/unabbrevvalue{
oforce//unabbrevtypedict 1 index type .knownget{exec}if}bdef
drawopdict begin/BI{mark}bdef/ID{counttomark 2 idiv dup 7 add dict begin{exch//unabbrevkeydict 1 index .knownget{exch pop}if
exch unabbrevvalue def}repeat pop/IDFlag true def/File PDFsource def
currentdict makeimagekeys doimage
0{PDFsource read not{//true exit}if
dup 10 eq 1 index 13 eq or{pop PDFsource token pop/EI ne exit}if
exch 69 eq 1 index 73 eq and{//false exit}if}loop
exch pop{/ID cvx/syntaxerror signalerror}if}bdef
end
drawopdict begin/BT{BT}def/ET{ET}def/Tc{Tc}def/TL{TL}def/Tr{Tr}def/Ts{Ts}def/Tw{Tw}def/Tz{Tz}def/Td{Td}def/TD{TD}def/Tm{Tm}def
/T*{T*}def/Tj{Tj}def/'{'}def/"{"}def/TJ{TJ}def/Tform{Tform}def
end/annotrect{/Rect get aload pop
exch 3 index sub dup 0 lt{dup 5 -1 roll add 4 1 roll neg}if
exch 2 index sub dup 0 lt{dup 4 -1 roll add 3 1 roll neg}if}bdef/annotsetcolor{
/C knownoget{aload pop setrgbcolor}{0 setgray}ifelse}bdef/strokeborder{1 index 0 ne{gsave
2 index annotsetcolor
0 setdash dup setlinewidth
exch annotrect
2{4 index sub 4 1 roll}repeat
2{4 index 0.5 mul add 4 1 roll}repeat
rectstroke pop
grestore}{pop pop pop}ifelse}bdef/drawborder{gsave
dup/BS known 1 index/Border known or{dup/BS knownoget{dup type/dicttype ne}{dup/Border oget
dup type/arraytype ne}ifelse{(   **** Warning: Wrong type of annotation border object.\n)pdfformaterror}if
dup type/dicttype eq{dup/W knownoget not{1}if//systemdict/NoUserUnit .knownget not{false}if not
//systemdict/PDFFitPage known not and{Page/UserUnit knownoget{div}if}if[]2 index/S knownoget{
/D eq{2 index/D knownoget not{[3]}if exch pop}if}if 3 -1 roll pop strokeborder}{dup 2 get
exch dup length 3 gt{3 get}{pop[]}ifelse
strokeborder}ifelse}{1[]strokeborder}ifelse
grestore}bdef/annotvisible{/F knownoget not{0}if
dup 2 and 0 eq
exch dup 4 and 0 ne Printed and
exch 32 and 0 eq Printed not and
or
and}bdef/drawwidget{dup/AP knownoget{dup/N known not{
(   **** Appearance dictionary (AP) lacks the mandatory normal (N) appearance.\n)pdfformaterror}if
false[/N/R/D]{dup 3 index exch known{exch pop true exit}if
pop}forall
dup{pop
oget
dup/Length known 1 index/File known or{true}{1 index/AS knownoget not{{exch pop oforce exit}forall true}{knownoget}ifelse
}ifelse}{exch pop}ifelse{q graphicsbeginpage textbeginpage
1 index annotrect pop pop translate
2 index dup scale
DoForm Q}if}{dup/FT knownoget{/Tx eq{dup/DA known 1 index/V known and{dup/DA oget
q graphicsbeginpage textbeginpage
1 index annotrect pop pop translate
2 index dup scale
cvx exec
dup/V oget
0 0 moveto dup false charpath pathbbox newpath 3 -1 roll
sub abs 3 1 roll sub abs
3 index annotrect 4 2 roll pop pop
6 index mul exch 6 index mul
3 -1 roll
5 index/Q knownoget not{0}if
dup 0 eq{pop pop pop 0}{1 eq{2 div exch 2 div exch sub}{sub}ifelse}ifelse
3 1 roll 2 div exch 2 div sub abs
moveto show
Q}if}if}if}ifelse
pop pop}bdef/calcstampscale{dup/Rect known{dup annotrect 4 -2 roll pop pop
3 -1 roll/AP knownoget{/N knownoget{dup/Matrix knownoget{4 -2 roll 3 -1 roll dtransform 3 -1 roll}if/BBox knownoget{exch pop
aload pop pop exch pop sub
dup 0 eq{(   **** Warning: /BBox has zero width which is not allowed.\n)pdfformaterror
pop pop 1 1}if
div
dup 0 lt{neg}if}{pop pop 1}ifelse}{pop pop 1}ifelse}{pop pop 1}ifelse}{
(   **** Warning: /Annot dict is missing required /Rect entry.\n)pdfformaterror
pop 1}ifelse}bdef/drawlink{dup drawborder dup calcstampscale exch drawwidget}bdef/drawannottypes mark/Link{drawlink}bind
.dicttomark readonly def/drawannot{dup annotvisible{gsave
dup dup/Subtype knownoget{//drawannottypes exch .knownget{exec}{dup calcstampscale exch drawwidget}ifelse}{pop
(   **** Warning: /Annot dict without required /Subtype entry is ignored.\n)pdfformaterror}ifelse
grestore}if pop}bdef
currentdict/drawannottypes undef/annot_oget{1 index/Kids knownoget{0 oget exch oget exch pop}{oget}ifelse}bdef
/draw_terminal_field_dict 4 dict begin/Btn{1 index/Tf pget not{0}if
dup 16#20000 and 0 ne{pop
dup/AP known{dup 1 exch drawwidget}{(Push button without appearance stream is not yet implemented)=}ifelse}{16#10000 and 0 ne{
dup/AP known{1 index/Kids oget{1 exch drawwidget}forall}{(Radio button without appearance stream is not yet implemented)=
}ifelse}{dup/AP known{dup 1 exch drawwidget}{(CkeckBox without appearance stream is not yet implemented)=}ifelse}ifelse}ifelse
}bdef/Tx{dup/AP known{dup 1 exch drawwidget}{2 index/NeedAppearances knownoget not{//false}if{
dup/AP<</N 10 dict dup cvx begin >>put/Subtype/Form def
/BBox[0 0 4 index/Rect oget{oforce}forall 3 -1 roll sub abs 3 1 roll sub abs exch]def
/Resources 3 index/DR pget not{0 dict}if def/File 1000 string dup 3 1 roll def/Length 0 def/NullEncode filter
dup(BT )writestring
2 index/DA pget not{()}if[exch{token{dup/Tf eq{2 index 0 eq{/BBox load 3 get
0.75 mul
4 -1 roll pop 3 1 roll}if}if
exch}{exit}ifelse}loop]{1 index exch write==}forall
dup 3 index/MaxLen pget not{0}if write=
dup 3 index/V pget not{()}if write==
dup 3 index/Ff pget not{0}if write=
dup 3 index/Q pget not{0}if write=
dup(Tform ET)write=
end
closefile
dup 1 exch drawwidget}if}ifelse}bdef/Ch{(Ch is not yet implemened)==}bdef/Sig{(Sig is not yet implemened )==}bdef
currentdict end def/draw_terminal_field{dup/Kids knownoget{0 oget}{dup}ifelse
dup/P knownoget{/Page load eq{//draw_terminal_field_dict 2 index/FT pget not{0}if .knownget{exec}if}if}if
pop pop}bdef/draw_form_field{dup/Kids knownoget{dup 0 oget/Parent knownoget{pop
exch pop{oforce draw_form_field}forall}{pop draw_terminal_field}ifelse}{draw_terminal_field}ifelse}bdef/draw_acro_form{
dup/Fields knownoget{{oforce draw_form_field}forall}if
pop}bdef
currentdict/draw_terminal_field_dict undef
end
end
.setglobal
/.setlanguagelevel where{pop 2 .setlanguagelevel}if
.currentglobal true .setglobal/pdfdict where{pop}{/pdfdict 100 dict def}ifelse
GS_PDF_ProcSet begin
pdfdict begin/.notdefEncoding 256{/.notdef}repeat 256 packedarray def/updateencoding{exch dup null eq{pop .notdefEncoding}if
0 0 3 index{dup type/nametype ne{exch pop oforce}{pop 1 add}ifelse
2 copy lt{exch pop dup}if}forall
pop 1 index length .max array dup 0 4 -1 roll putinterval
exch 0 exch{dup type/nametype ne{exch pop oforce}{3 copy put pop 1 add}ifelse}forall pop}bdef/getencoding{/Encoding knownoget
{dup type/nametype eq{dup dup dup/MacRomanEncoding eq
exch/MacExpertEncoding eq or
exch/WinAnsiEncoding eq or{exch pop findencoding}{pop}ifelse}{dup type/arraytype eq{exch pop
(   **** Warning: Encoding is an array, not name or dictionary.\n)pdfformaterror}{dup/BaseEncoding knownoget{dup/ eq{pop
(   **** Warning: Ignoring bad BaseEncoding name.\n)pdfformaterror}{findencoding 3 -1 roll pop exch}ifelse}if
/Differences knownoget{updateencoding}if}ifelse}ifelse}{(   **** Warning: Encoding not present.\n)pdfformaterror}ifelse}bdef
/checkGlyphNames2Unicode{PDFDEBUG{dup/FontInfo .knownget{/GlyphNames2Unicode .knownget{(Has GlyphNames2Unicode)=
pop}if}if}if
pop}bind def/adjustfont{getfontencoding
3 copy .processToUnicode
getfontmetrics 5 -1 roll pop .updatefont{dup/FontName get exch definefont}if}bind def/getfontencoding{
//systemdict/IgnoreTTEncoding .knownget not{//false}if{1 index/Subtype get/TrueType eq}{//false}ifelse{//null}{
1 index/Encoding known{dup/Encoding knownoget{2 index getencoding}{//null}ifelse}{//null}ifelse}ifelse}bdef/match_in_diff
{false 4 1 roll 0 4 -1 roll{exch 1 index type/nametype ne{pop}{exch 2 index eq{dup 3 index eq{true 5 1 roll
pop exit}if}if
1 add}ifelse}forall
pop pop pop}bdef/unique_name{.namestring
0 1 65535{5 string cvs(~GS~)exch concatstrings
1 index exch
concatstrings
dup
3 index exch
known not{exch pop exit}if
pop}for
exch pop cvn}bdef/getfontmetrics{2 index/Widths known{dup//null eq{pop dup/Encoding get}if
7 dict begin
dup length dict/Metrics exch def/Encoding exch def/GlyphMap//null def
exch
dup/Widths oget/Widths exch def
0.001 2 index/FontMatrix get 0 get
dup 0 eq{pop
2 index/FontMatrix get 1 get
dup 0 eq{pop 1}if}if
div/FirstChar 2 index/FirstChar oget def/LastChar 2 index/LastChar oget def
Encoding length LastChar le{(   **** Warning: Font Encoding array size is smaller than character range.\n)pdfformaterror}if
1 index/FontDescriptor knownoget{/MissingWidth knownoget not{0}if}{1000}ifelse/MissingWidth exch def
Widths length LastChar FirstChar sub le{(   **** Warning: Font Widths array size is smaller than character range.\n)
pdfformaterror/Widths[Widths aload length LastChar FirstChar sub exch sub MissingWidth exch{dup}repeat]def}if
FirstChar
0 Encoding{1 index FirstChar lt{MissingWidth}{1 index LastChar gt{MissingWidth}{Widths 2 index FirstChar sub get}ifelse}ifelse
4 index mul{1 index//null eq{exit}if
Metrics 2 index .knownget{1 index ne}{//false}ifelse{GlyphMap//null eq{/Encoding Encoding dup length array copy def
/GlyphMap 4 dict def}if//true
GlyphMap{4 index eq{dup Metrics exch get
3 index eq{4 3 roll pop
3 1 roll pop
Encoding 3 index 3 index put//false
exit}{pop}ifelse}{pop}ifelse}forall{Metrics 2 index//unique_name exec
Encoding 4 index 2 index put
GlyphMap 1 index 5 -1 roll put
exch}if}if
2 copy Metrics 3 1 roll put
exit}loop
pop pop
1 add}forall pop pop pop
exch Encoding Metrics GlyphMap end}{//null//null}ifelse}bdef
currentdict/unique_name undef
currentdict/match_in_diff undef/ToUnicodeCMapReader 3 dict begin/defineresource{pop
dup userdict exch/.lastToUnicode exch put
exch pop}bind def/CIDSystemInfo{(   **** Warning: ToUnicode CMap has invalid syntax near CIDSystemInfo.\n)pdfformaterror
/CIDSystemInfo}bind def/CMapName{(   **** Warning: ToUnicode CMap has no CMapName.\n\
See the comment to revision 6201 in gs/doc/ps2pdf.htm#Problems .\n) pdfformaterror/CMap1}bind def
currentdict end readonly def/string2number{0 exch dup 0 exch 1 exch length 1 sub{1 index exch get
3 2 roll 256 mul add exch}for
pop}bind def/copy&def{{true}{currentdict gcheck{dup gcheck not}{false}ifelse}ifelse{currentglobal currentdict gcheck setglobal
exch dup length string copy exch
setglobal}if
def}bind def/.convert_ToUnicode-into-g2u{PDFDEBUG{(.convert_ToUnicode-into-g2u beg)=}if
3 2 roll begin/.CodeMapData get
1 get{PDFDEBUG{dup ==}if
dup length 1 sub 0 exch 5 exch{2 copy get
string2number
2 index 2 index 1 add get
dup 0 get 8 mul
3 2 roll exch bitshift exch
dup 0 get exch 3 get
4 index 4 index 2 add get
5 index 5 index 3 add get
PDFDEBUG{( offset=)print 4 index =string cvs print( key_size=)print 3 index =string cvs print( value_size=)print 2 index =
( keys=)print 1 index ==( values=)print dup ==}if
1 index length 0 eq{exch pop exch pop exch pop exch
4 index null ne{4 index length 1 index gt{4 index exch get}if}if
exch
PDFDEBUG{( defined single: )print 1 index =string cvs print( )print dup ==}if
false copy&def
pop}{dup length string copy
0 4 index 2 mul 3 index length 1 sub{2 index 1 index 6 index getinterval
string2number
PDFDEBUG{( keyL=)print dup =string cvs print}if
3 index 2 index 7 index add 7 index getinterval
string2number
PDFDEBUG{( keyH=)print dup =}if
3 2 roll 6 index idiv 5 index mul
3 index exch 6 index getinterval
3 1 roll 1 exch{9 index null ne{9 index exch get}if
1 index
PDFDEBUG{( defined from range: )print 1 index =string cvs print( )print dup ==}if
true copy&def
dup dup length 1 sub
2 copy get
1 add 255 and put}for}for
pop pop pop pop pop pop pop}ifelse}for
pop}forall
end
pop
PDFDEBUG{(.convert_ToUnicode-into-g2u end)=}if}bind def/.processToUnicode{currentdevice .devicename/pdfwrite eq{PDFDEBUG{
(.processToUnicode beg)=}if
2 index/ToUnicode knownoget{dup type/nametype eq{(   **** Warning: Ignoring bad ToUnicode CMap.\n)pdfformaterror
pop}{PDFfile fileposition exch
false resolvestream//ToUnicodeCMapReader begin
dup 0(begincmap)/SubFileDecode filter flushfile/CIDInit/ProcSet findresource begin 12 dict begin
0(endcmap)/SubFileDecode filter cvx/begincmap cvx exch 2 .execn
endcmap
userdict/.lastToUnicode currentdict put
end end end
PDFfile exch setfileposition
1 index/FontInfo .knownget not{1 index/FontInfo 5 dict dup 4 1 roll put}if
dup/GlyphNames2Unicode .knownget not{currentglobal exch dup gcheck setglobal
dup/GlyphNames2Unicode 100 dict dup 4 1 roll .forceput
3 2 roll setglobal}if
exch pop exch
userdict/.lastToUnicode get
.convert_ToUnicode-into-g2u
null}ifelse}if
PDFDEBUG{(.processToUnicode end)=}if}if
pop pop pop}bind def/standardfontdescriptors mark/Courier mark/Flags 16#23 .dicttomark/Courier-Oblique 1 index
/Courier-Bold 1 index/Courier-BoldOblique 1 index/Helvetica mark/Flags 16#20 .dicttomark/Helvetica-Oblique 1 index
/Helvetica-Bold 1 index/Helvetica-BoldOblique 1 index/Times-Roman mark/Flags 16#22 .dicttomark/Times-Bold 1 index
/Times-Italic mark/Flags 16#62 .dicttomark/Times-BoldItalic 1 index/Symbol mark/Flags 16#4 .dicttomark/ZapfDingbats 1 index
.dicttomark readonly def/.pdforigfontcache_g 20 dict def
currentglobal false setglobal
systemdict/.pdforigfontcache_l 20 dict .forceput
setglobal/pdffindcachedfont{dup//.pdforigfontcache_g exch .knownget{exch pop}{dup .pdforigfontcache_l exch .knownget{exch pop}{
dup findfont dup
dup gcheck{//.pdforigfontcache_g}{.pdforigfontcache_l}ifelse
4 2 roll .growput}ifelse}ifelse}bind def/pdfaddcachedfont{dup findfont dup
dup gcheck{//.pdforigfontcache_g}{.pdforigfontcache_l}ifelse
4 2 roll
put}bind def/.remove_font_name_prefix{dup .namestring(+)search{true exch{dup 65 lt exch 90 gt or{pop false exit}if}forall
{pop exch pop cvn}{pop pop}ifelse}{pop}ifelse}bind def/.pdfdfndict mark/defaultfontname/Helvetica
.dicttomark readonly def/pdffindfont{dup/Font resourcestatus{pop pop pdffindcachedfont}{1 index/FontDescriptor knownoget{
dup/Flags oget
dup 16#40 and -6 bitshift
1 index 16#40000 and -17 bitshift add
exch 16#2 and 2 bitshift add
1 index dup/FontName known{/FontName oget}{(   **** FontDescriptor missing required /FontName key. BaseFont name used.\n)
pdfformaterror
pop 2 index}ifelse
.remove_font_name_prefix
exch
0 2 index .fontnameproperties 6 and or//.pdfdfndict begin .substitutefontname end
Fontmap 1 index known not{pop 1 index .substitutefont}if
dup 3 index ne QUIET not and{(Substituting font )print dup =only( for )print 2 index =only(.)= flush}if
pdffindcachedfont
exch/Flags oget 16#20000 and 0 ne{true .copyfontdict
dup/CharStrings 2 copy get dup length dict .copydict
5 index/FirstChar get 97 .max
6 index/LastChar get 122 .min 1 exch{6 index/Widths oget 1 index 8 index/FirstChar get sub oget
1 string dup 0 5 -1 roll put
2 index exch dup cvn exch
dup 0 2 copy get 32 sub put 4 -1 roll{0 setcharwidth exch pop
currentfont/FontMatrix get matrix invertmatrix concat
0.7 dup scale 0 0 moveto show}/exec cvx 4 packedarray cvx put}for put}if
dup/FontName get 2 index ne{true .copyfontdict
2 copy exch/FontName exch put}if
definefont}{pdffindcachedfont}ifelse}ifelse
exch pop}bdef/buildType1{dup/BaseFont get pdffindfont}bdef/readfontfilter{0()/SubFileDecode filter}bdef
/readtype1dict 5 dict dup begin/definefont{dup topFontDict eq topFontDict null eq or{dup wcheck not{dup length dict copy}if
exch pop savedFontName exch}if//systemdict/definefont get exec}bdef/undef_proc_warning{/Repaired true store
UndefProcList exch 2 copy .knownget{1 add}{1}ifelse put}bdef/missing-type1-procs 6 dict begin
/-|{string currentfile exch readstring pop/-|//undef_proc_warning exec}executeonly bdef
/RD{string currentfile exch readstring pop/RD//undef_proc_warning exec}executeonly bdef
/|-{noaccess def/|-//undef_proc_warning exec}executeonly bdef/ND{noaccess def/ND//undef_proc_warning exec}executeonly bdef
/|{noaccess put/|//undef_proc_warning exec}executeonly bdef/NP{noaccess put/NP//undef_proc_warning exec}executeonly bdef
currentdict end readonly def/eexec{count 0 gt{/topFontDict 2 index cvlit store}if//.eexec_param_dict/eexecDecode filter
//missing-type1-procs begin/userdict .systemvar begin//systemdict begin
readtype1dictcopy begin cvx stopped{currentdict end//missing-type1-procs eq{exit}if}loop{stop}if}bdef
currentdict dup/undef_proc_warning undef/missing-type1-procs undef
end readonly def/readtype1{1 index exch
PDFfile fileposition 3 1 roll
dup/PFB known exch
true resolvestream
exch{//false/PFBDecode filter}if//systemdict begin//readtype1dict dup length 3 add dict copy begin
1 index/BaseFont oget/savedFontName exch def/topFontDict null def/readtype1dictcopy currentdict def
{cvx exec}aload pop count 2 sub 3 packedarray cvx exec{currentdict/topFontDict known not{end}{end end exit}ifelse}loop
count exch sub{pop}repeat
PDFfile 3 -1 roll setfileposition/BaseFont oget pdfaddcachedfont
exch pop}bdef/buildType3{8 dict begin/FontType 3 def/Resources 1 index/Resources knownoget{oforce}{LocalResources}ifelse def
/FontBBox 1 index/FontBBox get cvx def/FontMatrix 1 index/FontMatrix oget def/CharProcs 1 index/CharProcs oget def
1 index/Widths knownoget{/Widths exch def/FirstChar 1 index/FirstChar oget def/LastChar 1 index/LastChar oget def}if
/FontName 1 index/Name .knownget not{PDFfile fileposition 16 32 string cvrs cvn}if def
/Encoding .notdefEncoding 2 index getencoding def/BuildChar{1 index begin 3 dict begin/Font 3 -1 roll def/CharCode 1 index def
Encoding exch get CharProcs exch knownoget{PDFfile fileposition exch//false resolvestream
q//null/FillColor gput//null/StrokeColor gput
Font/Resources get exch pdfopdict .pdfruncontext
Q
PDFfile exch setfileposition}{0 0 0 0 0 0
pdfopdict/d1 get exec}ifelse
end end}bdef
dup currentdict Encoding .processToUnicode
FontName currentdict end definefont exch pop}bdef/.adjustcharwidth{pop 0/Widths where{begin
CharCode FirstChar ge CharCode LastChar le and{exch pop Widths CharCode FirstChar sub get exch}if end}if}bdef/TTfonts mark
/Arial/Helvetica/Arial,Italic/Helvetica-Oblique/Arial,Bold/Helvetica-Bold/Arial,BoldItalic/Helvetica-BoldOblique
/CourierNew/Courier/CourierNew,Bold/Courier-Bold/TimesNewRoman/Times-Roman/TimesNewRoman,Italic/Times-Italic
/TimesNewRoman,Bold/Times-Bold/TimesNewRoman,BoldItalic/Times-BoldItalic
.dicttomark readonly def/buildTrueType{dup/BaseFont oget/Repaired true store
TTFWarnList 1 index true put
dup/Font resourcestatus dup{exch pop exch pop}if not
TTfonts 2 index known and{dup TTfonts exch get
QUIET not{(Substituting font )print dup =only( for )print 1 index =only(.)= flush}if
exch 3 1 roll pdffindfont
true .copyfontdict
2 copy exch/FontName exch put
definefont}{pdffindfont}ifelse}bdef/readtruetype{1 index exch
PDFfile fileposition 3 1 roll
true resolvestream readfontfilter
1 index/Subtype get/CIDFontType2 eq{.loadttcidfont}{1 index/FontDescriptor oget/Flags get 4 and 0 ne
dup{//null}{StandardEncoding}ifelse
3 index/Encoding known{3 index getencoding}if
dup 4 index exch/prebuilt_encoding exch put
.loadpdfttfont}ifelse
exch pop
PDFfile 3 -1 roll setfileposition
exch pop}bdef/knownCMaps mark/Identity-H{/Identity-H 0 makeIdentityCMap}/Identity-V{/Identity-V 1 makeIdentityCMap}
.dicttomark def/makeIdentityCMap{.currentglobal true .setglobal 3 1 roll/CIDInit/ProcSet findresource begin
12 dict begin
begincmap/WMode exch def/CMapName exch def/CIDSystemInfo 3 dict dup begin/Registry(Adobe)def/Ordering(Identity)def
/Supplement 0 def
end def/CMapVersion 1 def/CMapType 1 def
1 begincodespacerange
<0000><ffff>
endcodespacerange
1 begincidrange
<0000><ffff>0
endcidrange
endcmap
CMapName currentdict/CMap defineresource
knownCMaps CMapName 2 index put
end
end
exch .setglobal}bdef/buildType0{dup/BaseFont get
1 index/Encoding oget
dup type/nametype eq{dup/CMap resourcestatus{pop pop/CMap findresource}{knownCMaps 1 index .knownget
{exch pop exec}{/undefined signalerror}ifelse}ifelse}{PDFfile fileposition exch
dup/CMapName get exch true resolvestream cvx exec/CMap findresource
exch PDFfile exch setfileposition}ifelse[3 index/DescendantFonts oget{exec resourcefont}forall].composefontdict
3 copy exch pop null .processToUnicode/Font defineresource
1 index/FontMatrix knownoget{dup aload pop true{0 0 1 0 0 1}{3 -1 roll eq and}forall{
1 index exch makefont exch/FontName get exch definefont}{pop}ifelse}if exch pop}bdef/.pdfDefaultDW 1000 def
/.pdfDefaultDW2[880 -1000]def/addCIDmetrics{dup length 5 add dict .copydict
dup/FID undef
dup/UniqueID undef
dup/XUID undef
1 index/DW knownoget{1 index/DW 3 -1 roll put}{dup/DW .pdfDefaultDW put}ifelse
1 index/W knownoget{dup 2 index/W 3 -1 roll put
.pdfMakeInternalW 1 index/.internalW 3 -1 roll put}if
1 index/DW2 knownoget{1 index/DW2 3 -1 roll put}{dup/DW2 .pdfDefaultDW2 put}ifelse
1 index/W2 knownoget{dup 2 index/W2 3 -1 roll put
.pdfMakeInternalW2 1 index/.internalW2 3 -1 roll put}if
dup/CDevProc 1 index/CIDWProc load/exec load 3 packedarray cvx put
exch pop}bdef/.pdfMakeInternalMTXArray{7 dict
begin/itemSize exch def/M exch def/Msize M length def/Mi{M i get}def/Mi1{M i 1 add get}def/putMTXEntry<</arraytype{[
[Mi Mi Mi1 length itemSize idiv add 1 sub]true[0 itemSize Mi1 length 1 sub{[exch 1 1 index itemSize add 1 sub{Mi1 exch get}for]
}for]]/i i 2 add def}/integertype{[[Mi Mi1]false[[i 2 add 1 i 1 add itemSize add{M exch get}for]]]/i i 3 add def}>>def/i 0 def
[{putMTXEntry Mi1 type get exec i Msize ge{exit}if}loop]end}def
/.pdfMakeInternalW{dup length 0 gt{1 .pdfMakeInternalMTXArray}if}def
/.pdfMakeInternalW2{dup length 0 gt{3 .pdfMakeInternalMTXArray}if}def/.pdfGetMTXByCID{exch{{dup 0 get{}forall
3 index lt{pop pop false exit}if
2 index exch sub dup 0 lt{pop pop false exit}if
1 index 1 get not{pop 0}if
exch 2 get exch get true exit}loop{exit}if}forall
dup type/arraytype eq{exch pop true}{pop false}ifelse}def/CIDWProc{begin
5 1 roll pop pop pop pop{currentdict/DW .knownget not{.pdfDefaultDW exit}if
currentdict/.internalW .knownget not{exit}if
dup length 0 eq{pop
exit}if
2 index .pdfGetMTXByCID{exch pop{}forall
exit}if
exit}loop
FontType 11 eq{1000 div}if
0
9 -2 roll pop pop
7 2 roll
0
exch{currentdict/DW2 .knownget not{.pdfDefaultDW2 exit}if
currentdict/.internalW2 .knownget not{exit}if
dup length 0 eq{pop
exit}if
2 index .pdfGetMTXByCID{exch pop
exit}if
exit}loop
exch pop
dup length 2 eq{FontType 11 eq{{1000 div}}{{}}ifelse forall exch
8 index 2 div
exch}{FontType 11 eq{{1000 div}}{{}}ifelse forall}ifelse
end}def/tailmatch{2 copy length 1 index length .min
dup 2 index length exch sub exch getinterval
1 index eq{length 1 index length exch sub
0 exch getinterval true}{pop false}ifelse}bind def/makeboldfont{16 dict begin/strokewidth exch def/basecidfont exch def
/FontMatrix[1 0 0 1 0 0]def/CIDFontName/.boldfont def/CIDFontType 1 def
/basefont-H/.basefont-H/Identity-H[basecidfont]composefont def/basefont-V/.basefont-V/Identity-V[basecidfont]composefont def
/CIDSystemInfo dup basecidfont exch get def/FontBBox[basecidfont/FontBBox get cvx exec
4 2 roll basecidfont/FontMatrix get transform
4 2 roll basecidfont/FontMatrix get transform]def/tmpstr 2 string def/BuildGlyph{gsave
exch begin
dup 256 idiv tmpstr exch 0 exch put
256 mod tmpstr exch 1 exch put
rootfont/WMode known{rootfont/WMode get 1 eq}{false}ifelse{basefont-V}{basefont-H}ifelse setfont
strokewidth setlinewidth
1 setlinejoin
newpath
0 0 moveto tmpstr false charpath stroke
0 0 moveto tmpstr show
currentpoint setcharwidth
end
grestore}bind def
currentdict
end
dup/CIDFontName get exch/CIDFont defineresource}bind def/findCIDFont{{dup/CIDFont resourcestatus{pop pop/CIDFont findresource
exit}if
.remove_font_name_prefix
dup dup length string cvs(,Bold)tailmatch{exch pop
cvn findCIDFont 0.03 makeboldfont
exit}if(,Italic)tailmatch{exch pop
cvn findCIDFont[1 0 0.3 1 0 0]makefont
exit}if(,BoldItalic)tailmatch{exch pop
cvn findCIDFont 0.03 makeboldfont[1 0 0.3 1 0 0]makefont
exit}if
pop
1 index/CIDSystemInfo oget begin Registry(-)Ordering end
concatstrings concatstrings
cvn
QUIET not{(Substituting CID font resource)print dup ==only( for )print 1 index ==only(.\n)print}if
exch pop/CIDFont findresource
exit}loop}bdef/buildCIDType0{dup/BaseFont get findCIDFont exch pop}bdef/buildCIDType2{dup/BaseFont get findCIDFont exch pop
}bdef/processCIDToGIDMap{1 index/CIDToGIDMap knownoget{PDFfile fileposition 4 1 roll
dup/Identity eq{pop}{true resolvestream
dup 65534 string readstring{1 index 65534 string readstring pop
2 array astore
dup 1 get length 65534 add}{dup length}ifelse
2 idiv
3 index exch/CIDCount exch put
exch closefile exch
dup/CIDMap 4 -1 roll put}ifelse
3 2 roll PDFfile exch setfileposition}if}bdef/adjustCIDType0{addCIDmetrics
dup/CIDFontName get exch/CIDFont defineresource}bind def/adjustCIDType2{addCIDmetrics
processCIDToGIDMap
dup/CIDFontName get exch/CIDFont defineresource}bind def/fontloadprocs mark/Type1C/readType1C cvx
/CIDFontType0C/readCIDFontType0C cvx
.dicttomark readonly def/readType1C{1 index exch
PDFfile fileposition 3 1 roll
dup true resolvestream dup readfontfilter
3 index/FontDescriptor oget/FontName oget
1 index FRD
closefile closefile pop
PDFfile 3 -1 roll setfileposition/FontDescriptor oget/FontName oget pdfaddcachedfont
exch pop}bdef/readCIDFontType0C{PDFfile fileposition 3 1 roll
dup true resolvestream dup readfontfilter
3 index/FontDescriptor oget/FontName oget
1 index FRD
closefile closefile pop
PDFfile 3 -1 roll setfileposition
dup/FontDescriptor oget/FontName oget/CIDFont findresource
addCIDmetrics dup/CIDFontName get exch/CIDFont defineresource}bdef/readOTTOfont{1 index exch
PDFfile fileposition 3 1 roll
dup true resolvestream dup readfontfilter
3 index/FontDescriptor oget/FontName oget
1 index
.init_otto_font_file//true ReadData
closefile closefile pop
PDFfile 3 -1 roll setfileposition/FontDescriptor oget/FontName oget pdfaddcachedfont
exch pop}bdef/fonttypeprocs mark/Type0//buildType0/Type1//buildType1/MMType1//buildType1/Type3//buildType3
/TrueType//buildTrueType/CIDFontType0//buildCIDType0/CIDFontType2//buildCIDType2
.dicttomark readonly def/adjustfonttypes mark/Type1//adjustfont/MMType1//adjustfont/TrueType//adjustfont
/CIDFontType0//adjustCIDType0/CIDFontType2//adjustCIDType2
.dicttomark readonly def/bndef{exch bind exch{dup 3 1 roll def}repeat
pop}bdef/font_tag_dict 13 dict begin/no_stream{pop pop
dup/Subtype get
fonttypeprocs exch dup/ eq{(   **** Warning: Font missing required Subtype, /Type1 assumed.\n)pdfformaterror
pop/Type1}if
get exec}bdef/bad_stream{(   **** Warning: Error reading font stream, loading font by the name\n)pdfformaterror//no_stream exec
}bdef
<8001>{dup/PFB//true put
exch pop readtype1}bdef(%!PS)(%!Fo){exch pop readtype1}2 bndef
<01000401><01000402><01000403><01000404>
<01000C02>{exch pop
dup/Subtype get
fontloadprocs exch get exec}5 bndef
<00010000>(true)(typ1)(ttcf){exch pop readtruetype}4 bndef(OTTO){exch pop
readOTTOfont}bdef
currentdict end readonly def
currentdict/bndef undef/resourcefont{dup/PSFont .knownget{/FID knownoget{type/fonttype eq}{//false}ifelse}{//false}ifelse{
/PSFont get}{dup dup/FontDescriptor knownoget{dup/FontObject .knownget dup{3 index/Subtype knownoget not{/Type1}if
dup/CIDFontType0 eq exch/CIDFontType2 eq or
2 index/CIDFontType known xor{pop pop//false}if}if{3 1 roll pop pop}{dup/FontFile knownoget not{dup/FontFile2 knownoget not{
dup/FontFile3 knownoget not{//null}if}if}if
dup//null ne{PDFfile fileposition
1 index//true resolvestream dup
4 string readstring not{/bad_stream}if
exch closefile
PDFfile 3 -1 roll setfileposition
dup length 4 lt{pop/bad_stream}if}{/no_stream}ifelse//font_tag_dict 1 index known not{dup 0 2 getinterval<8001>eq{
0 2 getinterval}{(12345678>\n)dup/ASCIIHexEncode filter dup 4 -1 roll writestring closefile
(   **** Warning: unrecognized font file starts with <)exch concatstrings
pdfformaterror/no_stream}ifelse}if//font_tag_dict exch get exec
1 index/FontDescriptor oget
1 index/FontObject exch put}ifelse}{dup/Subtype get fonttypeprocs exch dup/ eq{
(   **** Warning: Font missing required Subtype, /Type1 assumed.\n)pdfformaterror
pop/Type1}if
get exec}ifelse
1 index 3 1 roll
1 index/Subtype get//adjustfonttypes exch .knownget{exec}{exch pop}ifelse
dup 3 1 roll/PSFont exch put}ifelse
dup checkGlyphNames2Unicode}bdef
currentdict/font_tag_dict undef
drawopdict begin/d0{.adjustcharwidth setcharwidth}bdef/d1{2 copy
0 ne exch 0 ne
3 index 6 index eq and
exch 2 index 5 index eq and or{pop pop pop pop .adjustcharwidth setcharwidth}{
6 -2 roll .adjustcharwidth 6 2 roll setcachedevice}ifelse}bdef/Tf{1 index Page/Font rget{resourcefont exch Tf pop}{
(   **** Warning: Tf refers to an unknown resource name: )pdfformaterror
1 index .namestring pdfformaterror( Assuming it's a font name.\n)pdfformaterror
Tf}ifelse}bdef
end
end
end
.setglobal
/.setlanguagelevel where{pop 2 .setlanguagelevel}if
.currentglobal true .setglobal/pdfdict where{pop}{/pdfdict 100 dict def}ifelse
pdfdict begin/#? false def/.writepdfmarkdict 1 dict dup/pdfmark null put readonly def/.writepdfmarks{
currentdevice//.writepdfmarkdict .getdeviceparams
mark eq{false}{pop pop true}ifelse
systemdict/DOPDFMARKS known or}bind def/pdfopdict mark
objopdict{}forall
drawopdict{}forall/endstream{exit}bind(%%EOF)cvn{exit}bind
/obj{(   **** Warning: Content stream is not terminated by 'endstream'.\n)pdfformaterror pop pop exit}bind
/BX{/BXlevel BXlevel 1 add store}bind/EX{/BXlevel BXlevel 1 sub store}bind/PS{cvx exec}bind/BMC{pop}bind/BDC{pop pop}bind/EMC{}
/MP{pop}bind/DP{pop pop}bind
.dicttomark readonly def
end
userdict begin/defaultfontname/Times-Roman def
SymbolEncoding pop
DingbatsEncoding pop
systemdict begin/.runps/run load def/run{dup type/filetype ne{(r)file}if{dup( ).peekstring not{false exit}if
dup 0 get 32 le{pop dup read pop pop}{true exit}ifelse}loop
exch pop{dup 2 string .peekstring pop dup(%!)eq exch(%%)eq or{cvx .runps}{dup 1023 string .peekstring pop dup length 400 ge{
(%PDF-1.)search{3 1 roll pop pop
dup(%!PS)search not{length 0 ne{1 index exch readstring pop pop(%stderr)(w)file dup
(   **** Warning: File has some garbage before %PDF-1. .\n)writestring flushfile}{pop}ifelse
dup(%stdin)(r)file eq{null(w+)//systemdict/.tempfile get exec exch 3 1 roll
64000 string{2 index 1 index readstring
exch 3 index exch writestring
not{exit}if}loop
pop exch closefile
dup 0 setfileposition
dup runpdf
closefile deletefile}{runpdf}ifelse}{pop pop pop pop cvx .runps}ifelse}{pop cvx .runps}ifelse}{pop cvx .runps}ifelse}ifelse}{
closefile}ifelse}bind odef
currentdict/runpdfstring .undef/runpdfbegin{userdict begin/PDFTopSave save def
0 setobjectformat/Page# null def/Page null def/DSCPageCount 0 def/PDFSave null def
GS_PDF_ProcSet begin
pdfdict begin
pdfopen begin}bind def/runpdfpagerange{/FirstPage where{pop FirstPage dup pdfpagecount gt
{(\nRequested FirstPage is greater than the number of pages in the file: )print
pdfpagecount = flush}if}{1}ifelse/LastPage where{pop LastPage pdfpagecount .min}{pdfpagecount}ifelse
1 index 1 index gt{(   No pages will be processed \(FirstPage > LastPage\).)= flush}{QUIET not
{(Processing pages )print 1 index =only( through )print dup =only(.)= flush}if}ifelse}bind def/dopdfpages{
<</PDFScanRules//true >>setuserparams
1 exch{dup/Page# exch store
QUIET not{(Page )print dup == flush}if
pdfgetpage pdfshowpage}for
<</PDFScanRules//null >>setuserparams}bind def/runpdfend{Repaired{printrepaired}if
currentdict pdfclose
end
end
end
PDFTopSave restore
end
2 vmreclaim}bind def/pdf_collection_files{{}//true
Trailer/Root oget/Collection knownoget{/D knownoget{Trailer/Root oget/Names knownoget{/EmbeddedFiles knownoget{
exch nameoget dup//null ne{/EF knownoget{/F knownoget{//true resolvestream//null(w).tempfile
3 -1 roll
32768 string{3 copy readstring
3 1 roll
writestring
not{exit}if}loop
pop closefile
closefile
3 1 roll pop pop
.currentglobal//true .setglobal
exch dup length string copy 1 array astore
exch .setglobal//false}if}if}{pop}ifelse}{pop}ifelse}{pop}ifelse}if}if}bind def/runpdf{//runpdfbegin exec
//pdf_collection_files exec{copy_trailer_attrs//runpdfpagerange exec//dopdfpages exec}if//runpdfend exec{dup(r)file
//runpdfbegin exec
copy_trailer_attrs//runpdfpagerange exec//dopdfpages exec//runpdfend exec
deletefile}forall}bind def{/runpdfbegin/runpdfpagerange/dopdfpages/runpdfend/pdf_collection_files}
{currentdict exch .undef}forall
end/.runstdin{{(%stdin)run}execute0}bind def
end
pdfdict begin/traileropdict mark(<<)cvn{/dictlevelcount dictlevelcount 1 add store mark}bind(>>)cvn{{.dicttomark}stopped{
(   **** File has unbalanced >> in trailer.\n)pdfformaterror}if/dictlevelcount dictlevelcount 1 sub def
dictlevelcount 0 eq{exit}if}bind([)cvn{mark}bind(])cvn dup load/R{/resolveR cvx 3 packedarray cvx}bind
.dicttomark readonly def/lineeq{anchorsearch{pop{( )anchorsearch not{()eq exit}if pop}loop}{pop false}ifelse}bind def
/linene{lineeq not}bind def/readorigxref{pop
0{PDFfile token pop
dup/trailer eq{pop exit}if
PDFfile pdfstring readline pop
token pop
exch dup length 0 ne{false 1 index{32 gt{pop true exit}if}forall{
(   **** Warning: xref subsection header has extra characters.\n)pdfformaterror/setxrefentry cvx/syntaxerror signalerror}if}if
pop
2 copy add growPDFobjects{PDFfile 20 string readstring pop
token pop
exch token pop
exch token pop
exch
dup length 0 ne{dup{32 gt{5 -1 roll 1 add 5 1 roll}if}forall}if
pop
dup/n eq{pop
0 3 1 roll//false setxrefentry
3 -1 roll pop}{/f ne{/setxrefentry cvx/syntaxerror signalerror}if}ifelse
pop pop
1 add}repeat
pop}loop
0 ne{(   **** Warning:  length of some xref entries is not equal to 20 bytes.\n)pdfformaterror}if/dictlevelcount 0 def
PDFfile traileropdict .pdfrun}bind def/xrefopdict mark(<<)cvn{/dictlevelcount dictlevelcount 1 add def mark}bind
(>>)cvn{.dicttomark/dictlevelcount dictlevelcount 1 sub def
dictlevelcount 0 eq{exit}if}bind([)cvn{mark}bind(])cvn dup load/R{/resolveR cvx 3 packedarray cvx}bind
.dicttomark readonly def/getintn{0 exch{256 mul 1 index read pop add}repeat
exch pop}bind def/xref15entryhandlers[{}bind{0 3 1 roll//false setxrefentry
3 -1 roll pop}bind{0//false setxrefentry pop}bind]def/readpdf15xref{PDFfile exch setfileposition
PDFfile token pop pop
PDFfile token pop pop
PDFfile token pop pop/dictlevelcount 0 def PDFfile xrefopdict .pdfrun
dup/Type get/XRef ne{/readpdf15xref cvx/syntaxerror signalerror}if
dup/Size get growPDFobjects
PDFfile token pop pop
dup stream false resolvestream
1 index/Index .knownget not{[0 3 index/Size get]}if
0 2 2 index length 1 sub{2 copy get
dup 3 index 3 index 1 add get
add 1 sub 1 exch{4 index/W get aload pop
3 -1 roll dup 0 eq{pop 1}{6 index exch getintn}ifelse
xref15entryhandlers exch get
3 -1 roll 6 index exch getintn
3 -1 roll 6 index exch getintn
3 -1 roll exec
pop pop pop}for
pop}for
pop pop}bind def/readxref{PDFoffset add PDFfile exch
dup PDFfilelen gt{(   **** Warning:  Specified xref location is beyond end of file.\n)pdfformaterror
/readxref cvx/invalidaccess signalerror}if
setfileposition{PDFfile fileposition PDFfile read pop 32 gt{exit}if pop}loop
dup
PDFfile exch setfileposition
PDFfile pdfstring 0 4 getinterval readstring pop(xref)eq{readorigxref}{readpdf15xref}ifelse}bind def/pdfopen{
currentpagedevice/UseCIEColor .knownget dup{pop}if not{.currentglobal false .setglobal
/DefaultGray{/DeviceGray}cvlit/ColorSpace defineresource pop/DefaultRGB{/DeviceRGB}cvlit/ColorSpace defineresource pop
/DefaultCMYK{/DeviceCMYK}cvlit/ColorSpace defineresource pop
.setglobal}if
pdfopenfile begin
pdfopencache
currentdict end}bind def/copy_trailer_attrs{writeoutputintents
.writepdfmarks{Trailer/Root oget/Outlines knownoget{/First knownoget{{dup writeoutline/Next knownoget not{exit}if}loop}if}if}if
}bind def/verify_xref{PDFfilelen
1 1 Objects llength 1 sub{Generations 1 index lget
0 ne{ObjectStream 1 index lget
0 eq{{dup Objects exch lget
PDFoffset add dup 3 index ge{pop true}{PDFfile exch setfileposition
true
PDFfile token pop
2 index eq{PDFfile token pop
Generations 3 index
lget 1 sub
eq{PDFfile token pop/obj eq{pop false}if}if}if}ifelse}.internalstopped{true}if{
(   **** Warning:  File has an invalid xref entry:  )pdfformaterror
pdfstring cvs pdfformaterror(.  Rebuilding xref table.\n)pdfformaterror
search_objects
exit}if}{pop exit}ifelse}if
pop}for
pop}bind odef/pdfopencache{/PageCount pdfpagecount def/PageNumbers PageCount 65534 .min dict def
/PageIndex PageCount 65534 .min array def}bind def/pdfopenfile{pdfdict readonly pop
15 dict begin/LocalResources 0 dict def/DefaultQstate//null def/Printed where{pop}{
/Printed currentpagedevice/OutputFile known def}ifelse/PSLevel1 where{pop}{/PSLevel1 false def}ifelse
cvlit/PDFfile exch def/PDFsource PDFfile def/Repaired false def
currentglobal true .setglobal globaldict begin/TTFWarnList 0 dict def/UndefProcList 0 dict def
end .setglobal
PDFfile dup 0 setfileposition
0()/SubFileDecode filter
pdfstring readstring pop(%PDF-)search not{/pdfopen cvx/syntaxerror signalerror}if
length/PDFoffset exch def pop
false exch{{cvr}stopped{exch pop true exch 0 1 index length 1 sub dup 0 eq{pop 0 exit}if
getinterval}{exch{(   **** Warning: PDF version number not followed by EOL.\n)pdfformaterror}if exit}ifelse}loop
/PDFversion exch def
count/pdfemptycount exch def/Trailer<< >>def{initPDFobjects findxref readxref}.internalstopped{recover_xref_data
search_trailer}{/Trailer exch def
Trailer{/Prev knownoget not{/NoVerifyXref where{pop}{verify_xref}ifelse exit}if{readxref}.internalstopped{recover_xref_data
exit}if
dup{Trailer 2 index known{pop pop}{Trailer 3 1 roll put}ifelse}forall}loop}ifelse
<</PDFScanUnsigned//true >>setuserparams{Trailer/Encrypt knownoget{pop
pdf_process_Encrypt}if}stopped
<</PDFScanUnsigned//false >>setuserparams{stop}if
currentdict end}bind def/findeof{-1 exch{dup bytesavailable 4 lt{exit}if
dup 0(%%EO)/SubFileDecode filter flushfile
dup dup fileposition 5 sub setfileposition
dup 5 string readstring not{pop exit}if
dup(\r%%EO)eq exch(\n%%EO)eq or{dup fileposition 4 sub
3 1 roll exch pop}if}loop
exch}bind def/findxref{PDFfile dup dup dup 0 setfileposition bytesavailable
dup/PDFfilelen exch def
1024 sub PDFoffset .max
setfileposition findeof
dup 0 le{pop
dup PDFoffset setfileposition findeof
dup 0 le{(   **** Error: Cannot find a %%EOF marker anywhere in the file.\n)pdfformaterror/findxref cvx/syntaxerror signalerror
}if}if
dup 3 1 roll setfileposition
dup PDFfilelen exch sub dup dup 7 gt exch 5 lt or{pop true}{string PDFfile exch readstring pop
dup(%%EOF\n)eq exch dup(%%EOF\r)eq
exch dup(%%EOF\r\n)eq exch(%%EOF)eq or or or not}ifelse{
(   **** Warning: File has a corrupted %%EOF marker, or garbage after %%EOF.\n)pdfformaterror}if
PDFfile exch setfileposition
prevline token not{null}if dup type/integertype eq{exch pop cvi
exch PDFfile exch setfileposition
prevline dup(startxref)linene{dup(startxref)search{pop pop pop
(   **** Warning: format of the startxref line in this file is invalid.\n)pdfformaterror}{/findxref cvx/syntaxerror signalerror
}ifelse}if
pop pop}{(startxref)ne{/findxref cvx/syntaxerror signalerror}if
cvi(   **** Warning: format of the startxref line in this file is invalid.\n)pdfformaterror
exch PDFfile exch setfileposition}ifelse}bind def/stderrfile(%stderr)(w)file def/stderrprint{
//stderrfile dup 3 -1 roll writestring flushfile}bind def/pdfformaterror{stderrprint/Repaired true store}bind def
/knownoget_safe{2 copy knownoget{3 1 roll pop pop//true}{pop pop//false}ifelse}odef/printProducer{
Trailer/Info{knownoget_safe}stopped{pop pop false}if{/Producer knownoget not{null}if}{null}ifelse
dup null eq{pop}{(   **** The file was produced by: \n   **** >>>> )stderrprint(\376\377)anchorsearch{
pop dup length 2 idiv string 0 1 2 index length 1 sub{1 index exch 3 index 1 index 2 mul 1 add get put}for exch pop}if
stderrprint( <<<<\n)stderrprint}ifelse}bind def/printCollectedWarnings{TTFWarnList length 0 gt{
(\n   **** Warning: Fonts with Subtype = /TrueType should be embedded.\n)stderrprint
(                 The following fonts were not embedded:\n)stderrprint
[TTFWarnList{pop .namestring(\t\t\t)exch concatstrings(\n)concatstrings}forall]{lt}.sort{stderrprint}forall}if
UndefProcList length 0 gt{(\n   **** Embedded font uses undefined procedure\(s\):  )stderrprint
UndefProcList{exch .namestring stderrprint( )stderrprint
=string cvs stderrprint( times, )stderrprint}forall(\n)stderrprint}if}bind def/printrepaired{printCollectedWarnings
(\n   **** This file had errors that were repaired or ignored.\n)stderrprint
printProducer(   **** Please notify the author of the software that produced this\n)stderrprint
(   **** file that it does not conform to Adobe's published PDF\n)stderrprint(   **** specification.\n\n)stderrprint}bind def
/writeoutline{mark
0 2 index/First knownoget{{exch 1 add exch/Next knownoget not{exit}if}loop}if
dup 0 eq{pop 1 index}{2 index/Count knownoget{0 lt{neg}if}if/Count exch 3 index}ifelse{linkdest}stopped{cleartomark
(   **** Warning: Outline has invalid link that was discarded.\n)pdfformaterror}{/Title oget/Title exch/OUT pdfmark}ifelse
/First knownoget{{dup writeoutline/Next knownoget not{exit}if}loop}if}bind def/pdfclose{begin
PDFfile closefile
end}bind def/pget{2 copy knownoget{exch pop exch pop true}{exch/Parent knownoget{exch pget}
{dup Trailer/Root oget exch knownoget dup{3 -1 roll(   **** Warning:  The /)pdfformaterror 50 string cvs pdfformaterror
( key is missing from the Page tree.\n)pdfformaterror}{exch pop}ifelse}ifelse}ifelse}bind def/rget{
LocalResources 1 index knownoget{3 index knownoget}{false}ifelse{exch pop exch pop exch pop true}{exch/Resources pget{
exch knownoget{exch knownoget}{pop false}ifelse}{pop pop false}ifelse}ifelse}bind def/pdfpagecount{Trailer/Root oget/Pages oget
dup/Count knownoget{dup 0 le{pop(   **** Warning:  Invalid Page count.\n)pdfformaterror
1 1 999999999{dup pdffindpage?
exch pop//null eq{exit}{pop}ifelse}for
1 sub
2 copy/Count exch put}if
exch pop}{dup/Type oget/Page eq{<< exch 1 array astore/Kids exch/Count 1/Type/Pages >>
Trailer/Root oget/Pages 3 -1 roll put
1(   **** Warning:  No /Pages node. The document root directly point a page.\n)pdfformaterror}{
(   **** Warning:  Page count not found; assuming 1.\n)pdfformaterror
pop 1}ifelse}ifelse}bind def/pdffindpage?{Trailer/Root oget/Pages get{dup oforce/Kids knownoget not{exit}if
exch pop null
0 1 3 index length 1 sub{2 index exch get
dup oforce dup/Kids known{/Count oget}{pop 1}ifelse
dup 5 index ge{pop exch pop exit}if
5 -1 roll exch sub 4 1 roll pop}for exch pop
dup null eq{pop pop 1 null exit}if}loop}bind def/pdffindpageref{dup pdffindpage?
1 index 1 ne{pop pop/pdffindpage cvx/rangecheck signalerror}if
exch pop
PageIndex 2 index 1 sub 65533 .min 2 index oforce put
PageNumbers 1 index oforce 3 index dup 65534 le{put}{pop pop pop}ifelse
exch pop}bind def/pdffindpage{pdffindpageref oforce}bind def/pdfgetpage{PageIndex 1 index 1 sub dup 65533 lt{get}{pop pop null}
ifelse
dup null ne{exch pop oforce}{pop pdffindpage}ifelse}bind def/pdfpagenumber{PageNumbers 1 index .knownget{exch pop}
{1 1 PageCount 1 add{dup pdfgetpage oforce 2 index eq{exit}if pop}for exch pop}ifelse}bind def/normrect_elems{exch 4 1 roll
2 copy gt{exch}if
4 2 roll 2 copy lt{exch}if
4 1 roll exch}bind def/normrect{aload pop normrect_elems 4 array astore}bind def/fix_empty_rect_elems
{dup 3 index eq{//true}{1 index 4 index eq}ifelse{pop pop pop pop
(   **** Warning:  File has an empty )pdfformaterror pdfstring cvs pdfformaterror
(. Using the current page size instead.\n)pdfformaterror
0 0 currentpagedevice/PageSize get aload pop}{5 -1 roll pop}ifelse}bind def/boxrect{exch 3 index sub exch 2 index sub}bind def
/resolvedest{dup type/nametype eq{Trailer/Root oget/Dests knownoget{exch knownoget not{null}if}{pop null}ifelse}{
dup type/stringtype eq{Trailer/Root oget/Names knownoget{/Dests knownoget{exch nameoget}{pop null}ifelse}{pop null}ifelse}if
}ifelse}bind def/viewdestprocs 8 dict dup begin/Fit{exch pop exch pop}bind def/FitH{aload pop
0 4 -1 roll 1 and 0 eq{exch}if
4 -1 roll transform exch pop
2 array astore}bind def/FitV{aload pop
0 4 -1 roll 1 and 0 ne{exch}if
4 -1 roll transform pop
2 array astore}bind def/FitB/Fit load def/FitBH/FitH load def/FitBV/FitV load def/XYZ{aload pop
3 1 roll
2 copy 7 -1 roll 1 and 0 ne{exch}if	4 2 roll
2{dup null eq{pop 0}if exch}repeat
7 -1 roll transform
2{3 -1 roll null eq{pop null}if exch}repeat
3 -1 roll
4 array astore}bind def/FitR{exch pop
aload pop
2{5 index transform 4 2 roll}repeat normrect_elems
5 array astore
exch pop}bind def
end readonly def/linkdest{dup/Dest knownoget{resolvedest
dup type/dicttype eq{/D knownoget not{null}if}if
dup null eq{pop}{dup 0 oget
false
1 index type/dicttype eq{1 index/Type knownoget{/Page eq{pop
dup pdf_cached_PDF2PS_matrix exch
dup/Rotate pget not{0}if 90 idiv exch
pdfpagenumber
true}if}if}if{/Page exch 6	2 roll
3 -1 roll dup length 1	sub 1 exch getinterval/View 4 1 roll//viewdestprocs 1 index 0 get get exec
3 -1 roll}{pop
dup length 1 sub 1 exch getinterval/View exch 3 -1 roll}ifelse}ifelse}if}bind def/namedactions 8 dict dup begin
/FirstPage{1//false}def/LastPage{pdfpagecount//false}def
/NextPage{counttomark 2 add index pdfpagenumber 1 add dup pdfpagecount gt}bind def
/PrevPage{counttomark 2 add index pdfpagenumber 1 sub dup 1 lt}bind def
end readonly def/annottypes 5 dict dup begin/Text{mark exch{/Rect/Open/Contents}{2 copy knownoget{3 -1 roll}{pop}ifelse}
forall pop/ANN pdfmark}bind def/Link{mark exch
dup/C knownoget{/Color exch 3 -1 roll}if{/Rect/Border}{2 copy knownoget{3 -1 roll}{pop}ifelse}forall dup/A knownoget{
dup/URI known{/A mark 3 2 roll{oforce}forall
.dicttomark
3 2 roll}{dup/D knownoget{exch pop exch dup length dict copy dup/Dest 4 -1 roll put}{/N knownoget{namedactions exch .knownget{
exec{pop(   **** Warning: Ignoring a named action pointing out of the document page range.\n)pdfformaterror}{
/Page exch 3 -1 roll}ifelse}if}if}ifelse}ifelse}if
linkdest pop/LNK pdfmark}bind def
end readonly def/pdfshowpage{dup/Page exch store
pdfshowpage_init
pdfshowpage_setpage
pdfshowpage_finish}bind def/pdfpagecontents{}bind def/pdfshowpage_init{/DSCPageCount DSCPageCount 1 add store}bind def
/get_media_box{/MediaBox pget not{(   **** Page has no /MediaBox attribute. Using the current page size.\n)pdfformaterror
[0 0 currentpagedevice/PageSize get aload pop]}if}bind def/pdf_PDF2PS_matrix{matrix currentmatrix matrix setmatrix exch
dup/CropBox pget dup{exch pop}if//systemdict/UseCropBox known and{/CropBox 2 copy pget pop}{/MediaBox 1 index get_media_box
}ifelse
oforce_elems normrect_elems fix_empty_rect_elems 4 array astore//systemdict/PDFFitPage known{
PDFDEBUG{(Fiting PDF to imageable area of the page.)= flush}if
currentpagedevice/.HWMargins get aload pop
currentpagedevice/PageSize get aload pop
2 copy gt
7 index aload pop 3 -1 roll sub 3 1 roll exch sub exch
10 index/Rotate pget not{0}if 90 idiv 1 and 0 ne{exch}if
gt
ne{2 copy ne{2 copy lt{6 2 roll 4 -1 roll 6 -2 roll}{6 2 roll 4 1 roll 6 -2 roll}ifelse
exch}if}if
3 -1 roll sub 3 1 roll exch sub exch
PDFDEBUG{(    Translate up by [ )print 3 index =print(, )print 2 index =print( ])= flush}if
3 index 3 index translate
2 index sub exch 3 index sub exch 4 2 roll pop pop
2 index aload pop 2 index sub exch 3 index sub exch 4 2 roll pop pop
5 index/Rotate pget not{0}if 90 idiv 1 and 0 ne{exch}if
3 -1 roll exch div 3 1 roll div .min
PDFDEBUG{(    Scale by )print dup = flush}if}{//systemdict/NoUserUnit .knownget not{false}if{1}{1 index/UserUnit knownoget{
PDFDEBUG{(Scaling due to UserUnit by )print dup = flush}if}{1}ifelse}ifelse}ifelse
dup scale
aload pop boxrect{{pop pop}{-90 rotate pop neg 0 translate}{180 rotate neg exch neg exch translate}
{90 rotate neg 0 exch translate pop}}5 index/Rotate pget not{0}if
PDFDEBUG{dup 0 ne{(Rotating by )print dup =print( degrees.)= flush}if}if
90 idiv 3 and get exec
exch neg exch neg translate
pop
matrix currentmatrix exch setmatrix}bind def/PDF2PS_matrix_key(PDF->PS matrix)cvn def/pdf_cached_PDF2PS_matrix{
dup//PDF2PS_matrix_key .knownget{exch pop}{dup dup pdf_PDF2PS_matrix//PDF2PS_matrix_key exch put//PDF2PS_matrix_key get}ifelse
}bind def
currentdict/PDF2PS_matrix_key undef/.pdfshowpage_Install{exch pdf_cached_PDF2PS_matrix concat
0 get exec}bind def/pdfshowpage_setpage{5 dict begin/UseCIEColor true def/Orientation 0 def
currentpagedevice
1 index/CropBox pget dup{exch pop}if//systemdict/UseCropBox known and{/CropBox 2 index/CropBox pget}{
/MediaBox 2 index get_media_box true}ifelse{oforce_elems normrect_elems fix_empty_rect_elems boxrect 4 2 roll pop pop
3 index/Rotate pget not{0}if 90 idiv 1 and 0 ne{exch}if//systemdict/PDFFitPage known{gt
1 index/PageSize get aload pop
2 copy gt
4 -1 roll ne{exch}if}{//systemdict/NoUserUnit .knownget not{false}if not{3 index/UserUnit knownoget{
dup 4 -1 roll mul 3 1 roll mul}if}if}ifelse
2 array astore/PageSize exch def}{pop}ifelse
<</PageSpotColors 3 index countspotcolors >>setpagedevice
1 index pageusestransparency/PageUsesTransparency exch def
dup/Install .knownget{dup type dup/arraytype eq exch/packedarraytype eq or{dup length 4 eq{
dup 2 get/.pdfshowpage_Install load eq{1 get 0 get}if}if}if}{{}}ifelse 1 array astore
2 index exch/.pdfshowpage_Install load/exec load
4 packedarray cvx/Install exch def
pop currentdict end setpagedevice}bind def/.free_page_resources{Page/Resources pget{/Shading knownoget{{dup type/dicttype eq{
dup/.shading_dict known{dup/.shading_dict undef}if}if
pop pop}forall}if}if}bind def/pdfshowpage_finish{save/PDFSave exch store/PDFdictstackcount countdictstack store
(before exec)VMDEBUG
pdfshowpage_setcspacesub
.writepdfmarks{dup/CropBox pget{oforce_elems
2{Page pdf_cached_PDF2PS_matrix transform 4 2 roll}repeat
normrect_elems/CropBox 5 1 roll fix_empty_rect_elems 4 array astore
mark/CropBox 3 -1 roll/PAGE pdfmark}if
dup/Annots knownoget{0 1 2 index length 1 sub{1 index exch oget
dup/Subtype oget annottypes exch .knownget{exec}{pop}ifelse}for pop}if}if
6 dict begin/BXlevel 0 def/BGDefault currentblackgeneration def/UCRDefault currentundercolorremoval def
/TRDefault currenttransfer def
matrix currentmatrix 2 dict
2 index/CropBox pget{oforce_elems normrect_elems boxrect
4 array astore 1 index/ClipRect 3 -1 roll put}if
dictbeginpage setmatrix/DefaultQstate qstate store
count 1 sub/pdfemptycount exch store
dup pageusestransparency dup/PDFusingtransparency exch def{0 .pushpdf14devicefilter{/DefaultQstate qstate store
dup/Group knownoget{1 index/CropBox pget{/CropBox exch}{1 index get_media_box/MediaBox exch}ifelse
oforce_elems normrect_elems fix_empty_rect_elems 4 array astore .beginformgroup{showpagecontents}stopped{
.discardtransparencygroup stop}if .endtransparencygroup}{showpagecontents}ifelse}stopped{.poppdf14devicefilter
/DefaultQstate qstate store
stop}if .poppdf14devicefilter/DefaultQstate qstate store}{showpagecontents}ifelse
.free_page_resources
endpage
end
<</PageSpotColors -1 >>setpagedevice
countdictstack PDFdictstackcount sub dup 0 ne{(   **** Warning: File has imbalanced q/Q operators \(too many q's\)\n)
pdfformaterror{end}repeat}{pop}ifelse(after exec)VMDEBUG
Repaired
PDFSave restore/Repaired exch def}bind def/showpagecontents{dup
count 1 sub/pdfemptycount exch store
gsave/Contents knownoget not{0 array}if
dup type/arraytype ne{1 array astore}if{oforce false resolvestream pdfopdict .pdfrun}forall
count pdfemptycount sub dup 0 ne{(   **** File did not complete the page properly and may be damaged.\n)pdfformaterror
{pop}repeat}{pop}ifelse
grestore//systemdict/ShowAnnots .knownget not{//true}if{/Annots knownoget{{oforce drawannot}forall}if}if
//systemdict/ShowAcroForm .knownget{//true eq}{//false}ifelse{Trailer/Root oget/AcroForm knownoget{draw_acro_form}if}if
}bind def/processcolorspace{currentdevice 1 dict dup/ProcessColorModel dup put .getdeviceparams
exch pop exch pop
dup type/nametype ne{cvn}if
dup{setcolorspace}.internalstopped{pop/DeviceRGB}if}bind def/PDFtransparencyversion 1.2 def/pageusestransparency{
PDFversion PDFtransparencyversion lt NOTRANSPARENCY or{pop false}{dup false exch{
4 dict 1 index resourceusestransparency{pop not exit}if/Parent knownoget not{exit}if}loop
{pop true}{annotsusetransparency}ifelse}ifelse}bind def/extgstateusestransparency{false exch{exch pop oforce
dup/BM knownoget{dup/Normal ne exch/Compatible ne and{pop not exit}if}if
dup/ca knownoget{1 ne{pop not exit}if}if
dup/CA knownoget{1 ne{pop not exit}if}if
dup/SMask knownoget{/None ne{pop not exit}if}if
pop}forall}bind def/resourceusestransparency{{/Resources knownoget not{0 dict}if
2 copy .knownget{{(   **** File has circular references in resource dictionaries.\n)pdfformaterror}if
pop//false exit}if
2 copy//true put
dup/ExtGState knownoget{extgstateusestransparency{pop//true exit}if}if
dup/XObject knownoget{//false exch{exch pop oforce dup/Subtype get
dup/Image eq{1 index/SMask known{pop pop not exit}if}if/Form eq{3 index exch resourceusestransparency{not exit}if}{pop}ifelse
}forall{pop//true exit}if}if
2 copy//false put
pop//false exit}loop
exch pop}bind def/annotsusetransparency{false exch/Annots knownoget{{oforce/AP knownoget{/N knownoget{/Resources knownoget{
/ExtGState knownoget{extgstateusestransparency{pop true exit}if}if}if}if}if}forall}if}bind def/putspotcolor{
exch dup type/stringtype eq{cvn}if
dup dup/None eq exch/All eq or{pop pop}{0 put}ifelse}bind def/colorspacespotcolors{exch dup type/arraytype eq{
dup 0 oget dup/Indexed eq{pop 1 oget 2 copy colorspacespotcolors}{dup/Separation eq exch/DeviceN eq or{
dup 1 oget dup type/arraytype eq{{oforce 2 index putspotcolor}forall}{2 index putspotcolor}ifelse}if}ifelse}if
pop pop}bind def/resourcespotcolors{{/Resources knownoget not{exit}if
2 copy known{pop exit}if
2 copy 0 put
dup/ColorSpace knownoget{{exch pop oforce 3 index colorspacespotcolors}forall}if
dup/Pattern knownoget{{exch pop oforce 4 copy exch pop resourcespotcolors pop pop pop}forall}if
dup/Shading knownoget{{exch pop oforce/ColorSpace oget 3 index colorspacespotcolors}forall}if/XObject knownoget{
{exch pop oforce dup/Subtype get/Form eq{resourcespotcolors}{pop}ifelse}forall}if
exit}loop}bind def/annotsspotcolors{{oforce/AP knownoget{/N knownoget{resourcespotcolors}if}if}forall}bind def/pagespotcolors{
dup
0 dict exch
4 dict exch
resourcespotcolors
3 -1 roll/Annots knownoget{annotsspotcolors}if
pop}bind def/countspotcolors{pagespotcolors
dup length[/Cyan/Magenta/Yellow/Black]{2 index exch known{1 sub}if}forall
exch pop}bind def/pdfshowpage_setcspacesub{false{/DefaultGray/DefaultRGB/DefaultCMYK}{dup 3 index/ColorSpace//rget exec
{resolvecolorspace/ColorSpace defineresource pop}{pop}ifelse}forall{currentcolorspace dup length 1 eq{0 get
dup/DeviceGray eq 1 index/DeviceRGB eq or 1 index/DeviceCMYK or{/Pattern setcolorspace setcolorspace}{pop}ifelse}{pop}if}if}
bind def/writeoutputintents{currentdevice 1 dict dup/OutputIntent null put readonly
.getdeviceparams
mark ne{pop pop
Trailer/Root oget/OutputIntents knownoget{{oforce
dup length dict .copydict
dup/DestOutputProfile knownoget{PDFfile fileposition exch
mark exch{oforce}forall .dicttomark
true resolvestream[{counttomark 1 add index
64000 string readstring
not{exit}if}loop]exch closefile
0 1 index{length add}forall .bytestring
0 3 2 roll{3 copy putinterval
length add}forall pop
exch PDFfile exch setfileposition
1 index/DestOutputProfile 3 2 roll put}if[1 index/OutputCondition knownoget not{()}if
2 index/OutputConditionIdentifier knownoget not{()}if
3 index/RegistryName knownoget not{()}if
4 index/Info knownoget not{()}if
5 index/DestOutputProfile knownoget not{()}if][/OutputIntent 3 2 roll .pdfputparams pop pop
pop}forall}if[/OutputIntent[].pdfputparams pop pop}if}bind def
end
.setglobal
/.setlanguagelevel where{pop 2 .setlanguagelevel}if
.currentglobal true .setglobal/pdfdict where{pop}{/pdfdict 100 dict def}ifelse
pdfdict begin/.pdftoken where{pop}{/.pdftoken/token load def}ifelse/arc4decodefilter{1 dict begin/Key exch def
currentdict end/ArcfourDecode filter}bind def/arc4decode{1 index length 0 eq{pop}{
1 index length string 3 1 roll arc4decodefilter exch readstring pop}ifelse}bind def/md5{
16 string dup/MD5Encode filter dup 4 3 roll writestring closefile}bind def/md5_trunk{md5 0 pdf_key_length getinterval}bind def
/pdf_padding_string
<28bf4e5e4e758a41 64004e56fffa0108
2e2e00b6d0683e80 2f0ca9fe6453697a>
def/pdf_pad_key{dup length 32 gt{0 32 getinterval}if
pdf_padding_string
0 32 3 index length sub getinterval
concatstrings}bind def/pdf_xorbytes{dup length dup string
exch 1 sub 0 1 3 2 roll{dup 3 index exch get 4 index xor
3 copy put pop pop}for
3 1 roll pop pop}bind def/pdf_key_length{Trailer/Encrypt oget
dup/V knownoget not{0}if 1 eq{pop 5}{/Length knownoget{-3 bitshift}{5}ifelse}ifelse}bind def/pdf_compute_encryption_key{
pdf_pad_key
Trailer/Encrypt oget dup/O oget
exch/P oget 4 string exch
2 copy 255 and 0 exch put
2 copy -8 bitshift 255 and 1 exch put
2 copy -16 bitshift 255 and 2 exch put
2 copy -24 bitshift 255 and 3 exch put pop
Trailer/ID knownoget{0 oget}{()(   **** ID key in the trailer is required for encrypted files.\n)pdfformaterror}ifelse
3{concatstrings}repeat
Trailer/Encrypt oget dup/R oget dup 3 ge{4 ge{/EncryptMetadata knownoget
not{true}if
not{<ff ff ff ff>concatstrings}if}{pop}ifelse
md5_trunk
50{md5_trunk}repeat}{pop pop md5_trunk}ifelse}bind def/pdf_gen_user_password_R2{pdf_padding_string exch arc4decode}bind def
/pdf_gen_user_password_R3{pdf_padding_string
Trailer/ID knownoget{0 oget}{()(   **** ID key in the trailer is required for encrypted files.\n)pdfformaterror}ifelse
concatstrings md5
1 index arc4decode
1 1 19{2 index pdf_xorbytes arc4decode}for
exch pop}bind def/pdf_gen_user_password{pdf_compute_encryption_key dup
Trailer/Encrypt oget/R oget dup 2 eq{pop pdf_gen_user_password_R2}{dup 3 eq{pop pdf_gen_user_password_R3}{dup 4 eq{
pop pdf_gen_user_password_R3}{(   **** This file uses an unknown standard security handler revision: )
exch =string cvs concatstrings pdfformaterror printProducer/pdf_check_user_password cvx/undefined signalerror}ifelse}ifelse
}ifelse}bind def/pdf_check_user_password{pdf_gen_user_password
Trailer/Encrypt oget/U oget
0 2 index length getinterval eq{true}{pop false}ifelse}bind def/pdf_owner_key{pdf_pad_key
md5_trunk
Trailer/Encrypt oget/R oget 3 ge{50{md5_trunk}repeat}if}bind def/pdf_check_owner_password{pdf_owner_key
Trailer/Encrypt oget dup/O oget 2 index arc4decode
exch/R oget 3 ge{1 1 19{2 index pdf_xorbytes arc4decode}for}if
exch pop
pdf_check_user_password}bind def/pdf_process_Encrypt{Trailer/Encrypt oget/Filter oget/Standard eq not{
(   **** This file uses an unknown security handler.\n)pdfformaterror
printProducer/pdf_process_Encrypt cvx/undefined signalerror}if()pdf_check_user_password{/FileKey exch def}{/PDFPassword where{
pop PDFPassword pdf_check_user_password{/FileKey exch def}{PDFPassword pdf_check_owner_password{/FileKey exch def}{
(   **** Password did not work.\n)pdfformaterror
printProducer/pdf_process_Encrypt cvx/invalidfileaccess signalerror}ifelse}ifelse}{
(   **** This file requires a password for access.\n)pdfformaterror
printProducer/pdf_process_Encrypt cvx/invalidfileaccess signalerror}ifelse}ifelse}bind def/computeobjkey{exch
FileKey length 5 add string
dup 0 FileKey putinterval
exch
2 copy 255 and FileKey length exch put
2 copy -8 bitshift 255 and FileKey length 1 add exch put
2 copy -16 bitshift 255 and FileKey length 2 add exch put
pop exch
2 copy 255 and FileKey length 3 add exch put
2 copy -8 bitshift 255 and FileKey length 4 add exch put
pop md5 0 FileKey length 5 add 2 index length .min getinterval}bind def/PDFScanRules_true<</PDFScanRules true >>def
/PDFScanRules_null<</PDFScanRules null >>def/.decpdfrun{2 index cvlit mark/PDFScanRules .getuserparam//null eq{
//PDFScanRules_true{setuserparams}0 get
mark 7 4 roll}{mark 5 2 roll}ifelse{.pdftoken not{(%%EOF)cvn cvx}if
dup xcheck{PDFDEBUG{dup == flush}if
3 -1 roll pop
2 copy .knownget{exch pop exch pop exec}{exch pop
dup/true eq{pop//true}{dup/false eq{pop//false}{dup/null eq{pop//null}{(   **** Unknown operator: )
exch =string cvs concatstrings(\n)concatstrings
pdfformaterror}ifelse}ifelse}ifelse}ifelse}{exch pop PDFDEBUG{dup ==only( )print flush}if
dup type/stringtype eq{Trailer/Encrypt oget
dup/R oget 4 lt{pop 1 index arc4decode
PDFDEBUG{(%Decrypted: )print dup == flush}if}{/StrF knownoget{/Identity eq not{1 index arc4decode
PDFDEBUG{(%Decrypted: )print dup == flush}if}if}if}ifelse}if
exch pop}ifelse}aload pop .packtomark cvx{loop}0 get 2 packedarray cvx{stopped}0 get/PDFScanRules .getuserparam//null eq{
//PDFScanRules_null{setuserparams}0 get}if/PDFsource PDFsource{store{stop}if}aload pop .packtomark cvx
/PDFsource 3 -1 roll store exec}bind def
currentdict/PDFScanRules_true undef
currentdict/PDFScanRules_null undef/pdf_run_resolve{/FileKey where{pop
2 copy computeobjkey dup 4 1 roll
PDFfile exch resolveopdict .decpdfrun
dup dup dup 5 2 roll{xcheck exch type/dicttype eq and
not{pop pop
exit}if
Trailer/Encrypt oget
dup/R oget dup 3 lt{pop pop/StreamKey exch put
exit}if
exch dup/EncryptMetadata knownoget
not{true}if
not{3 index/Type knownoget
not{//null}if/Metadata eq{pop pop pop pop
exit}if}if
exch 4 lt{pop/StreamKey exch put
exit}if/StmF knownoget
not{/Identity}if/Identity eq{pop pop
exit}if/StreamKey exch put
exit}loop}{PDFfile resolveopdict .pdfrun}ifelse}bind def/pdf_decrypt_stream{3 index/StreamKey known{exch
3 index/StreamKey get arc4decodefilter
exch}if}bind def
end
.setglobal
/currentglobal where{pop currentglobal{setglobal}true setglobal}{{}}ifelse/CFFStandardStrings mark
/.notdef/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright/parenleft/parenright/asterisk/plus/comma/hyphen
/period/slash/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon/less/equal/greater/question/at/A/B/C/D/E/F
/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i
/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/exclamdown/cent/sterling/fraction
/yen/florin/section/currency/quotesingle/quotedblleft/guillemotleft/guilsinglleft/guilsinglright/fi
/fl/endash/dagger/daggerdbl/periodcentered/paragraph/bullet/quotesinglbase/quotedblbase/quotedblright
/guillemotright/ellipsis/perthousand/questiondown/grave/acute/circumflex/tilde/macron/breve
/dotaccent/dieresis/ring/cedilla/hungarumlaut/ogonek/caron/emdash/AE/ordfeminine/Lslash/Oslash/OE/ordmasculine/ae
/dotlessi/lslash/oslash/oe/germandbls/onesuperior/logicalnot/mu/trademark/Eth/onehalf/plusminus/Thorn/onequarter/divide
/brokenbar/degree/thorn/threequarters/twosuperior/registered/minus/eth/multiply/threesuperior
/copyright/Aacute/Acircumflex/Adieresis/Agrave/Aring/Atilde/Ccedilla/Eacute/Ecircumflex
/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave/Ntilde/Oacute/Ocircumflex/Odieresis
/Ograve/Otilde/Scaron/Uacute/Ucircumflex/Udieresis/Ugrave/Yacute/Ydieresis/Zcaron/aacute/acircumflex/adieresis/agrave/aring
/atilde/ccedilla/eacute/ecircumflex/edieresis/egrave/iacute/icircumflex/idieresis/igrave
/ntilde/oacute/ocircumflex/odieresis/ograve/otilde/scaron/uacute/ucircumflex/udieresis
/ugrave/yacute/ydieresis/zcaron/exclamsmall/Hungarumlautsmall/dollaroldstyle/dollarsuperior/ampersandsmall/Acutesmall
/parenleftsuperior/parenrightsuperior/twodotenleader/onedotenleader/zerooldstyle
/oneoldstyle/twooldstyle/threeoldstyle/fouroldstyle/fiveoldstyle
/sixoldstyle/sevenoldstyle/eightoldstyle/nineoldstyle/commasuperior
/threequartersemdash/periodsuperior/questionsmall/asuperior/bsuperior/centsuperior/dsuperior/esuperior/isuperior/lsuperior
/msuperior/nsuperior/osuperior/rsuperior/ssuperior/tsuperior/ff/ffi/ffl/parenleftinferior
/parenrightinferior/Circumflexsmall/hyphensuperior/Gravesmall/Asmall/Bsmall/Csmall/Dsmall/Esmall/Fsmall
/Gsmall/Hsmall/Ismall/Jsmall/Ksmall/Lsmall/Msmall/Nsmall/Osmall/Psmall/Qsmall/Rsmall/Ssmall/Tsmall/Usmall
/Vsmall/Wsmall/Xsmall/Ysmall/Zsmall/colonmonetary/onefitted/rupiah/Tildesmall/exclamdownsmall
/centoldstyle/Lslashsmall/Scaronsmall/Zcaronsmall/Dieresissmall/Brevesmall/Caronsmall/Dotaccentsmall/Macronsmall/figuredash
/hypheninferior/Ogoneksmall/Ringsmall/Cedillasmall/questiondownsmall/oneeighth/threeeighths/fiveeighths/seveneighths/onethird
/twothirds/zerosuperior/foursuperior/fivesuperior/sixsuperior/sevensuperior/eightsuperior/ninesuperior/zeroinferior/oneinferior
/twoinferior/threeinferior/fourinferior/fiveinferior/sixinferior
/seveninferior/eightinferior/nineinferior/centinferior/dollarinferior
/periodinferior/commainferior/Agravesmall/Aacutesmall/Acircumflexsmall
/Atildesmall/Adieresissmall/Aringsmall/AEsmall/Ccedillasmall
/Egravesmall/Eacutesmall/Ecircumflexsmall/Edieresissmall/Igravesmall
/Iacutesmall/Icircumflexsmall/Idieresissmall/Ethsmall/Ntildesmall
/Ogravesmall/Oacutesmall/Ocircumflexsmall/Otildesmall/Odieresissmall
/OEsmall/Oslashsmall/Ugravesmall/Uacutesmall/Ucircumflexsmall/Udieresissmall/Yacutesmall/Thornsmall/Ydieresissmall
counttomark packedarray exch pop
10 1 index .registerencoding
.defineencoding
exec
/.scanfontheaders where{pop/.scanfontheaders[.scanfontheaders aload pop(OTTO*)]def}if
/.loadnonottofontfile/.loadfontfile load def/.loadfontfile{dup 4 string .peekstring pop(OTTO)eq{.init_otto_font_file
realtime rand xor =string cvs exch false
ReadData}{.loadnonottofontfile}ifelse}bind def/.init_otto_font_file{/FontSetInit/ProcSet findresource begin
2 dict begin/f exch def/cff null def
card32 pop card16 6{next pop}repeat dup{dup 0 eq{pop pop/.loadottofontfile cvx/invalidfont signalerror}if
f 4 string readstring pop(CFF )eq{sub exit}if
f 12 string readstring pop pop 1 sub}loop
card32 pop card32 card32
exch 3 -1 roll 1 add 16 mul 12 add sub
f exch subfilefilter flushfile
f exch subfilefilter end}bind def
30 dict begin/StandardStrings mark/CFFStandardStrings .findencoding aload pop(001.000)(001.001)(001.002)(001.003)/Black/Bold
/Book/Light/Medium/Regular/Roman/Semibold
.packtomark def/StandardEncodings[mark
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64
65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110
0 111 112 113 114 0 115 116 117 118 119 120 121 122 0 123
0 124 125 126 127 128 129 130 131 0 132 133 0 134 135 136
137 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 138 0 139 0 0 0 0 140 141 142 143 0 0 0 0
0 144 0 0 0 145 0 0 146 147 148 149 0 0 0 0
.packtomark
mark
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 229 230 0 231 232 233 234 235 236 237 238 13 14 15 99
239 240 241 242 243 244 245 246 247 248 27 28 249 250 251 252
0 253 254 255 256 257 0 0 0 258 0 0 259 260 261 262
0 0 263 264 265 0 266 109 110 267 268 269 0 270 271 272
273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288
289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 304 305 306 0 0 307 308 309 310 311 0 312 0 0 313
0 0 314 315 0 0 316 317 318 0 0 0 158 155 163 319
320 321 322 323 324 325 0 0 326 150 164 169 327 328 329 330
331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346
347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362
363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378
.packtomark]readonly def/StandardCharsets[mark
0
1 1 228{}for
.packtomark
mark
0
1 229 230 231 232 233 234 235 236 237 238 13 14 15 99 239
240 241 242 243 244 245 246 247 248 27 28 249 250 251 252 253
254 255 256 257 258 259 260 261 262 263 264 265 266 109 110 267
268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283
284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299
300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315
316 317 318 158 155 163 319 320 321 322 323 324 325 326 150 164
169 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341
342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357
358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373
374 375 376 377 378
.packtomark
mark
0
1 231 232 235 236 237 238 13 14 15 99 239 240 241 242 243
244 245 246 247 248 27 28 249 250 251 253 254 255 256 257 258
259 260 261 262 263 264 265 266 109 110 267 268 269 270 272 300
301 302 305 314 315 158 155 163 320 321 322 323 324 325 326 150
164 169 327 328 329 330 331 332 333 334 335 336 337 338 339 340
341 342 343 344 345 346
.packtomark]readonly def/advance{f cff eq{pos add/pos exch store}{pop}ifelse}bind def/next{f read{1 advance
CFFDEBUG{(  )print dup =}if}if}bind def/next2{f read{f read{2 advance
CFFDEBUG{(  )print 1 index =only(,)print dup =}if}{1 advance
CFFDEBUG{(  )print dup =}if}ifelse}if}bind def/nextstring{dup 0 eq{pop()}{string f exch readstring pop dup length advance
CFFDEBUG{(  )print dup ==}if}ifelse}bind def/card8/next load
def/card16{next2 exch 8 bitshift add}bind def/card32{card16 16 bitshift card16 add}bind def/offsetprocs[/card8 load/card16 load
{card8 16 bitshift card16 add}bind/card32 load]readonly def/offsetproc{1 sub//offsetprocs exch get}bind def/offset{
offsetproc exec}bind def/sid/card16 load
def/Index{CFFDEBUG{(% reading Index: )print dup =}if
mark card16 dup 0 ne{1 exch next offsetproc dup exec pop exch{dup exec dup 4 -1 roll sub 3 1 roll exch}repeat pop
}if pop .packtomark
CFFDEBUG{(% Index lengths = )print dup ===}if[exch{nextstring}forall]readonly}bind def/tokens{{f read not{12 exit}if
CFFDEBUG{(..)print dup =}if
1 advance
dup 12 eq{pop next 32 add exit}if
dup 28 lt{exit}if
dup 32 lt{28 sub{{card16 32768 xor 32768 sub}{4 offset dup 16#7fffffff gt{-1 32 bitshift add}if}{tokenreal}{31 exit}
}exch get exec}{dup 247 lt{139 sub}{247 sub{{next 108 add}{next 364 add}{next 620 add}{next 876 add}{next 108 add neg}
{next 364 add neg}{next 620 add neg}{next 876 add neg}}exch get exec}ifelse}ifelse}loop}bind def/tokenbuf 100 string def
/tokenput{dup length 3 1 roll
tokenbuf 2 index 3 -1 roll putinterval add}bind def/tokenrealarray[(0)(1)(2)(3)(4)(5)(6)(7)(8)(9)(.)(E)(E-)()(-){exit}bind
]readonly def/tokenreal{0{next exch 1 index -4 bitshift tokenrealarray exch get exec tokenput
1 index 15 and tokenrealarray exch get exec tokenput exch pop}loop
tokenbuf 0 3 -1 roll getinterval cvr exch pop}bind def/Dict{/opdict exch store{mark tokens
CFFDEBUG{(tokens: )print]dup === mark exch aload pop}if
opdict exch .knownget{exec}if cleartomark}loop cleartomark}bind def/idstring{
dup 391 lt{//StandardStrings}{391 sub strings}ifelse exch get}bind def/idname{idstring dup type/nametype ne{cvn}if}bind def
/subfilefilter{dup 0 le{pop pop()0}if()/SubFileDecode filter}bind def/offput{1 index 0 le
CFFDEBUG{dup{(not )print}if(queued: )print 2 index =only( )print 1 index ===}if{pop pop}
{currentdict exch aload length 1 add packedarray cvx
offsets 3 1 roll put}ifelse}bind def/queueput{16#7fffffff offsets{pop .min}forall
pos sub nextstring
3 1 roll aload length 2 add packedarray cvx[queued aload pop counttomark 2 add -1 roll]/queued exch store}bind def/printvk{
CFFDEBUG{(\t% )print dup =only( = )print 1 index ===}if}bind def/xxput{3 1 roll exch put}bind def/putfi{printvk FontInfo xxput
}bind def/xdef{exch def}bind def/pxdef{printvk xdef}bind def/topdictops mark
12{CFFDEBUG{(\t% EOD)=}if exit}0{idstring/version putfi}1{idstring/Notice putfi}32{idstring/Copyright putfi}
2{idstring/FullName putfi}3{idstring/FamilyName putfi}4{idstring/Weight putfi}33{0 ne/isFixedPitch putfi}34{/ItalicAngle putfi}
35{/UnderlinePosition putfi}36{/UnderlineThickness putfi}37{/PaintType pxdef}38{/FontType pxdef}
39{counttomark array astore/FontMatrix pxdef}13{/UniqueID pxdef}5{counttomark array astore/FontBBox pxdef}
40{/StrokeWidth pxdef}14{counttomark array astore/XUID pxdef}15{/charset printvk pop
dup StandardCharsets length lt{StandardCharsets exch get/charset xdef}{{queuecharset}offput}ifelse}16{/Encoding printvk pop
dup StandardEncodings length lt{/Encoding xdef}{{queueEncoding}offput}ifelse}17{{readCharStrings}offput}
18{exch/readPrivate cvx 2 packedarray offput}62{currentdict/FontType undef
currentdict/Encoding undef
currentdict/FontMatrix undef/CIDFontVersion 0 def/CIDFontRevision 0 def/CIDFontType 0 def/CIDCount 8720 def
3 dict begin/Supplement pxdef
idstring/Ordering pxdef
idstring/Registry pxdef/CIDSystemInfo currentdict end def}63{/CIDFontVersion pxdef}64{/CIDFontRevision pxdef}
65{/CIDFontType pxdef}66{/CIDCount pxdef}67{/UIDBase pxdef}68{{readFDArray}offput}69{{readFDSelect}offput}
70{{idstring}.internalstopped{pop pop}{/FontName pxdef}ifelse}.dicttomark readonly def/charstringcount{
/CharStringArray .knownget{length true}{16#7fffffff offsets{pop .min}forall
pos sub false}ifelse}bind def/readCharStrings{/CharStringArray Index put}bind def/charsetcount{
charstringcount{1 sub}{2 idiv}ifelse}bind def/charsetformats[{[0 3 -1 roll charsetcount{sid}repeat]}bind
{[0 3 -1 roll charsetcount{dup 0 eq{pop exit}if
sid card8 1 add 2 index .min{exch 1 sub 1 index 1 add}repeat pop}loop]}bind{[0 3 -1 roll charsetcount{dup 0 eq{pop exit}if
sid card16 1 add 2 index .min{exch 1 sub 1 index 1 add}repeat pop}loop]}bind]readonly def/queuecharset{{readcharset}queueput
}bind def/readcharset{begin 0()/SubFileDecode filter/f exch store
charsetformats next get currentdict exch exec/charset exch def end}bind def/encodingformats[
{1 1 next{next exch Encoding 3 1 roll put}for}bind{1 next{next next 1 add{Encoding 1 index 3 index put
exch 1 add exch 1 add}repeat pop}repeat pop}bind]readonly def/queueEncoding{{readEncoding}queueput}bind def/readEncoding{
begin 0()/SubFileDecode filter/f exch store/Encoding[256{/.notdef}repeat]def
next encodingformats 1 index 127 and get exec
128 ge{next{Encoding next sid idname put}repeat}if end}bind def/readFDArray{/FDarray Index exch pop exch
2 dict begin/f null def begin[exch{dup length subfilefilter/f exch store
10 dict begin/FontType 2 def/PaintType 0 def/FontMatrix[0.001 0 0 0.001 0 0]def/Private 20 dict def
//topdictops Dict currentdict end}forall]/FDArray xdef end end}bind def/fdselectformats[
{[exch charstringcount pop{card8}repeat]}bind{/FDSelect cvx/invalidfont signalerror}bind
dup{pop 65535 array card16 card16 exch{card8 card16
exch 1 index 4 -1 roll
exch 1 exch 1 sub{3 index exch 2 index put}for pop}repeat
0 exch getinterval}bind]readonly def/readFDSelect{begin fdselectformats next get currentdict exch exec/FDSelect exch def end
}bind def/deltarray{0 counttomark 1 sub{counttomark -1 roll add dup}repeat pop
counttomark array astore}bind def/privatedictops mark
12{CFFDEBUG{(\t% EOD)=}if exit}6{deltarray/BlueValues pxdef}7{deltarray/OtherBlues pxdef}8{deltarray/FamilyBlues pxdef}
9{deltarray/FamilyOtherBlues pxdef}41{/BlueScale pxdef}42{/BlueShift pxdef}43{/BlueFuzz pxdef}10{1 array astore/StdHW pxdef}
11{1 array astore/StdVW pxdef}44{deltarray/StemSnapH pxdef}45{deltarray/StemSnapV pxdef}46{0 ne/ForceBold pxdef}
47{/ForceBoldThreshold pxdef}48{/lenIV pxdef}49{/LanguageGroup pxdef}50{/ExpansionFactor pxdef}51{/initialRandomSeed pxdef}
19{PrivateStart add{readSubrs}offput}20{/defaultWidthX pxdef}21{/nominalWidthX pxdef}59{/NDV pxdef}60{/CDV pxdef}
61{/lenBuildCharArray pxdef}.dicttomark readonly def/readPrivate{2 dict begin/PrivateStart pos def
f 3 1 roll exch 1 index f exch subfilefilter/f exch store
dup/FontType get exch/Private get begin
2 ne{/lenIV -1 def}if//privatedictops Dict end
exch/f exch store advance
end}bind def/readSubrs{/Subrs Index put}bind def/cleanupFont{currentdict/charset undef
currentdict/CharStringArray undef}bind def/finishFont{/Encoding mark Encoding
CFFDEBUG{(Encoding: )print dup === flush}if
dup type/integertype eq{StandardEncodings exch get{idname}forall}{{dup type/integertype eq{charset exch get idname}if}forall
}ifelse .packtomark def/CharStrings charset length CharStringArray length .min dict def
CFFDEBUG{charset length =only( charset )print
CharStringArray length =only( CharStringArray)=
charset == flush}if
0 1 CharStrings maxlength 1 sub{dup CharStringArray exch get
exch charset exch get idstring CharStrings xxput}for
cleanupFont}bind def/finishCIDFont{/FDBytes FDArray length 1 gt{1}{0}ifelse def
/GlyphDirectory charset length CharStringArray length .min dict def
CFFDEBUG{charset length =only( charset )print
CharStringArray length =only( CharStringArray)=
charset == flush}if
0 1 GlyphDirectory maxlength 1 sub{dup CharStringArray exch get
FDBytes 1 eq{FDSelect 2 index get
1 string dup 0 4 -1 roll put exch concatstrings}if
exch charset exch get GlyphDirectory xxput}for
Private/GlobalSubrs .knownget{FDArray{/Private get/GlobalSubrs 2 index put}forall
pop
Private/GlobalSubrs undef}if
currentdict/FDSelect undef
cleanupFont}bind def/StartData{currentfile exch subfilefilter false ReadData}bind def/ReadData{30 dict begin
/forceresname exch def/cff exch def/pos 0 def/resname exch cvlit def/DEBUG CFFDEBUG def/f cff def/vmajor next def
/vminor next def/hdrsize next def/aoffsize next def
hdrsize 4 gt{hdrsize 4 sub dup advance
f exch()/SubFileDecode filter flushfile}if/names Index def/topdicts Index def/strings Index def/gsubrs Index def
/offsets 50 dict def/queued[]def/opdict null def/fonts[topdicts{0()/SubFileDecode filter/f exch def
40 dict begin/FontType 2 def/PaintType 0 def/FontMatrix[0.001 0 0 0.001 0 0]def/charset StandardCharsets 0 get def
/Encoding 0 def/FontInfo 10 dict
dup/UnderlinePosition -100 put
dup/UnderlineThickness 50 put
def/Private 20 dict
gsubrs length 0 ne{dup/GlobalSubrs gsubrs put}if
def//topdictops Dict
currentdict end}forall]def{CFFDEBUG{(offsets: )print[offsets{pop}forall]==}if[offsets{pop}forall]{lt}.sort{/f cff def
CFFDEBUG{(queued offset: )print dup =print flush(, current pos=)print pos =}if
dup pos ne{dup pos sub nextstring pop}if
offsets exch 2 copy get 3 1 roll undef
CFFDEBUG{(exec queued: )print dup ==}if
exec}forall
offsets length 0 eq{exit}if}loop
CFFDEBUG{queued length =only( queued)= flush}if
queued{exec}forall
fonts{begin
currentdict/CIDFontType known{finishCIDFont}{finishFont}ifelse
end}forall
resname mark 0 1 fonts length 1 sub{CFFDEBUG{dup =only( )print flush}if
dup names exch get
forceresname{pop resname}if
CFFDEBUG{dup == flush}if
exch fonts exch get
dup/CIDFontType known{dup/CIDFontName 3 index put
1 index exch/CIDFont defineresource}{dup/FontName 3 index put
1 index exch definefont}ifelse}for .dicttomark
end
end/FontSet defineresource pop}bind def
currentdict end readonly
languagelevel exch 2 .setlanguagelevel/FontSet/Generic/Category findresource dup length dict .copydict
/Category defineresource pop/FontSetInit exch/ProcSet defineresource pop
.setlanguagelevel
/currentglobal where{pop currentglobal{setglobal}true setglobal}{{}}ifelse/MacRomanEncoding .findencoding/MacGlyphEncoding
/.notdef/.null/CR
4 index 32 95 getinterval aload pop
99 index 128 45 getinterval aload pop/notequal/AE/Oslash/infinity/plusminus/lessequal/greaterequal
/yen/mu1/partialdiff/summation/product/pi/integral/ordfeminine/ordmasculine/Ohm/ae/oslash/questiondown/exclamdown/logicalnot
/radical/florin/approxequal/increment/guillemotleft/guillemotright/ellipsis/nbspace
174 index 203 12 getinterval aload pop/lozenge
187 index 216 24 getinterval aload pop/applelogo
212 index 241 7 getinterval aload pop/overscore
220 index 249 7 getinterval aload pop/Lslash/lslash/Scaron/scaron/Zcaron/zcaron/brokenbar/Eth/eth
/Yacute/yacute/Thorn/thorn/minus/multiply/onesuperior/twosuperior/threesuperior/onehalf
/onequarter/threequarters/franc/Gbreve/gbreve/Idotaccent/Scedilla/scedilla/Cacute/cacute/Ccaron/ccaron/dmacron
260 -1 roll pop
258 packedarray
7 1 index .registerencoding
.defineencoding
exec
/AdobeGlyphList 1500 dict
dup/A 16#0041 put
dup/AE 16#00C6 put
dup/AEacute 16#01FC put
dup/AEsmall 16#F7E6 put
dup/Aacute 16#00C1 put
dup/Aacutesmall 16#F7E1 put
dup/Abreve 16#0102 put
dup/Acircumflex 16#00C2 put
dup/Acircumflexsmall 16#F7E2 put
dup/Acute 16#F6C9 put
dup/Acutesmall 16#F7B4 put
dup/Adieresis 16#00C4 put
dup/Adieresissmall 16#F7E4 put
dup/Agrave 16#00C0 put
dup/Agravesmall 16#F7E0 put
dup/Alpha 16#0391 put
dup/Alphatonos 16#0386 put
dup/Amacron 16#0100 put
dup/Aogonek 16#0104 put
dup/Aring 16#00C5 put
dup/Aringacute 16#01FA put
dup/Aringsmall 16#F7E5 put
dup/Asmall 16#F761 put
dup/Atilde 16#00C3 put
dup/Atildesmall 16#F7E3 put
dup/B 16#0042 put
dup/Beta 16#0392 put
dup/Brevesmall 16#F6F4 put
dup/Bsmall 16#F762 put
dup/C 16#0043 put
dup/Cacute 16#0106 put
dup/Caron 16#F6CA put
dup/Caronsmall 16#F6F5 put
dup/Ccaron 16#010C put
dup/Ccedilla 16#00C7 put
dup/Ccedillasmall 16#F7E7 put
dup/Ccircumflex 16#0108 put
dup/Cdotaccent 16#010A put
dup/Cedillasmall 16#F7B8 put
dup/Chi 16#03A7 put
dup/Circumflexsmall 16#F6F6 put
dup/Csmall 16#F763 put
dup/D 16#0044 put
dup/Dcaron 16#010E put
dup/Dcroat 16#0110 put
dup/Delta[16#2206 16#0394]put
dup/Dieresis 16#F6CB put
dup/DieresisAcute 16#F6CC put
dup/DieresisGrave 16#F6CD put
dup/Dieresissmall 16#F7A8 put
dup/Dotaccentsmall 16#F6F7 put
dup/Dsmall 16#F764 put
dup/E 16#0045 put
dup/Eacute 16#00C9 put
dup/Eacutesmall 16#F7E9 put
dup/Ebreve 16#0114 put
dup/Ecaron 16#011A put
dup/Ecircumflex 16#00CA put
dup/Ecircumflexsmall 16#F7EA put
dup/Edieresis 16#00CB put
dup/Edieresissmall 16#F7EB put
dup/Edotaccent 16#0116 put
dup/Egrave 16#00C8 put
dup/Egravesmall 16#F7E8 put
dup/Emacron 16#0112 put
dup/Eng 16#014A put
dup/Eogonek 16#0118 put
dup/Epsilon 16#0395 put
dup/Epsilontonos 16#0388 put
dup/Esmall 16#F765 put
dup/Eta 16#0397 put
dup/Etatonos 16#0389 put
dup/Eth 16#00D0 put
dup/Ethsmall 16#F7F0 put
dup/Euro 16#20AC put
dup/F 16#0046 put
dup/Fsmall 16#F766 put
dup/G 16#0047 put
dup/Gamma 16#0393 put
dup/Gbreve 16#011E put
dup/Gcaron 16#01E6 put
dup/Gcircumflex 16#011C put
dup/Gcommaaccent 16#0122 put
dup/Gdotaccent 16#0120 put
dup/Grave 16#F6CE put
dup/Gravesmall 16#F760 put
dup/Gsmall 16#F767 put
dup/H 16#0048 put
dup/H18533 16#25CF put
dup/H18543 16#25AA put
dup/H18551 16#25AB put
dup/H22073 16#25A1 put
dup/Hbar 16#0126 put
dup/Hcircumflex 16#0124 put
dup/Hsmall 16#F768 put
dup/Hungarumlaut 16#F6CF put
dup/Hungarumlautsmall 16#F6F8 put
dup/I 16#0049 put
dup/IJ 16#0132 put
dup/Iacute 16#00CD put
dup/Iacutesmall 16#F7ED put
dup/Ibreve 16#012C put
dup/Icircumflex 16#00CE put
dup/Icircumflexsmall 16#F7EE put
dup/Idieresis 16#00CF put
dup/Idieresissmall 16#F7EF put
dup/Idotaccent 16#0130 put
dup/Ifraktur 16#2111 put
dup/Igrave 16#00CC put
dup/Igravesmall 16#F7EC put
dup/Imacron 16#012A put
dup/Iogonek 16#012E put
dup/Iota 16#0399 put
dup/Iotadieresis 16#03AA put
dup/Iotatonos 16#038A put
dup/Ismall 16#F769 put
dup/Itilde 16#0128 put
dup/J 16#004A put
dup/Jcircumflex 16#0134 put
dup/Jsmall 16#F76A put
dup/K 16#004B put
dup/Kappa 16#039A put
dup/Kcommaaccent 16#0136 put
dup/Ksmall 16#F76B put
dup/L 16#004C put
dup/LL 16#F6BF put
dup/Lacute 16#0139 put
dup/Lambda 16#039B put
dup/Lcaron 16#013D put
dup/Lcommaaccent 16#013B put
dup/Ldot 16#013F put
dup/Lslash 16#0141 put
dup/Lslashsmall 16#F6F9 put
dup/Lsmall 16#F76C put
dup/M 16#004D put
dup/Macron 16#F6D0 put
dup/Macronsmall 16#F7AF put
dup/Msmall 16#F76D put
dup/Mu 16#039C put
dup/N 16#004E put
dup/Nacute 16#0143 put
dup/Ncaron 16#0147 put
dup/Ncommaaccent 16#0145 put
dup/Nsmall 16#F76E put
dup/Ntilde 16#00D1 put
dup/Ntildesmall 16#F7F1 put
dup/Nu 16#039D put
dup/O 16#004F put
dup/OE 16#0152 put
dup/OEsmall 16#F6FA put
dup/Oacute 16#00D3 put
dup/Oacutesmall 16#F7F3 put
dup/Obreve 16#014E put
dup/Ocircumflex 16#00D4 put
dup/Ocircumflexsmall 16#F7F4 put
dup/Odieresis 16#00D6 put
dup/Odieresissmall 16#F7F6 put
dup/Ogoneksmall 16#F6FB put
dup/Ograve 16#00D2 put
dup/Ogravesmall 16#F7F2 put
dup/Ohorn 16#01A0 put
dup/Ohungarumlaut 16#0150 put
dup/Omacron 16#014C put
dup/Omega[16#2126 16#03A9]put
dup/Omegatonos 16#038F put
dup/Omicron 16#039F put
dup/Omicrontonos 16#038C put
dup/Oslash 16#00D8 put
dup/Oslashacute 16#01FE put
dup/Oslashsmall 16#F7F8 put
dup/Osmall 16#F76F put
dup/Otilde 16#00D5 put
dup/Otildesmall 16#F7F5 put
dup/P 16#0050 put
dup/Phi 16#03A6 put
dup/Pi 16#03A0 put
dup/Psi 16#03A8 put
dup/Psmall 16#F770 put
dup/Q 16#0051 put
dup/Qsmall 16#F771 put
dup/R 16#0052 put
dup/Racute 16#0154 put
dup/Rcaron 16#0158 put
dup/Rcommaaccent 16#0156 put
dup/Rfraktur 16#211C put
dup/Rho 16#03A1 put
dup/Ringsmall 16#F6FC put
dup/Rsmall 16#F772 put
dup/S 16#0053 put
dup/SF010000 16#250C put
dup/SF020000 16#2514 put
dup/SF030000 16#2510 put
dup/SF040000 16#2518 put
dup/SF050000 16#253C put
dup/SF060000 16#252C put
dup/SF070000 16#2534 put
dup/SF080000 16#251C put
dup/SF090000 16#2524 put
dup/SF100000 16#2500 put
dup/SF110000 16#2502 put
dup/SF190000 16#2561 put
dup/SF200000 16#2562 put
dup/SF210000 16#2556 put
dup/SF220000 16#2555 put
dup/SF230000 16#2563 put
dup/SF240000 16#2551 put
dup/SF250000 16#2557 put
dup/SF260000 16#255D put
dup/SF270000 16#255C put
dup/SF280000 16#255B put
dup/SF360000 16#255E put
dup/SF370000 16#255F put
dup/SF380000 16#255A put
dup/SF390000 16#2554 put
dup/SF400000 16#2569 put
dup/SF410000 16#2566 put
dup/SF420000 16#2560 put
dup/SF430000 16#2550 put
dup/SF440000 16#256C put
dup/SF450000 16#2567 put
dup/SF460000 16#2568 put
dup/SF470000 16#2564 put
dup/SF480000 16#2565 put
dup/SF490000 16#2559 put
dup/SF500000 16#2558 put
dup/SF510000 16#2552 put
dup/SF520000 16#2553 put
dup/SF530000 16#256B put
dup/SF540000 16#256A put
dup/Sacute 16#015A put
dup/Scaron 16#0160 put
dup/Scaronsmall 16#F6FD put
dup/Scedilla[16#015E 16#F6C1]put
dup/Scircumflex 16#015C put
dup/Scommaaccent 16#0218 put
dup/Sigma 16#03A3 put
dup/Ssmall 16#F773 put
dup/T 16#0054 put
dup/Tau 16#03A4 put
dup/Tbar 16#0166 put
dup/Tcaron 16#0164 put
dup/Tcommaaccent[16#0162 16#021A]put
dup/Theta 16#0398 put
dup/Thorn 16#00DE put
dup/Thornsmall 16#F7FE put
dup/Tildesmall 16#F6FE put
dup/Tsmall 16#F774 put
dup/U 16#0055 put
dup/Uacute 16#00DA put
dup/Uacutesmall 16#F7FA put
dup/Ubreve 16#016C put
dup/Ucircumflex 16#00DB put
dup/Ucircumflexsmall 16#F7FB put
dup/Udieresis 16#00DC put
dup/Udieresissmall 16#F7FC put
dup/Ugrave 16#00D9 put
dup/Ugravesmall 16#F7F9 put
dup/Uhorn 16#01AF put
dup/Uhungarumlaut 16#0170 put
dup/Umacron 16#016A put
dup/Uogonek 16#0172 put
dup/Upsilon 16#03A5 put
dup/Upsilon1 16#03D2 put
dup/Upsilondieresis 16#03AB put
dup/Upsilontonos 16#038E put
dup/Uring 16#016E put
dup/Usmall 16#F775 put
dup/Utilde 16#0168 put
dup/V 16#0056 put
dup/Vsmall 16#F776 put
dup/W 16#0057 put
dup/Wacute 16#1E82 put
dup/Wcircumflex 16#0174 put
dup/Wdieresis 16#1E84 put
dup/Wgrave 16#1E80 put
dup/Wsmall 16#F777 put
dup/X 16#0058 put
dup/Xi 16#039E put
dup/Xsmall 16#F778 put
dup/Y 16#0059 put
dup/Yacute 16#00DD put
dup/Yacutesmall 16#F7FD put
dup/Ycircumflex 16#0176 put
dup/Ydieresis 16#0178 put
dup/Ydieresissmall 16#F7FF put
dup/Ygrave 16#1EF2 put
dup/Ysmall 16#F779 put
dup/Z 16#005A put
dup/Zacute 16#0179 put
dup/Zcaron 16#017D put
dup/Zcaronsmall 16#F6FF put
dup/Zdotaccent 16#017B put
dup/Zeta 16#0396 put
dup/Zsmall 16#F77A put
dup/a 16#0061 put
dup/aacute 16#00E1 put
dup/abreve 16#0103 put
dup/acircumflex 16#00E2 put
dup/acute 16#00B4 put
dup/acutecomb 16#0301 put
dup/adieresis 16#00E4 put
dup/ae 16#00E6 put
dup/aeacute 16#01FD put
dup/afii00208 16#2015 put
dup/afii10017 16#0410 put
dup/afii10018 16#0411 put
dup/afii10019 16#0412 put
dup/afii10020 16#0413 put
dup/afii10021 16#0414 put
dup/afii10022 16#0415 put
dup/afii10023 16#0401 put
dup/afii10024 16#0416 put
dup/afii10025 16#0417 put
dup/afii10026 16#0418 put
dup/afii10027 16#0419 put
dup/afii10028 16#041A put
dup/afii10029 16#041B put
dup/afii10030 16#041C put
dup/afii10031 16#041D put
dup/afii10032 16#041E put
dup/afii10033 16#041F put
dup/afii10034 16#0420 put
dup/afii10035 16#0421 put
dup/afii10036 16#0422 put
dup/afii10037 16#0423 put
dup/afii10038 16#0424 put
dup/afii10039 16#0425 put
dup/afii10040 16#0426 put
dup/afii10041 16#0427 put
dup/afii10042 16#0428 put
dup/afii10043 16#0429 put
dup/afii10044 16#042A put
dup/afii10045 16#042B put
dup/afii10046 16#042C put
dup/afii10047 16#042D put
dup/afii10048 16#042E put
dup/afii10049 16#042F put
dup/afii10050 16#0490 put
dup/afii10051 16#0402 put
dup/afii10052 16#0403 put
dup/afii10053 16#0404 put
dup/afii10054 16#0405 put
dup/afii10055 16#0406 put
dup/afii10056 16#0407 put
dup/afii10057 16#0408 put
dup/afii10058 16#0409 put
dup/afii10059 16#040A put
dup/afii10060 16#040B put
dup/afii10061 16#040C put
dup/afii10062 16#040E put
dup/afii10063 16#F6C4 put
dup/afii10064 16#F6C5 put
dup/afii10065 16#0430 put
dup/afii10066 16#0431 put
dup/afii10067 16#0432 put
dup/afii10068 16#0433 put
dup/afii10069 16#0434 put
dup/afii10070 16#0435 put
dup/afii10071 16#0451 put
dup/afii10072 16#0436 put
dup/afii10073 16#0437 put
dup/afii10074 16#0438 put
dup/afii10075 16#0439 put
dup/afii10076 16#043A put
dup/afii10077 16#043B put
dup/afii10078 16#043C put
dup/afii10079 16#043D put
dup/afii10080 16#043E put
dup/afii10081 16#043F put
dup/afii10082 16#0440 put
dup/afii10083 16#0441 put
dup/afii10084 16#0442 put
dup/afii10085 16#0443 put
dup/afii10086 16#0444 put
dup/afii10087 16#0445 put
dup/afii10088 16#0446 put
dup/afii10089 16#0447 put
dup/afii10090 16#0448 put
dup/afii10091 16#0449 put
dup/afii10092 16#044A put
dup/afii10093 16#044B put
dup/afii10094 16#044C put
dup/afii10095 16#044D put
dup/afii10096 16#044E put
dup/afii10097 16#044F put
dup/afii10098 16#0491 put
dup/afii10099 16#0452 put
dup/afii10100 16#0453 put
dup/afii10101 16#0454 put
dup/afii10102 16#0455 put
dup/afii10103 16#0456 put
dup/afii10104 16#0457 put
dup/afii10105 16#0458 put
dup/afii10106 16#0459 put
dup/afii10107 16#045A put
dup/afii10108 16#045B put
dup/afii10109 16#045C put
dup/afii10110 16#045E put
dup/afii10145 16#040F put
dup/afii10146 16#0462 put
dup/afii10147 16#0472 put
dup/afii10148 16#0474 put
dup/afii10192 16#F6C6 put
dup/afii10193 16#045F put
dup/afii10194 16#0463 put
dup/afii10195 16#0473 put
dup/afii10196 16#0475 put
dup/afii10831 16#F6C7 put
dup/afii10832 16#F6C8 put
dup/afii10846 16#04D9 put
dup/afii299 16#200E put
dup/afii300 16#200F put
dup/afii301 16#200D put
dup/afii57381 16#066A put
dup/afii57388 16#060C put
dup/afii57392 16#0660 put
dup/afii57393 16#0661 put
dup/afii57394 16#0662 put
dup/afii57395 16#0663 put
dup/afii57396 16#0664 put
dup/afii57397 16#0665 put
dup/afii57398 16#0666 put
dup/afii57399 16#0667 put
dup/afii57400 16#0668 put
dup/afii57401 16#0669 put
dup/afii57403 16#061B put
dup/afii57407 16#061F put
dup/afii57409 16#0621 put
dup/afii57410 16#0622 put
dup/afii57411 16#0623 put
dup/afii57412 16#0624 put
dup/afii57413 16#0625 put
dup/afii57414 16#0626 put
dup/afii57415 16#0627 put
dup/afii57416 16#0628 put
dup/afii57417 16#0629 put
dup/afii57418 16#062A put
dup/afii57419 16#062B put
dup/afii57420 16#062C put
dup/afii57421 16#062D put
dup/afii57422 16#062E put
dup/afii57423 16#062F put
dup/afii57424 16#0630 put
dup/afii57425 16#0631 put
dup/afii57426 16#0632 put
dup/afii57427 16#0633 put
dup/afii57428 16#0634 put
dup/afii57429 16#0635 put
dup/afii57430 16#0636 put
dup/afii57431 16#0637 put
dup/afii57432 16#0638 put
dup/afii57433 16#0639 put
dup/afii57434 16#063A put
dup/afii57440 16#0640 put
dup/afii57441 16#0641 put
dup/afii57442 16#0642 put
dup/afii57443 16#0643 put
dup/afii57444 16#0644 put
dup/afii57445 16#0645 put
dup/afii57446 16#0646 put
dup/afii57448 16#0648 put
dup/afii57449 16#0649 put
dup/afii57450 16#064A put
dup/afii57451 16#064B put
dup/afii57452 16#064C put
dup/afii57453 16#064D put
dup/afii57454 16#064E put
dup/afii57455 16#064F put
dup/afii57456 16#0650 put
dup/afii57457 16#0651 put
dup/afii57458 16#0652 put
dup/afii57470 16#0647 put
dup/afii57505 16#06A4 put
dup/afii57506 16#067E put
dup/afii57507 16#0686 put
dup/afii57508 16#0698 put
dup/afii57509 16#06AF put
dup/afii57511 16#0679 put
dup/afii57512 16#0688 put
dup/afii57513 16#0691 put
dup/afii57514 16#06BA put
dup/afii57519 16#06D2 put
dup/afii57534 16#06D5 put
dup/afii57636 16#20AA put
dup/afii57645 16#05BE put
dup/afii57658 16#05C3 put
dup/afii57664 16#05D0 put
dup/afii57665 16#05D1 put
dup/afii57666 16#05D2 put
dup/afii57667 16#05D3 put
dup/afii57668 16#05D4 put
dup/afii57669 16#05D5 put
dup/afii57670 16#05D6 put
dup/afii57671 16#05D7 put
dup/afii57672 16#05D8 put
dup/afii57673 16#05D9 put
dup/afii57674 16#05DA put
dup/afii57675 16#05DB put
dup/afii57676 16#05DC put
dup/afii57677 16#05DD put
dup/afii57678 16#05DE put
dup/afii57679 16#05DF put
dup/afii57680 16#05E0 put
dup/afii57681 16#05E1 put
dup/afii57682 16#05E2 put
dup/afii57683 16#05E3 put
dup/afii57684 16#05E4 put
dup/afii57685 16#05E5 put
dup/afii57686 16#05E6 put
dup/afii57687 16#05E7 put
dup/afii57688 16#05E8 put
dup/afii57689 16#05E9 put
dup/afii57690 16#05EA put
dup/afii57694 16#FB2A put
dup/afii57695 16#FB2B put
dup/afii57700 16#FB4B put
dup/afii57705 16#FB1F put
dup/afii57716 16#05F0 put
dup/afii57717 16#05F1 put
dup/afii57718 16#05F2 put
dup/afii57723 16#FB35 put
dup/afii57793 16#05B4 put
dup/afii57794 16#05B5 put
dup/afii57795 16#05B6 put
dup/afii57796 16#05BB put
dup/afii57797 16#05B8 put
dup/afii57798 16#05B7 put
dup/afii57799 16#05B0 put
dup/afii57800 16#05B2 put
dup/afii57801 16#05B1 put
dup/afii57802 16#05B3 put
dup/afii57803 16#05C2 put
dup/afii57804 16#05C1 put
dup/afii57806 16#05B9 put
dup/afii57807 16#05BC put
dup/afii57839 16#05BD put
dup/afii57841 16#05BF put
dup/afii57842 16#05C0 put
dup/afii57929 16#02BC put
dup/afii61248 16#2105 put
dup/afii61289 16#2113 put
dup/afii61352 16#2116 put
dup/afii61573 16#202C put
dup/afii61574 16#202D put
dup/afii61575 16#202E put
dup/afii61664 16#200C put
dup/afii63167 16#066D put
dup/afii64937 16#02BD put
dup/agrave 16#00E0 put
dup/aleph 16#2135 put
dup/alpha 16#03B1 put
dup/alphatonos 16#03AC put
dup/amacron 16#0101 put
dup/ampersand 16#0026 put
dup/ampersandsmall 16#F726 put
dup/angle 16#2220 put
dup/angleleft 16#2329 put
dup/angleright 16#232A put
dup/anoteleia 16#0387 put
dup/aogonek 16#0105 put
dup/approxequal 16#2248 put
dup/aring 16#00E5 put
dup/aringacute 16#01FB put
dup/arrowboth 16#2194 put
dup/arrowdblboth 16#21D4 put
dup/arrowdbldown 16#21D3 put
dup/arrowdblleft 16#21D0 put
dup/arrowdblright 16#21D2 put
dup/arrowdblup 16#21D1 put
dup/arrowdown 16#2193 put
dup/arrowhorizex 16#F8E7 put
dup/arrowleft 16#2190 put
dup/arrowright 16#2192 put
dup/arrowup 16#2191 put
dup/arrowupdn 16#2195 put
dup/arrowupdnbse 16#21A8 put
dup/arrowvertex 16#F8E6 put
dup/asciicircum 16#005E put
dup/asciitilde 16#007E put
dup/asterisk 16#002A put
dup/asteriskmath 16#2217 put
dup/asuperior 16#F6E9 put
dup/at 16#0040 put
dup/atilde 16#00E3 put
dup/b 16#0062 put
dup/backslash 16#005C put
dup/bar 16#007C put
dup/beta 16#03B2 put
dup/block 16#2588 put
dup/braceex 16#F8F4 put
dup/braceleft 16#007B put
dup/braceleftbt 16#F8F3 put
dup/braceleftmid 16#F8F2 put
dup/bracelefttp 16#F8F1 put
dup/braceright 16#007D put
dup/bracerightbt 16#F8FE put
dup/bracerightmid 16#F8FD put
dup/bracerighttp 16#F8FC put
dup/bracketleft 16#005B put
dup/bracketleftbt 16#F8F0 put
dup/bracketleftex 16#F8EF put
dup/bracketlefttp 16#F8EE put
dup/bracketright 16#005D put
dup/bracketrightbt 16#F8FB put
dup/bracketrightex 16#F8FA put
dup/bracketrighttp 16#F8F9 put
dup/breve 16#02D8 put
dup/brokenbar 16#00A6 put
dup/bsuperior 16#F6EA put
dup/bullet 16#2022 put
dup/c 16#0063 put
dup/cacute 16#0107 put
dup/caron 16#02C7 put
dup/carriagereturn 16#21B5 put
dup/ccaron 16#010D put
dup/ccedilla 16#00E7 put
dup/ccircumflex 16#0109 put
dup/cdotaccent 16#010B put
dup/cedilla 16#00B8 put
dup/cent 16#00A2 put
dup/centinferior 16#F6DF put
dup/centoldstyle 16#F7A2 put
dup/centsuperior 16#F6E0 put
dup/chi 16#03C7 put
dup/circle 16#25CB put
dup/circlemultiply 16#2297 put
dup/circleplus 16#2295 put
dup/circumflex 16#02C6 put
dup/club 16#2663 put
dup/colon 16#003A put
dup/colonmonetary 16#20A1 put
dup/comma 16#002C put
dup/commaaccent 16#F6C3 put
dup/commainferior 16#F6E1 put
dup/commasuperior 16#F6E2 put
dup/congruent 16#2245 put
dup/copyright 16#00A9 put
dup/copyrightsans 16#F8E9 put
dup/copyrightserif 16#F6D9 put
dup/currency 16#00A4 put
dup/cyrBreve 16#F6D1 put
dup/cyrFlex 16#F6D2 put
dup/cyrbreve 16#F6D4 put
dup/cyrflex 16#F6D5 put
dup/d 16#0064 put
dup/dagger 16#2020 put
dup/daggerdbl 16#2021 put
dup/dblGrave 16#F6D3 put
dup/dblgrave 16#F6D6 put
dup/dcaron 16#010F put
dup/dcroat 16#0111 put
dup/degree 16#00B0 put
dup/delta 16#03B4 put
dup/diamond 16#2666 put
dup/dieresis 16#00A8 put
dup/dieresisacute 16#F6D7 put
dup/dieresisgrave 16#F6D8 put
dup/dieresistonos 16#0385 put
dup/divide 16#00F7 put
dup/dkshade 16#2593 put
dup/dnblock 16#2584 put
dup/dollar 16#0024 put
dup/dollarinferior 16#F6E3 put
dup/dollaroldstyle 16#F724 put
dup/dollarsuperior 16#F6E4 put
dup/dong 16#20AB put
dup/dotaccent 16#02D9 put
dup/dotbelowcomb 16#0323 put
dup/dotlessi 16#0131 put
dup/dotlessj 16#F6BE put
dup/dotmath 16#22C5 put
dup/dsuperior 16#F6EB put
dup/e 16#0065 put
dup/eacute 16#00E9 put
dup/ebreve 16#0115 put
dup/ecaron 16#011B put
dup/ecircumflex 16#00EA put
dup/edieresis 16#00EB put
dup/edotaccent 16#0117 put
dup/egrave 16#00E8 put
dup/eight 16#0038 put
dup/eightinferior 16#2088 put
dup/eightoldstyle 16#F738 put
dup/eightsuperior 16#2078 put
dup/element 16#2208 put
dup/ellipsis 16#2026 put
dup/emacron 16#0113 put
dup/emdash 16#2014 put
dup/emptyset 16#2205 put
dup/endash 16#2013 put
dup/eng 16#014B put
dup/eogonek 16#0119 put
dup/epsilon 16#03B5 put
dup/epsilontonos 16#03AD put
dup/equal 16#003D put
dup/equivalence 16#2261 put
dup/estimated 16#212E put
dup/esuperior 16#F6EC put
dup/eta 16#03B7 put
dup/etatonos 16#03AE put
dup/eth 16#00F0 put
dup/exclam 16#0021 put
dup/exclamdbl 16#203C put
dup/exclamdown 16#00A1 put
dup/exclamdownsmall 16#F7A1 put
dup/exclamsmall 16#F721 put
dup/existential 16#2203 put
dup/f 16#0066 put
dup/female 16#2640 put
dup/ff 16#FB00 put
dup/ffi 16#FB03 put
dup/ffl 16#FB04 put
dup/fi 16#FB01 put
dup/figuredash 16#2012 put
dup/filledbox 16#25A0 put
dup/filledrect 16#25AC put
dup/five 16#0035 put
dup/fiveeighths 16#215D put
dup/fiveinferior 16#2085 put
dup/fiveoldstyle 16#F735 put
dup/fivesuperior 16#2075 put
dup/fl 16#FB02 put
dup/florin 16#0192 put
dup/four 16#0034 put
dup/fourinferior 16#2084 put
dup/fouroldstyle 16#F734 put
dup/foursuperior 16#2074 put
dup/fraction[16#2044 16#2215]put
dup/franc 16#20A3 put
dup/g 16#0067 put
dup/gamma 16#03B3 put
dup/gbreve 16#011F put
dup/gcaron 16#01E7 put
dup/gcircumflex 16#011D put
dup/gcommaaccent 16#0123 put
dup/gdotaccent 16#0121 put
dup/germandbls 16#00DF put
dup/gradient 16#2207 put
dup/grave 16#0060 put
dup/gravecomb 16#0300 put
dup/greater 16#003E put
dup/greaterequal 16#2265 put
dup/guillemotleft 16#00AB put
dup/guillemotright 16#00BB put
dup/guilsinglleft 16#2039 put
dup/guilsinglright 16#203A put
dup/h 16#0068 put
dup/hbar 16#0127 put
dup/hcircumflex 16#0125 put
dup/heart 16#2665 put
dup/hookabovecomb 16#0309 put
dup/house 16#2302 put
dup/hungarumlaut 16#02DD put
dup/hyphen[16#002D 16#00AD]put
dup/hypheninferior 16#F6E5 put
dup/hyphensuperior 16#F6E6 put
dup/i 16#0069 put
dup/iacute 16#00ED put
dup/ibreve 16#012D put
dup/icircumflex 16#00EE put
dup/idieresis 16#00EF put
dup/igrave 16#00EC put
dup/ij 16#0133 put
dup/imacron 16#012B put
dup/infinity 16#221E put
dup/integral 16#222B put
dup/integralbt 16#2321 put
dup/integralex 16#F8F5 put
dup/integraltp 16#2320 put
dup/intersection 16#2229 put
dup/invbullet 16#25D8 put
dup/invcircle 16#25D9 put
dup/invsmileface 16#263B put
dup/iogonek 16#012F put
dup/iota 16#03B9 put
dup/iotadieresis 16#03CA put
dup/iotadieresistonos 16#0390 put
dup/iotatonos 16#03AF put
dup/isuperior 16#F6ED put
dup/itilde 16#0129 put
dup/j 16#006A put
dup/jcircumflex 16#0135 put
dup/k 16#006B put
dup/kappa 16#03BA put
dup/kcommaaccent 16#0137 put
dup/kgreenlandic 16#0138 put
dup/l 16#006C put
dup/lacute 16#013A put
dup/lambda 16#03BB put
dup/lcaron 16#013E put
dup/lcommaaccent 16#013C put
dup/ldot 16#0140 put
dup/less 16#003C put
dup/lessequal 16#2264 put
dup/lfblock 16#258C put
dup/lira 16#20A4 put
dup/ll 16#F6C0 put
dup/logicaland 16#2227 put
dup/logicalnot 16#00AC put
dup/logicalor 16#2228 put
dup/longs 16#017F put
dup/lozenge 16#25CA put
dup/lslash 16#0142 put
dup/lsuperior 16#F6EE put
dup/ltshade 16#2591 put
dup/m 16#006D put
dup/macron[16#00AF 16#02C9]put
dup/male 16#2642 put
dup/minus 16#2212 put
dup/minute 16#2032 put
dup/msuperior 16#F6EF put
dup/mu[16#00B5 16#03BC]put
dup/multiply 16#00D7 put
dup/musicalnote 16#266A put
dup/musicalnotedbl 16#266B put
dup/n 16#006E put
dup/nacute 16#0144 put
dup/napostrophe 16#0149 put
dup/ncaron 16#0148 put
dup/ncommaaccent 16#0146 put
dup/nine 16#0039 put
dup/nineinferior 16#2089 put
dup/nineoldstyle 16#F739 put
dup/ninesuperior 16#2079 put
dup/notelement 16#2209 put
dup/notequal 16#2260 put
dup/notsubset 16#2284 put
dup/nsuperior 16#207F put
dup/ntilde 16#00F1 put
dup/nu 16#03BD put
dup/numbersign 16#0023 put
dup/o 16#006F put
dup/oacute 16#00F3 put
dup/obreve 16#014F put
dup/ocircumflex 16#00F4 put
dup/odieresis 16#00F6 put
dup/oe 16#0153 put
dup/ogonek 16#02DB put
dup/ograve 16#00F2 put
dup/ohorn 16#01A1 put
dup/ohungarumlaut 16#0151 put
dup/omacron 16#014D put
dup/omega 16#03C9 put
dup/omega1 16#03D6 put
dup/omegatonos 16#03CE put
dup/omicron 16#03BF put
dup/omicrontonos 16#03CC put
dup/one 16#0031 put
dup/onedotenleader 16#2024 put
dup/oneeighth 16#215B put
dup/onefitted 16#F6DC put
dup/onehalf 16#00BD put
dup/oneinferior 16#2081 put
dup/oneoldstyle 16#F731 put
dup/onequarter 16#00BC put
dup/onesuperior 16#00B9 put
dup/onethird 16#2153 put
dup/openbullet 16#25E6 put
dup/ordfeminine 16#00AA put
dup/ordmasculine 16#00BA put
dup/orthogonal 16#221F put
dup/oslash 16#00F8 put
dup/oslashacute 16#01FF put
dup/osuperior 16#F6F0 put
dup/otilde 16#00F5 put
dup/p 16#0070 put
dup/paragraph 16#00B6 put
dup/parenleft 16#0028 put
dup/parenleftbt 16#F8ED put
dup/parenleftex 16#F8EC put
dup/parenleftinferior 16#208D put
dup/parenleftsuperior 16#207D put
dup/parenlefttp 16#F8EB put
dup/parenright 16#0029 put
dup/parenrightbt 16#F8F8 put
dup/parenrightex 16#F8F7 put
dup/parenrightinferior 16#208E put
dup/parenrightsuperior 16#207E put
dup/parenrighttp 16#F8F6 put
dup/partialdiff 16#2202 put
dup/percent 16#0025 put
dup/period 16#002E put
dup/periodcentered[16#00B7 16#2219]put
dup/periodinferior 16#F6E7 put
dup/periodsuperior 16#F6E8 put
dup/perpendicular 16#22A5 put
dup/perthousand 16#2030 put
dup/peseta 16#20A7 put
dup/phi 16#03C6 put
dup/phi1 16#03D5 put
dup/pi 16#03C0 put
dup/plus 16#002B put
dup/plusminus 16#00B1 put
dup/prescription 16#211E put
dup/product 16#220F put
dup/propersubset 16#2282 put
dup/propersuperset 16#2283 put
dup/proportional 16#221D put
dup/psi 16#03C8 put
dup/q 16#0071 put
dup/question 16#003F put
dup/questiondown 16#00BF put
dup/questiondownsmall 16#F7BF put
dup/questionsmall 16#F73F put
dup/quotedbl 16#0022 put
dup/quotedblbase 16#201E put
dup/quotedblleft 16#201C put
dup/quotedblright 16#201D put
dup/quoteleft 16#2018 put
dup/quotereversed 16#201B put
dup/quoteright 16#2019 put
dup/quotesinglbase 16#201A put
dup/quotesingle 16#0027 put
dup/r 16#0072 put
dup/racute 16#0155 put
dup/radical 16#221A put
dup/radicalex 16#F8E5 put
dup/rcaron 16#0159 put
dup/rcommaaccent 16#0157 put
dup/reflexsubset 16#2286 put
dup/reflexsuperset 16#2287 put
dup/registered 16#00AE put
dup/registersans 16#F8E8 put
dup/registerserif 16#F6DA put
dup/revlogicalnot 16#2310 put
dup/rho 16#03C1 put
dup/ring 16#02DA put
dup/rsuperior 16#F6F1 put
dup/rtblock 16#2590 put
dup/rupiah 16#F6DD put
dup/s 16#0073 put
dup/sacute 16#015B put
dup/scaron 16#0161 put
dup/scedilla[16#015F 16#F6C2]put
dup/scircumflex 16#015D put
dup/scommaaccent 16#0219 put
dup/second 16#2033 put
dup/section 16#00A7 put
dup/semicolon 16#003B put
dup/seven 16#0037 put
dup/seveneighths 16#215E put
dup/seveninferior 16#2087 put
dup/sevenoldstyle 16#F737 put
dup/sevensuperior 16#2077 put
dup/shade 16#2592 put
dup/sigma 16#03C3 put
dup/sigma1 16#03C2 put
dup/similar 16#223C put
dup/six 16#0036 put
dup/sixinferior 16#2086 put
dup/sixoldstyle 16#F736 put
dup/sixsuperior 16#2076 put
dup/slash 16#002F put
dup/smileface 16#263A put
dup/space[16#0020 16#00A0]put
dup/spade 16#2660 put
dup/ssuperior 16#F6F2 put
dup/sterling 16#00A3 put
dup/suchthat 16#220B put
dup/summation 16#2211 put
dup/sun 16#263C put
dup/t 16#0074 put
dup/tau 16#03C4 put
dup/tbar 16#0167 put
dup/tcaron 16#0165 put
dup/tcommaaccent[16#0163 16#021B]put
dup/therefore 16#2234 put
dup/theta 16#03B8 put
dup/theta1 16#03D1 put
dup/thorn 16#00FE put
dup/three 16#0033 put
dup/threeeighths 16#215C put
dup/threeinferior 16#2083 put
dup/threeoldstyle 16#F733 put
dup/threequarters 16#00BE put
dup/threequartersemdash 16#F6DE put
dup/threesuperior 16#00B3 put
dup/tilde 16#02DC put
dup/tildecomb 16#0303 put
dup/tonos 16#0384 put
dup/trademark 16#2122 put
dup/trademarksans 16#F8EA put
dup/trademarkserif 16#F6DB put
dup/triagdn 16#25BC put
dup/triaglf 16#25C4 put
dup/triagrt 16#25BA put
dup/triagup 16#25B2 put
dup/tsuperior 16#F6F3 put
dup/two 16#0032 put
dup/twodotenleader 16#2025 put
dup/twoinferior 16#2082 put
dup/twooldstyle 16#F732 put
dup/twosuperior 16#00B2 put
dup/twothirds 16#2154 put
dup/u 16#0075 put
dup/uacute 16#00FA put
dup/ubreve 16#016D put
dup/ucircumflex 16#00FB put
dup/udieresis 16#00FC put
dup/ugrave 16#00F9 put
dup/uhorn 16#01B0 put
dup/uhungarumlaut 16#0171 put
dup/umacron 16#016B put
dup/underscore 16#005F put
dup/underscoredbl 16#2017 put
dup/union 16#222A put
dup/universal 16#2200 put
dup/uogonek 16#0173 put
dup/upblock 16#2580 put
dup/upsilon 16#03C5 put
dup/upsilondieresis 16#03CB put
dup/upsilondieresistonos 16#03B0 put
dup/upsilontonos 16#03CD put
dup/uring 16#016F put
dup/utilde 16#0169 put
dup/v 16#0076 put
dup/w 16#0077 put
dup/wacute 16#1E83 put
dup/wcircumflex 16#0175 put
dup/wdieresis 16#1E85 put
dup/weierstrass 16#2118 put
dup/wgrave 16#1E81 put
dup/x 16#0078 put
dup/xi 16#03BE put
dup/y 16#0079 put
dup/yacute 16#00FD put
dup/ycircumflex 16#0177 put
dup/ydieresis 16#00FF put
dup/yen 16#00A5 put
dup/ygrave 16#1EF3 put
dup/z 16#007A put
dup/zacute 16#017A put
dup/zcaron 16#017E put
dup/zdotaccent 16#017C put
dup/zero 16#0030 put
dup/zeroinferior 16#2080 put
dup/zerooldstyle 16#F730 put
dup/zerosuperior 16#2070 put
dup/zeta 16#03B6 put
def
/.scanfontheaders where{pop/.scanfontheaders[.scanfontheaders aload pop(\000\001\000\000*)(true*)]def}if
/.findnonttfontvalue/.findfontvalue load def/.findfontvalue{1 index read{2 index 1 index unread
dup 0 eq 1 index(O)0 get eq or exch(t)0 get eq or{dup/FontType eq{pop closefile 42 true}{
dup/FontName eq{pop .findttfontname}{pop closefile false}ifelse}ifelse}{.findnonttfontvalue}ifelse}{pop closefile false}ifelse
}bind def/.findttfontname{//true 0 .loadttfonttables
tabdict/name .knownget{dup 8 getu32 f exch setfileposition
12 getu32 string f exch readstring pop
dup
6 findname not{4 findname}{exch pop true}ifelse}{false}ifelse
f closefile end end}bind def/tt_tag_dict<<<00010000>0(true)0(typ1)0(ttcf)0 >>readonly def
/.loadnonttfontfile/.loadfontfile load def/.loadfontfile{dup(1234).peekstring{//tt_tag_dict exch known}{//false}ifelse{
.loadttfont pop}{.loadnonttfontfile}ifelse}bind def
currentdict/tt_tag_dict .undef/.loadttfontdict 50 dict dup begin/orgXUID AladdinEnterprisesXUID def/maxstring 32764 def
/.invert_encoding{dup 256 dict exch
0 exch 1 exch length 1 sub{dup 3 index exch get
dup/.notdef ne{exch 2 index 2 index .knownget{dup type/arraytype eq{[exch aload pop counttomark 2 add -1 roll]}{
exch 2 array astore}ifelse}if 2 index 3 1 roll put}{pop pop}ifelse}for
exch pop}bind def/MacRomanEncodingForTrueType/MacRomanEncoding .findencoding
dup length array copy
<</notequal	173/infinity	176/lessequal	178/greaterequal	179/partialdiff	182/summation	183/product	184/pi	185/integral	186
/Omega	189/radical	195/approxequal	197/Delta	198/lozenge	215/Euro	219/apple	240
>>{TTFDEBUG{(Extend MacRomanEncodingForTrueType for TrueType: )=only}if
2 index 1 index get dup/.notdef eq{TTFDEBUG{(insert /)=only 2 index =only( @ )=only 1 index ==}if
pop
exch 2 index 3 1 roll put}{TTFDEBUG{(cannot insert /)=only 2 index =only( @ )=only 1 index =only( used for )=only dup ==}if
pop
pop pop}ifelse}forall
aload pop
256 packedarray
5 1 index .registerencoding
.defineencoding/MacRomanEncoding dup .findencoding def/MacGlyphEncoding dup .findencoding def
/MacRomanEncodingForTrueType dup .findencoding def/.romanmacdict MacRomanEncodingForTrueType .invert_encoding def
/.latin1isodict ISOLatin1Encoding .invert_encoding def/postremap mark/Eoverdot/Edotaccent/eoverdot/edotaccent
.dicttomark readonly def/.array1024z[1024{0}repeat]def/xuidstring<80000000>def/curxuid{
0 xuidstring{exch 8 bitshift exch add}forall}bind def/nextxuid{3 -1 0{xuidstring 1 index 2 copy get dup 255 ne{
1 add put pop exit}if pop 0 put pop}for}bind def/getu16{2 copy get 8 bitshift 3 1 roll 1 add get add}bind def/gets16{
getu16 16#8000 xor 16#8000 sub}bind def/getu32{2 copy getu16 16 bitshift 3 1 roll 2 add getu16 add}bind def/gets32{
2 copy gets16 16 bitshift 3 1 roll 2 add getu16 add}bind def/getu16a{2 getinterval_from_stringarray 0 getu16}bind def/gets16a{
2 getinterval_from_stringarray 0 gets16}bind def/getu32a{4 getinterval_from_stringarray 0 getu32}bind def/gets32a{
4 getinterval_from_stringarray 0 gets32}bind def
16#ffffffff 0 gt{{/curxuid/gets32/gets32a}{mark 1 index load aload pop{16#80000000 xor 16#80000000 sub}aload pop
.packtomark cvx def}bind forall}if/putu16{3 copy -8 bitshift put
exch 1 add exch 16#ff and put}bind def/putu32{3 copy -16 bitshift putu16
exch 2 add exch 16#ffff and putu16}bind def/findname{TTFDEBUG{(findname: )print dup =only}if
false 3 1 roll
1 index length 0 gt{0 1 3 index 2 getu16 1 sub{12 mul 6 add 2 index exch 12 getinterval
dup 6 getu16 2 index eq{exch pop
dup 10 getu16 2 index 4 getu16 add
1 index 8 getu16 4 -1 roll 3 1 roll
3 copy add 1 index length
le{pop
getinterval exch
is2byte{true}{dup is2byte2}ifelse{string2to1}if true null 4 -1 roll exit}{pop pop pop pop
false
exit}ifelse}if pop}for}if
pop pop
TTFDEBUG{dup{( = )print 1 index ==}{( not found)=}ifelse}if}bind def/is2byte{dup 0 getu16{{pop true}{pop false}{1 getu16 1 eq}
{1 getu16 1 eq}}exch get exec}bind def/is2byte2{dup length
dup 2 mod 0 ne{pop pop false}{true exch
1 sub 0 exch 2 exch{2 index exch get 0 ne{pop false exit}if}for
exch pop}ifelse}bind def/string2to1{dup length 2 idiv string dup
0 1 3 index length 1 sub{3 index 1 index 2 mul 1 add get put dup}for pop exch pop}bind def/cmapformats mark
0{6 256 getinterval_from_stringarray{}forall 256 packedarray}bind
2{/sHK_sz 2 def/sH_sz 8 def
dup 2 getu16a/cmapf2_tblen exch def
dup 4 getu16a/cmapf2_lang exch def
dup 6 256 sHK_sz mul getinterval_from_stringarray/sHKs exch def
0
0 1 255{sHKs exch
2 mul getu16
1 index
1 index
lt{exch}if pop}for/sH_len exch def
dup 6 256 sHK_sz mul add
cmapf2_tblen 1 index sub getinterval_from_stringarray/sH_gIA exch def/cmapf2_glyph_array 65535 array def/.cmapf2_putGID{
/cmapf2_ch cmapf2_ch_hi 8 bitshift cmapf2_ch_lo add def
firstCode cmapf2_ch_lo le
cmapf2_ch_lo firstCode entryCount add lt
and{sH_offset idRangeOffset add
cmapf2_ch_lo firstCode sub 2 mul
add 6 add
sH_gIA exch getu16
dup 0 gt{idDelta add
cmapf2_glyph_array exch cmapf2_ch exch put}{pop}ifelse}{}ifelse}def
16#00 1 16#ff{/cmapf2_ch_hi exch def
sHKs cmapf2_ch_hi sHK_sz mul getu16/sH_offset exch def
sH_gIA sH_offset sH_sz getinterval
dup 0 getu16/firstCode exch def
dup 2 getu16/entryCount exch def
dup 4 gets16/idDelta exch def
dup 6 getu16/idRangeOffset exch def
pop
sH_offset 0 eq{/cmapf2_ch_lo cmapf2_ch_hi def/cmapf2_ch_hi 0 def
.cmapf2_putGID}{16#00 1 16#ff{/cmapf2_ch_lo exch def
.cmapf2_putGID}for}ifelse}for
pop
0 1 cmapf2_glyph_array length 1 sub{dup cmapf2_glyph_array exch get
null eq{cmapf2_glyph_array exch 0 put}{pop}ifelse}for
cmapf2_glyph_array}bind
4{/etab exch def/nseg2 etab 6 getu16 def
14/endc etab 2 index nseg2 getinterval_from_stringarray def
2 add
nseg2 add/startc etab 2 index nseg2 getinterval_from_stringarray def
nseg2 add/iddelta etab 2 index nseg2 getinterval_from_stringarray def
nseg2 add/idroff etab 2 index nseg2 getinterval_from_stringarray def
pop/firstcode startc 0 getu16 16#ff00 and dup 16#f000 ne{pop 0}if def/putglyph{glyphs code 3 -1 roll put/code code 1 add def
}bind def/numcodes 0 def/glyphs 0 0 2 nseg2 3 sub{/i2 exch def/scode startc i2 getu16 def/ecode endc i2 getu16 def
numcodes scode firstcode sub
exch sub 0 .max ecode scode sub 1 add add
exch 1 index add exch
numcodes add/numcodes exch def}for array def
glyphs length 1024 ge{.array1024z 0 1024 glyphs length 1023 sub{glyphs exch 2 index putinterval}for
glyphs dup length 1024 sub 3 -1 roll
putinterval}{0 1 glyphs length 1 sub{glyphs exch 0 put}for}ifelse/numcodes 0 def/code 0 def
0 2 nseg2 3 sub{/i2 exch def/scode startc i2 getu16 def/ecode endc i2 getu16 def
numcodes scode firstcode sub
exch sub 0 .max dup/code exch code exch add def
ecode scode sub 1 add add numcodes add/numcodes exch def/delta iddelta i2 gets16 def
TTFDEBUG{(scode=)print scode =only( ecode=)print ecode =only( delta=)print delta =only( droff=)print idroff i2 getu16 =}if
idroff i2 getu16 dup 0 eq{pop scode delta add 65535 and 1 ecode delta add 65535 and{putglyph}for}{
/gloff exch 14 nseg2 3 mul add 2 add i2 add add def
0 1 ecode scode sub{2 mul gloff add etab exch getu16a
dup 0 ne{delta add 65535 and}if putglyph}for}ifelse}for glyphs/glyphs null def}bind
6{dup 6 getu16a/firstcode exch def
dup 8 getu16a/ng exch def
firstcode ng add array
0 1 firstcode 1 sub{2 copy 0 put pop}for
dup firstcode ng getinterval
0 1 ng 1 sub{dup 2 mul 10 add 4 index exch getu16a 3 copy put pop pop}for pop exch pop}bind
.dicttomark readonly def/cmaparray{dup 0 getu16a cmapformats exch .knownget{TTFDEBUG{
(cmap: format )print 1 index 0 getu16a = flush}if exec}{(Can't handle format )print 0 getu16a = flush
0 1 255{}for 256 packedarray}ifelse
TTFDEBUG{(cmap: length=)print dup length = dup ==}if}bind def/get_from_stringarray{1 index type/stringtype eq{get}{exch{
2 copy length ge{length sub}{exch get exit}ifelse}forall}ifelse}bind def/getinterval_from_stringarray{
2 index type/stringtype eq{getinterval}{string exch 0
4 3 roll{dup length
dup 4 index lt{3 index exch sub
exch pop 3 1 roll exch pop}{dup 3 1 roll
4 index sub
5 index length 4 index sub
2 copy gt{exch}if pop
dup 3 1 roll
5 index exch getinterval
5 index 4 index 3 index
getinterval
copy pop
3 1 roll
sub
3 1 roll add
dup 3 index length ge 2 index 0 le or{exch exit}if
exch}ifelse}forall
pop pop}ifelse}bind def/string_array_size{dup type/stringtype eq{length}{0 exch{length add}forall}ifelse}bind def
/postformats mark
16#00010000{pop MacGlyphEncoding}16#00020000{dup dup type/arraytype eq{0 get}if length 36 lt{
TTFDEBUG{(post format 2.0 invalid.)= flush}if
pop[]}{/postglyphs exch def/post_first postglyphs dup type/arraytype eq{0 get}if def
post_first 32 getu16/numglyphs exch def/glyphnames numglyphs 2 mul 34 add def/postpos glyphnames def
/total_length postglyphs//string_array_size exec def
numglyphs array 0 1 numglyphs 1 sub{postpos total_length ge{pop exit}if
postglyphs postpos//get_from_stringarray exec
postglyphs postpos 1 add 2 index//getinterval_from_stringarray exec cvn
exch postpos add 1 add/postpos exch def
2 index 3 1 roll
.latin1isodict 1 index known{TTFDEBUG{(ignore post table that redefines ISOLatin1Encoding glyph name /)print dup == flush}if
pop pop pop pop[]/numglyphs 0 def exit}{put}ifelse}for/postnames exch def
numglyphs array 0 1 numglyphs 1 sub{dup 2 mul 34 add postglyphs exch 2//getinterval_from_stringarray exec
dup 0 get 8 bitshift exch 1 get add dup 258 lt{MacGlyphEncoding exch get}{dup 32768 ge{pop/.notdef}{
258 sub dup postnames length ge{TTFDEBUG{(   *** warning: glyph index past end of 'post' table)= flush}if
pop
exit}if
postnames exch get
postremap 1 index .knownget{exch pop}if}ifelse}ifelse
2 index 3 1 roll put}for}ifelse}bind
16#00030000{pop[]}bind
.dicttomark readonly def/call.readtable{.readtable}bind def/call.readbigtable{.readbigtable}bind def/readtables mark
(head)//call.readtable(hhea)1 index(maxp)1 index(name)1 index(OS/2)1 index(post)//call.readbigtable(vhea)//call.readtable
(cmap)//call.readbigtable(glyf)1 index(loca)1 index(hmtx)1 index(vmtx)1 index(cvt )//call.readtable(fpgm)1 index(prep)1 index
.dicttomark
def/readtables_stripped readtables dup length dict copy
dup(loca){.skiptable}put
dup(glyf){.skiptable}put
def/.skiptable{pop pop()}bind def/.readtable{dup dup 1 and add string
dup 0 4 -1 roll getinterval
3 -1 roll exch
dup()ne{readstring}if pop pop}bind def/.readbigtable{dup 65400 lt{.readtable}{currentuserparams/VMReclaim get -2 vmreclaim
[4 2 roll{dup maxstring le{exit}if
1 index maxstring string readstring pop 3 1 roll maxstring sub}loop .readtable]exch vmreclaim}ifelse}bind def
end readonly def/.printtab{dup 0 4 getinterval print( )print
dup 8 getu32 =only( )print
12 getu32 =}bind def/.loadttfonttables{.loadttfontdict begin
40 dict begin/SubfontID exch def/load_stripped exch def/f exch def/offsets f 12 string readstring pop def
load_stripped{readtables_stripped}{readtables}ifelse/readtables_ exch def
offsets 0 4 getinterval(ttcf)eq{offsets 8 getu32/num_fonts exch def
SubfontID num_fonts ge{QUIET not{(True Type collection contains insufficient fonts.)=}if
/.loadttfonttables cvx/invalidfont signalerror}if
SubfontID 4 mul 12 add f exch setfileposition
f 4 string readstring pop 0
getu32/ttc_offset exch def
f ttc_offset setfileposition/offsets f 12 string readstring pop def}{SubfontID 0 gt{
QUIET not{(SubfontID > 0 with a True Type file which is not a collection.)=}if/.loadttfonttables cvx/invalidfont signalerror}if
/ttc_offset 0 def}ifelse/tables f offsets 4 getu16 16 mul string readstring pop def/tabdict tables length 16 idiv dict def
/tabs[0 16 tables length 1 sub{tables exch 16 getinterval
TTFDEBUG{dup .printtab}if
dup 0 4 getinterval readtables_ 1 index known{1 index 12 getu32 0 eq{1 index 8 0 putu32}if
tabdict exch 2 index put}{pop pop}ifelse}for]{exch 8 getu32 exch 8 getu32 lt}.sort def
0 1 tabs length 2 sub{dup tabs exch get exch 1 add tabs exch get
1 index 8 getu32 2 index 12 getu32 add
1 index 8 getu32 gt{(**** Warning: )print 1 index 0 4 getinterval print( overlaps )print dup 0 4 getinterval print
(, truncating.)= flush
dup 8 getu32 2 index 8 getu32 sub
2 index 12 3 -1 roll putu32}if pop pop}for}bind def/.file_table_pos_names
mark/glyf 0/loca 0
.dicttomark readonly def/.readttdata{/file_table_pos 10 dict def/fpos offsets length tables length add ttc_offset add def
/sfpos offsets length tabs length 16 mul add def
offsets 4 tabs length putu16
tabs{dup 0 4 getinterval/tname exch def
dup 8 getu32/tpos exch def
dup 12 getu32/tlen exch def
load_stripped//.file_table_pos_names tname known and{pop
file_table_pos tname[tpos tlen]put
tabdict tname()put}{8 sfpos putu32
tpos fpos gt{load_stripped{f tpos setfileposition}{f tpos fpos sub()/SubFileDecode filter dup flushfile closefile/fpos tpos def
}ifelse}if
f tlen readtables_ tname get exec
tabdict tname 3 -1 roll put/sfpos sfpos tlen dup 1 and add add def}ifelse/fpos fpos tlen add def}forall}bind def/.findseg{exch{
dup length 2 index gt{exch exit}if
length sub}forall}bind def/.makesfnts{.readttdata/head tabdict/head get def/post tabdict/post .knownget{
dup 0 get/post_first_part exch def}{null}ifelse def
load_stripped not{/locatable tabdict/loca get def/numloca
locatable dup type/stringtype eq{length}{0 exch{length add}forall}ifelse
locatable type/stringtype eq{/.indexloca{}def}{/.indexloca/.findseg load def}ifelse
head 50 getu16 0 ne{/getloca{2 bitshift locatable exch .indexloca getu32}def
4 idiv 1 sub}{/getloca{dup add locatable exch .indexloca getu16 dup add}def
2 idiv 1 sub}ifelse def
tabdict/glyf get dup type/stringtype ne{.dividesfnts tabdict/glyf 3 -1 roll put}{pop}ifelse}{
/numloca tabdict/maxp get 4 getu16 def}ifelse/sfnts[offsets tabs{concatstrings}forall
tabs{0 4 getinterval tabdict exch get
dup type/stringtype ne{aload pop}if}forall]def}bind def/.dividesfnts{/glyfs exch def/len1 0 glyfs{length add}forall def
/prevsplit 0 def/prevboundary 0 def/needsort false def
numloca array
-1
0 1 numloca 1 sub{dup getloca dup
4 -1 roll lt{/needsort true def}if
3 copy put exch pop}for pop
needsort{{lt}bind .sort}if/splitarray[3 -1 roll 0 1 numloca 1 sub{1 index exch get dup prevsplit maxstring add gt{
prevboundary prevsplit sub exch/prevsplit prevboundary def}if
dup 1 and 0 eq{/prevboundary exch def}{pop}ifelse
dup type/arraytype ne{exch}if}for
len1 prevsplit sub
exch pop]def
currentuserparams/VMReclaim get -2 vmreclaim[/sfnt_idx 0 def/strpos 0 def/avail()def
splitarray{/seglen exch def/segpos 0 def
avail length seglen ge{avail 0 seglen getinterval/avail()def}{seglen string}ifelse{/str glyfs sfnt_idx get def
/strlen str length def/strleft strlen strpos sub def
seglen segpos sub strleft lt{exit}if
dup segpos str strpos strleft getinterval putinterval/segpos segpos strleft add def/avail str def/sfnt_idx sfnt_idx 1 add def
/strpos 0 def
segpos seglen eq{exit}if}loop/segleft seglen segpos sub def
dup segpos str strpos segleft getinterval putinterval/strpos strpos segleft add def}forall]exch vmreclaim}bind def
/first_post_string{post dup type/arraytype eq{0 get}if}bind def/.getpost{/glyphencoding post null eq{
TTFDEBUG{(post missing)= flush}if[]}{postformats first_post_string 0 getu32 .knownget{TTFDEBUG{(post: format )print
first_post_string
dup 0 getu16 =only(,)print 2 getu16 = flush}if
post exch exec}{TTFDEBUG{(post: unknown format )print post 0 getu32 = flush}if[]}ifelse}ifelse
TTFDEBUG{(post=)print dup ==}if
def}bind def/.ttkeys{count/ttkeycount exch def/upem head 18 getu16 def/FontMatrix matrix
/FontBBox[36 2 42{head exch gets16 upem div}for]nextxuid
tabdict/name .knownget{/names exch def
/FontName names 6 findname not{names 4 findname not{curxuid 16#ffffffff and 16 32 string cvrs}if}if/fontname 1 index def
/FontInfo mark
names 0 findname{/Notice exch}if
names 1 findname{/FamilyName exch}if
names 4 findname{/FullName exch}if
names 5 findname{/Version exch}if}{/FontName curxuid 16#ffffffff and 16 32 string cvrs/fontname 1 index def/FontInfo mark
}ifelse
post null ne{/ItalicAngle first_post_string 4 gets32 65536.0 div/isFixedPitch first_post_string 12 getu32 0 ne
/UnderlinePosition first_post_string 8 gets16 upem div/UnderlineThickness first_post_string 10 gets16 upem div}if
counttomark 0 ne{.dicttomark}{pop pop}ifelse/XUID[orgXUID 42 curxuid]TTFDEBUG{tabs{.printtab}forall[sfnts{length}forall]==
count ttkeycount sub array astore dup{==}forall aload pop}if/sfnts sfnts}bind def/.pickcmap_with_no_xlatmap{tabdict/cmap get
dup 4 8 getinterval_from_stringarray exch
0 1 2 index 2 getu16a 1 sub{8 mul 4 add 1 index exch 8 getinterval_from_stringarray
TTFDEBUG{(cmap: platform )print dup 0 getu16 =only( encoding )print dup 2 getu16 = flush}if
dup 0 getu16 3 eq{exch 3 -1 roll pop exit}if pop}for/cmapsub 2 index def
exch 4 getu32 1 index string_array_size 1 index sub getinterval_from_stringarray/cmaptab exch def}bind def
/.pickcmap_with_xlatmap{.xlatmap_dict/TrueType known not{(Emulating a CID font with a True Type file, )print
(the file gs/lib/xlatmap must contain /TrueType key.)=/.pickcmap_with_xlatmap cvx/configurationerror signalerror}if
false
.xlatmap_dict/TrueType get
dup length 2 sub 0 exch 2 exch{2 copy get(.)search{cvi exch pop exch cvi}{
(gs/lib/xlatmap containg a record with an invalid (PlatformID.SpecificID))=
/.pickcmap_with_xlatmap cvx/configurationerror signalerror}ifelse
TTFDEBUG{(Seeking a cmap for platform=)print 1 index =only( encoding=)print dup =}if
tabdict/cmap get
dup/cmaptab exch def
0 1 2 index 2 getu16a 1 sub{8 mul 4 add 1 index exch 8
getinterval_from_stringarray
TTFDEBUG{(cmap: platform )print dup 0 getu16 =only( encoding )print dup 2 getu16 = flush}if
dup 0 getu16 4 index eq{dup 2 getu16 3 index eq{TTFDEBUG{(Choosen a cmap for platform=)print 3 index =only
( encoding=)print 2 index =}if/cmapsub 1 index def
dup 4 getu32
cmaptab 1 index getu16a
8 lt{cmaptab 1 index 2 add getu16a}{cmaptab 1 index 4 add getu32a}ifelse
cmaptab 3 1 roll getinterval_from_stringarray/cmaptab exch def
5 index 5 index 1 add get/Decoding exch def
7 -1 roll pop true 7 1 roll}if}if
pop
5 index{exit}if}for
pop pop pop pop
1 index{exit}if}for
pop
not{QUIET not{(True Type font doesn't contain a charset listed in gs/lib/xlatmap.)=}if
/.pickcmap_with_xlatmap cvx/invalidfont signalerror}if}bind def/.pickcmap{load_stripped{//.pickcmap_with_xlatmap exec}{
//.pickcmap_with_no_xlatmap exec}ifelse}bind def/.nname{=string cvs(_)exch concatstrings cvn}bind def/postalias mark
/pi1/pi/plusinus/plusminus/Acyrillic/afii10017/Becyrillic/afii10018/Cdot/Cdotaccent/Checyrillic/afii10041
/Dcroat/Dslash/Decyrillic/afii10021/Delta/increment/Djecyrillic/afii10051/Dzecyrillic/afii10054/Dzhecyrillic/afii10145
/Ecyrillic/afii10053/Edot/Edotaccent/Efcyrillic/afii10038/Elcyrillic/afii10029/Emcyrillic/afii10030/Encyrillic/afii10031
/Ercyrillic/afii10034/Ereversedcyrillic/afii10047/Escyrillic/afii10035/Euro/euro/Fitacyrillic/afii10147/Gcedilla/Gcommaaccent
/Gdot/Gdotaccent/Gecyrillic/afii10020/Gheupturncyrillic/afii10050/Gjecyrillic/afii10052
/H18533/blackcircle/H18543/blacksmallsquare/H18551/whitesmallsquare/H22073/whitesquare
/Hardsigncyrillic/afii10044/IAcyrillic/afii10049/IUcyrillic/afii10048/Icyrillic/afii10055/Idot/Idotaccent/Iecyrillic/afii10022
/Iicyrillic/afii10026/Iishortcyrillic/afii10027/Iocyrillic/afii10023/Izhitsacyrillic/afii10148
/Jecyrillic/afii10057/Kacyrillic/afii10028/Kcedilla/Kcommaaccent/Khacyrillic/afii10039
/Kjecyrillic/afii10061/Lcedilla/Lcommaaccent/Ldot/Ldotaccent/Ljecyrillic/afii10058/Ncedilla/Ncommaaccent/Njecyrillic/afii10059
/Ocyrillic/afii10032/Odblacute/Ohungarumlaut/Ohm/Omega/Oslashacute/Ostrokeacute/Pecyrillic/afii10033/Rcedilla/Rcommaaccent
/Shacyrillic/afii10042/Shchacyrillic/afii10043/Softsigncyrillic/afii10046/Tcedilla/Tcommaaccent
/Tecyrillic/afii10036/Tsecyrillic/afii10040/Tshecyrillic/afii10060/Ucyrillic/afii10037
/Udblacute/Uhungarumlaut/Upsilon1/Upsilonhooksymbol/Ushortcyrillic/afii10062/Vecyrillic/afii10019
/Yatcyrillic/afii10146/Yericyrillic/afii10045/Yicyrillic/afii10056/Zdot/Zdotaccent/Zecyrillic/afii10025/Zhecyrillic/afii10024
/acutecmb/acutecomb/acyrillic/afii10065/afii00208/horizontalbar/afii08941/lira/afii10066/becyrillic/afii10067/vecyrillic
/afii10068/gecyrillic/afii10069/decyrillic/afii10070/iecyrillic/afii10071/iocyrillic/afii10072/zhecyrillic/afii10073/zecyrillic
/afii10074/iicyrillic/afii10075/iishortcyrillic/afii10076/kacyrillic/afii10077/elcyrillic
/afii10078/emcyrillic/afii10079/encyrillic/afii10080/ocyrillic/afii10081/pecyrillic/afii10082/ercyrillic/afii10083/escyrillic
/afii10084/tecyrillic/afii10085/ucyrillic/afii10086/efcyrillic/afii10087/khacyrillic
/afii10088/tsecyrillic/afii10089/checyrillic/afii10090/shacyrillic/afii10091/shchacyrillic
/afii10092/hardsigncyrillic/afii10093/yericyrillic/afii10094/softsigncyrillic/afii10095/ereversedcyrillic
/afii10096/iucyrillic/afii10097/iacyrillic/afii10098/gheupturncyrillic/afii10099/djecyrillic
/afii10100/gjecyrillic/afii10101/ecyrillic/afii10102/dzecyrillic/afii10103/icyrillic/afii10104/yicyrillic/afii10105/jecyrillic
/afii10106/ljecyrillic/afii10107/njecyrillic/afii10108/tshecyrillic/afii10109/kjecyrillic
/afii10110/ushortcyrillic/afii10193/dzhecyrillic/afii10194/yatcyrillic/afii10195/fitacyrillic
/afii10196/izhitsacyrillic/afii10846/schwacyrillic/afii57381/percentarabic/afii57388/commaarabic
/afii57392/zeroarabic/afii57393/onearabic/afii57394/twoarabic/afii57395/threearabic/afii57396/fourarabic/afii57397/fivearabic
/afii57398/sixarabic/afii57399/sevenarabic/afii57400/eightarabic/afii57401/ninearabic
/afii57403/semicolonarabic/afii57407/questionarabic/afii57409/hamzaarabic/afii57410/alefmaddaabovearabic
/afii57411/alefhamzaabovearabic/afii57412/wawhamzaabovearabic/afii57413/alefhamzabelowarabic/afii57414/yehhamzaabovearabic
/afii57415/alefarabic/afii57416/beharabic/afii57417/tehmarbutaarabic/afii57418/teharabic
/afii57419/theharabic/afii57420/jeemarabic/afii57421/haharabic/afii57422/khaharabic/afii57423/dalarabic/afii57424/thalarabic
/afii57425/reharabic/afii57426/zainarabic/afii57427/seenarabic/afii57428/sheenarabic/afii57429/sadarabic/afii57430/dadarabic
/afii57431/taharabic/afii57432/zaharabic/afii57433/ainarabic/afii57434/ghainarabic/afii57440/tatweelarabic/afii57441/feharabic
/afii57442/qafarabic/afii57443/kafarabic/afii57444/lamarabic/afii57445/meemarabic/afii57446/noonarabic/afii57448/wawarabic
/afii57449/alefmaksuraarabic/afii57450/yeharabic/afii57451/fathatanarabic/afii57452/dammatanarabic
/afii57453/kasratanarabic/afii57454/fathaarabic/afii57455/dammaarabic/afii57456/kasraarabic
/afii57457/shaddaarabic/afii57458/sukunarabic/afii57470/heharabic/afii57505/veharabic/afii57506/peharabic/afii57507/tcheharabic
/afii57508/jeharabic/afii57509/gafarabic/afii57511/tteharabic/afii57512/ddalarabic
/afii57513/rreharabic/afii57514/noonghunnaarabic/afii57519/yehbarreearabic/afii57636/newsheqelsign
/afii57645/maqafhebrew/afii57658/sofpasuqhebrew/afii57664/alef/afii57665/bet/afii57666/gimel/afii57667/dalet
/afii57668/he/afii57669/vav/afii57670/zayin/afii57671/het/afii57672/tet/afii57673/yod/afii57674/finalkaf/afii57675/kaf
/afii57676/lamed/afii57677/finalmem/afii57678/mem/afii57679/finalnun/afii57680/nun/afii57681/samekh
/afii57682/ayin/afii57683/finalpe/afii57684/pe/afii57685/finaltsadi/afii57686/tsadi/afii57687/qof/afii57688/resh/afii57689/shin
/afii57690/tav/afii57694/shinshindot/afii57695/shinsindot/afii57700/vavholam/afii57705/doubleyodpatah/afii57716/vavvavhebrew
/afii57717/vavyodhebrew/afii57718/yodyodhebrew/afii57723/vavdagesh/afii57793/hiriq/afii57794/tsere/afii57795/segol
/afii57796/qubuts/afii57797/qamats/afii57798/patah/afii57799/sheva/afii57800/hatafpatah/afii57801/hatafsegol
/afii57802/hatafqamats/afii57803/sindothebrew/afii57804/shindothebrew/afii57806/holam/afii57807/dagesh/afii57839/siluqhebrew
/afii57841/rafe/afii57842/paseqhebrew/afii57929/apostrophemod/afii61248/careof/afii61289/lsquare/afii61352/numero
/afii61664/zerowidthnonjoiner/afii63167/asteriskarabic/afii64937/commareversedmod/alefmaksurainitialarabic/yehinitialarabic
/alefmaksuramedialarabic/yehmedialarabic/approximatelyequal/congruent/arrowdblboth/dblarrowleft/arrowdblleft/arrowleftdbl
/arrowdblright/dblarrowright/arrowupdnbse/arrowupdownbase/bar/verticalbar/betdagesh/betdageshhebrew
/blackdownpointingtriangle/triagdn/blackleftpointingpointer/triaglf/blackrectangle/filledrect/blackrightpointingpointer/triagrt
/blacksmilingface/invsmileface/blacksquare/filledbox/blackuppointingtriangle/triagup/bulletinverse/invbullet
/cdot/cdotaccent/circle/whitecircle/circlemultiply/timescircle/circleplus/pluscircle/club/clubsuitblack/colonmonetary/colonsign
/compass/sun/daletdagesh/daletdageshhebrew/dargahebrew/dargalefthebrew/dbllowline/underscoredbl
/dcroat/dmacron/decimalseparatorarabic/decimalseparatorpersian/dialytikatonos/dieresistonos/dkshade/shadedark
/dotbelowcmb/dotbelowcomb/edot/edotaccent/eighthnotebeamed/musicalnotedbl/etnahtafoukhhebrew/etnahtahebrew
/existential/thereexists/female/venus/finalkafdagesh/finalkafdageshhebrew/forall/universal
/gcedilla/gcommaaccent/gdot/gdotaccent/gimeldagesh/gimeldageshhebrew/gradient/nabla
/gravecmb/gravecomb/haaltonearabic/hehaltonearabic/heart/heartsuitblack/hedagesh/hedageshhebrew
/hehfinalalttwoarabic/hehfinalarabic/hookabovecomb/hookcmb/ilde/tilde/integralbottom/integralbt
/integraltop/integraltp/invcircle/whitecircleinverse/kafdagesh/kafdageshhebrew/kcedilla/kcommaaccent
/lameddagesh/lameddageshhebrew/lcedilla/lcommaaccent/ldot/ldotaccent/logicalnotreversed/revlogicalnot
/longs/slong/ltshade/shadelight/macron/overscore/mahapakhhebrew/mahapakhlefthebrew/male/mars/memdagesh/memdageshhebrew
/merkhahebrew/merkhalefthebrew/merkhakefulahebrew/merkhakefulalefthebrew/middot/periodcentered/mu/mu1
/munahhebrew/munahlefthebrew/napostrophe/quoterightn/nbspace/nonbreakingspace/ncedilla/ncommaaccent
/notelement/notelementof/nundagesh/nundageshhebrew/odblacute/ohungarumlaut/omega1/pisymbolgreek
/openbullet/whitebullet/orthogonal/rightangle/oslashacute/ostrokeacute/pedagesh/pedageshhebrew
/phi1/phisymbolgreek/propersubset/subset/propersuperset/superset/qofdagesh/qofdageshhebrew
/quoteleftreversed/quotereversed/rcedilla/rcommaaccent/reflexsubset/subsetorequal/reflexsuperset/supersetorequal
/reviahebrew/reviamugrashhebrew/samekhdagesh/samekhdageshhebrew/sfthyphen/softhyphen/shade/shademedium
/sheqel/sheqelhebrew/shindagesh/shindageshhebrew
/shindageshshindot/shindageshshindothebrew/shindageshsindot/shindageshsindothebrew/sigma1/sigmafinal/similar/tildeoperator
/smileface/whitesmilingface/space/spacehackarabic/spade/spadesuitblack/tavdages/tavdagesh
/tcedilla/tcommaaccent/tetdagesh/tetdageshhebrew/tevirhebrew/tevirlefthebrew/theta1/thetasymbolgreek
/thousandsseparatorarabic/thousandsseparatorpersian/tildecmb/tildecomb
/tipehahebrew/tipehalefthebrew/tsadidagesh/tsadidageshhebrew/twodotenleader/twodotleader/udblacute/uhungarumlaut
/yerahbenyomohebrew/yerahbenyomolefthebrew/yoddagesh/yoddageshhebrew/zayindagesh/zayindageshhebrew/zdot/zdotaccent
.dicttomark readonly def/.charkeys{TTFDEBUG{(glyphencoding: length=)print glyphencoding dup length = === flush}if
glyphencoding length 0 eq{/have_post false def
cmapsub 0 4 getinterval<00030001>eq{PDFDEBUG{(No post but have cmap 3.1, so use ISOLatin1Encoding)=}if
/glyphencoding ISOLatin1Encoding dup length array copy def}{PDFDEBUG{(No encoding info, use .GS_extended_SymbolEncoding)=}if
/glyphencoding/.GS_extended_SymbolEncoding findencoding dup length array copy def}ifelse}{/have_post true def}ifelse
glyphencoding length numloca lt{/glyphencoding numloca array
glyphencoding length dup 1 sub 0 1 3 2 roll{dup glyphencoding exch get
3 index 3 1 roll put}for
1 numloca 1 sub{1 index exch dup .nname put}for
def}if/cmapa cmaptab cmaparray def/CharStrings glyphencoding dup length 1 add dict
0 1 3 index length 1 sub{2 index 1 index get
have_post not{exch dup cmapa length lt{cmapa exch get}{pop 0}ifelse
exch}if
2 index 1 index known{pop dup .nname 3 index 2 index 2 index put
2 index exch 3 -1 roll put}{2 index exch 3 -1 roll put}ifelse}for exch pop
dup/.notdef known not{dup/.notdef 0 put}if
TTFDEBUG{(CharStrings:)= dup{exch =string cvs print( )print ==}forall}if//postalias{
2 index 2 index known 3 index 2 index known 1 index xor not{pop pop pop}{{exch}if
TTFDEBUG{(setting alias: )print 1 index ==only( to be the same as glyph: )print dup ==}if
2 index exch get 2 index 3 1 roll put}ifelse}forall
readonly/Encoding[have_post{cmapa dup length 256 gt{0 256 getinterval}if{glyphencoding exch get}forall}{
glyphencoding dup length 256 gt{0 256 getinterval}if
aload pop}ifelse
counttomark 256 exch sub{/.notdef}repeat]TTFDEBUG{(Encoding: )print dup === flush}if}bind def
currentdict/postalias undef/.definettfont{/FontType 42/PaintType 0
TTFDEBUG{(numloca=)print numloca =}if
.dicttomark
end end dup/FontName get exch definefont}bind def/.loadttfont{TTFDEBUG{(.loadttfont)=}if//false 0 .loadttfonttables
.makesfnts
.getpost
.pickcmap
mark
.charkeys
.ttkeys
.definettfont}bind def/.fill_identity_cmap{1 index length 2 sub
0 2 3 2 roll{3 copy exch
-8 bitshift
put
3 copy 1 add
exch 255 and
put
pop 1 add}for
pop}bind def/.definettcidfont{/CIDFontName fontname/CIDFontType 2/CIDSystemInfo mark/Registry(Adobe)/Ordering(Japan1)
/Supplement 0
.dicttomark/CharStrings mark/.notdef 0 .dicttomark/CIDCount numloca/CIDMap numloca maxstring le{
numloca 2 mul string 0 .fill_identity_cmap}{maxstring 2 mul string 0 .fill_identity_cmap
numloca maxstring sub 2 mul string maxstring .fill_identity_cmap
2 array astore}ifelse/GDBytes 2
.dicttomark
end end dup/CIDFontName get exch/CIDFont defineresource}bind def/.loadttcidfont{//false 0 .loadttfonttables
.makesfnts
mark
.ttkeys
.definettcidfont}bind def/.load_tt_font_stripped{//true exch .loadttfonttables
.makesfnts
.pickcmap
mark
.ttkeys/NumGlyphs numloca/TT_cmap cmaptab cmaparray/file_table_pos file_table_pos/Decoding Decoding
.dicttomark
end end}bind def/.findcmap{false exch tabdict/cmap get
0 1 2 index 2 getu16a 1 sub{8 mul 4 add 1 index exch 8 getinterval_from_stringarray
dup 0 4 getinterval 3 index eq{4 getu32 1 index exch 1 index string_array_size 1 index sub getinterval_from_stringarray
4 -1 roll not 4 2 roll exit}if pop}for
pop pop}bind def/.symbol_list 256 dict def{=string 0(x)0 get put/SymbolEncoding .findencoding
0 1 255{dup 2 index exch get
dup/.notdef eq{pop dup
=string 1 3 getinterval cvs length 1 add
=string exch 0 exch getinterval cvn}if
exch//.symbol_list 3 1 roll put}for
pop}bind exec{/.GS_extended_SymbolEncoding 256 array//.symbol_list{exch 2 index 3 1 roll put}forall
.defineencoding}bind exec/.hexdigits(0123456789ABCDEF)def/.is_hex_digit{dup 48 ge exch
dup 57 le exch
dup 65 ge exch
70 le and
3 1 roll
and or}bind def/.popfex{pop//false exit}bind def/.pop3ex{pop pop pop exit}bind def/.addglyph{1 index .namestring
dup length 7 eq{currentdict/.allow_uniXXXX_glyph_names .knownget not{//false}if}{//false}ifelse{
TTFDEBUG{(Try uniXXXX:)print dup print}if{dup 0 get 117 ne//.popfex if
dup 1 get 110 ne//.popfex if
dup 2 get 105 ne//.popfex if
dup 3 get//.is_hex_digit exec not//.popfex if
dup 4 get//.is_hex_digit exec not//.popfex if
dup 5 get//.is_hex_digit exec not//.popfex if
dup 6 get//.is_hex_digit exec not//.popfex if
dup 3 1 getinterval .hexdigits exch search pop length exch pop exch pop 12 bitshift exch
dup 4 1 getinterval .hexdigits exch search pop length exch pop exch pop 8 bitshift exch
dup 5 1 getinterval .hexdigits exch search pop length exch pop exch pop 4 bitshift exch
dup 6 1 getinterval .hexdigits exch search pop length exch pop exch pop exch pop
add add add
dup cmapencoding length ge//.popfex if
cmapencoding exch get
dup 0 eq//.popfex if
TTFDEBUG{( index=)print dup =string cvs print}if
exch pop
put//true exit}loop
TTFDEBUG{()=}if}{pop//false}ifelse
not{{dup cmapencoding length ge//.pop3ex if
cmapencoding exch get dup 0 eq//.pop3ex if
3 copy pop known//.pop3ex if
put exit}loop}if}bind def/.pdfmapchars{exch cmaparray/cmapencoding exch def/CharStrings 0 dict
3 2 roll{dup type/arraytype eq{{3 copy//.addglyph exec
pop}forall}{3 copy//.addglyph exec pop}ifelse
pop}forall
0 1 glyphencoding length 1 sub{dup glyphencoding exch get exch
dup 0 ne{3 copy pop known not{3 copy put}if}if
pop pop}for
dup/.notdef 0 put}bind def/.pdfcharkeys{TTFDEBUG{(.pdfcharkeys beg)=}if
is_symbolic{<00030001>.findcmap{
(   **** Warning: Embedded symbolic TT fonts should not contain a cmap for Platform=3 Encoding=1.\n)pdfformaterror
prebuilt_encoding null ne{TTFDEBUG{(Using cmap 3.0 with prebuilt_encoding.)=}if
prebuilt_encoding .invert_encoding .pdfmapchars/Encoding prebuilt_encoding}{TTFDEBUG{(Using cmap 3.1 with WinAnsiEncoding)=}if
AdobeGlyphList .pdfmapchars/Encoding/WinAnsiEncoding .findencoding}ifelse}{<00010000>.findcmap{prebuilt_encoding null ne{
TTFDEBUG{(Using cmap 1.0 with prebuilt_encoding.)=}if
prebuilt_encoding .invert_encoding .pdfmapchars/Encoding prebuilt_encoding}{pop
TTFDEBUG{(Using cmap 1.0 with post or .GS_extended_SymbolEncoding)=}if
.charkeys}ifelse}{(   **** Warning: Embedded symbolic TT fonts must contain a cmap for Platform=1 Encoding=0.\n)pdfformaterror
.charkeys
prebuilt_encoding null ne{false prebuilt_encoding{4 index exch known not{pop true exit}if}forall{
(   **** Warning: Encoding derived from 'post' is incomplete.\n)pdfformaterror
<00030000>.findcmap{TTFDEBUG{(Adding cmap 3.0)=}if
5 1 roll pop pop pop pop
prebuilt_encoding null ne{prebuilt_encoding .invert_encoding .pdfmapchars/Encoding prebuilt_encoding}{
AdobeGlyphList .pdfmapchars/Encoding/SymbolEncoding .findencoding}ifelse}if}if}if}ifelse}ifelse}{<00030001>.findcmap{
prebuilt_encoding null ne{TTFDEBUG{(Using cmap 3.1 with prebuilt_encoding for non-symbolic.)=}if
/.allow_uniXXXX_glyph_names//true def
AdobeGlyphList prebuilt_encoding .invert_encoding dup{pop
TTFDEBUG{(check glypname /)print dup =only flush}if
2 index 1 index .knownget{2 index 3 1 roll
TTFDEBUG{( redefine codepoint by AdobeGlyphList, )print dup == flush}if
put}{TTFDEBUG{( unknown glyphname, leave as it is )print flush}if
pop}ifelse}forall
exch pop
TTFDEBUG{dup(<<\n)print{exch(    )print =only(\t)print ==}forall(>>\n)print flush}if
.pdfmapchars/Encoding prebuilt_encoding}{TTFDEBUG{(Using cmap 3.1 for non-symbolic.)=}if
AdobeGlyphList .pdfmapchars/Encoding/WinAnsiEncoding .findencoding}ifelse}{<00010000>.findcmap{
TTFDEBUG{(Using cmap 1.0 for non-symbolic.)=}if
.romanmacdict .pdfmapchars/Encoding
prebuilt_encoding null ne{prebuilt_encoding}{/MacRomanEncodingForTrueType .findencoding}ifelse}{.charkeys}ifelse}ifelse}ifelse
TTFDEBUG{(.pdfcharkeys end)=}if}bind def/.loadpdfttfont{TTFDEBUG{(.loadpdfttfont Encoding=)print dup ==}if
/prebuilt_encoding gput/is_symbolic gput//false 0 .loadttfonttables
.makesfnts
.getpost
.pickcmap
mark
.pdfcharkeys
.ttkeys
.definettfont}bind def
.currentglobal true .setglobal
.cspace_util begin/icc_comp_map_dict
mark 1/DeviceGray 3/DeviceRGB 4/DeviceCMYK .dicttomark
def/get_icc_alternative_space{1 get dup/Alternate .knownget{exch pop}{/N get//icc_comp_map_dict exch get}ifelse}bind def
colorspacedict/ICCBased
mark/cs_potential_indexed_base true/cs_potential_pattern_base true/cs_potential_alternate true/cs_potential_icc_alternate false
/cs_get_ncomps{1 get/N get}bind/cs_get_range{1 get dup/Range .knownget{exch pop}
{/N get 2 mul//dflt_range_4 exch 0 exch getinterval}ifelse}bind/cs_get_default_color{1 get/N get{0}repeat}bind
/cs_get_currentgray{//get_icc_alternative_space exec//.cs_get_currentgray exec}bind/cs_get_currentrgb
{//get_icc_alternative_space exec//.cs_get_currentrgb exec}bind/cs_get_currentcmyk
{//get_icc_alternative_space exec//.cs_get_currentcmyk exec}bind/cs_validate{//check_cie_cspace exec
dup 1 get
dup/N get
dup type/integertype ne//setcspace_typecheck
if//icc_comp_map_dict exch known not//setcspace_rangecheck
if
dup/DataSource get
dup type dup/stringtype ne exch/filetype ne and//setcspace_typecheck
if
rcheck not//setcspace_invalidaccess
if
dup/Range .knownget{//check_array exec{type dup/integertype ne exch/realtype ne and//setcspace_typecheck
if}forall}if/Alternate .knownget{//.cs_validate exec
dup//.cs_potential_icc_alternate exec not{0 get/ICCBased ne//setcspace_rangecheck
if}{pop}ifelse}if}bind/cs_substitute{dup//get_icc_alternative_space exec//.cs_substitute exec
2 copy eq
1 index//.cs_potential_icc_alternate exec not
or{pop pop dup}{exch pop
.currentglobal 3 1 roll//false .setglobal
1 index dup length array copy
dup 1 2 copy get dup length dict copy
dup/Alternate 7 -1 roll put
put
3 -1 roll .setglobal}ifelse}bind/cs_prepare{dup 1 get/DataSource get type/stringtype eq{.currentglobal exch//false .setglobal
2 copy eq{dup length array copy
dup 1 2 copy get dup length dict copy put}if
dup 1 2 copy get dup/DataSource 2 copy get/ReusableStreamDecode filter
put put
exch .setglobal}if}bind/cs_install{dup//get_icc_alternative_space exec//_setcolorspace_nosub exec/.seticcspace where
{pop//false}{//true}ifelse
NOCIE or//pop_1{mark exch 1 get{.seticcspace}.internalstopped
cleartomark}ifelse}bind/cs_prepare_color{dup 1 get/N get//check_num_stack exec pop}bind/cs_complete_setcolor//pop_1
.dicttomark
put
end
NOPSICC{(%END PSICC).skipeof}if
systemdict begin/.ProcessICCcomment{dup(%%BeginICCProfile)anchorsearch{pop pop
DEBUG{(.ProcessICCcomment found %%BeginICCProfile)print flush}if
1 index 0(%%EndICCProfile)/SubFileDecode filter[{counttomark 1 add index
64000 string readhexstring
not{exit}if}loop]exch closefile
0 1 index{length add}forall
.bigstring
exch 0 exch{2 copy length add
3 1 roll 3 index 3 1 roll putinterval}forall
pop
mark/AsyncRead true .dicttomark/ReusableStreamDecode filter/DeviceCMYK setcolorspace
<</DataSource 3 -1 roll/N 4
>>{.seticcspace}stopped{/DeviceRGB setcolorspace
dup/N 3 put{.seticcspace}stopped{/DeviceGray setcolorspace
dup/N 1 put{.seticcspace}stopped{QUIET not{(   *** Unable to load ICC profile from PostScript DSC comments ***)= flush}if
pop}if}if}if}{pop}ifelse}bind def/.ProcessICCcomment load/exec load
currentuserparams/ProcessDSCComment get
dup null eq{pop{pop pop}}if/exec load
4 array astore cvx readonly
<</ProcessDSCComment 3 -1 roll >>setuserparams
end
%END PSICC
.setglobal
{/invalidcontext/invalidid}{.registererror}forall/.savelocalstate{.currentglobal true .setglobal
//systemdict/savedlocaldicts mark//systemdict{dup gcheck{pop pop}{dup type/dicttype eq{dup maxlength dict .copydict readonly}{
pop pop}ifelse}ifelse}forall .dicttomark readonly put
false .setglobal
userdict/localdicts mark savedlocaldicts{pop dup load}forall/internaldict dup load
.dicttomark readonly put
true .setglobal//systemdict/savedinitialgstate gstate readonly put
.setglobal}.bind def/.copylocal{dup maxlength dict .copydict
1 index load wcheck not{readonly}if}.bind def/.initlocaldicts{-2 vmreclaim
.currentglobal//systemdict begin
false .setglobal
countdictstack array dictstack{dup gcheck not{exit}if pop}forall
mark savedlocaldicts{1 index/userdict eq{counttomark 1 add index .copydict}{1 index/userparams eq{userparams .copydict}{
.copylocal}ifelse}ifelse}forall/internaldict dup .makeinternaldict .makeoperator
.dicttomark readonly/localdicts exch put
localdicts{.forcedef}forall
userparams readonly .setuserparams/savedinitialgstate .systemvar setgstate gsave
end .setglobal}odef/.proccheck{dup xcheck
exch type dup/arraytype eq exch/packedarraytype eq or and}bind def/localfork{.currentglobal true .setglobal 3 index
dup .proccheck not{pop .setglobal/localfork .systemvar/typecheck signalerror}if{exec .initlocaldicts}aload pop
3 1 roll 3 packedarray cvx
4 1 roll 5 -1 roll pop .setglobal .localfork}odef/.postfork{savedlocaldicts/userparams get userparams .copydict readonly pop
}odef/fork{.currentglobal false .setglobal 1 index
dup .proccheck not{pop .setglobal/fork .systemvar/typecheck signalerror}if{exec .postfork}aload pop
3 1 roll 3 packedarray cvx
3 1 roll exch pop .setglobal .fork}odef/sethalftonephase{-1 2 index 2 index .setscreenphase pop pop}odef/currenthalftonephase{
0 .currentscreenphase}odef
.imagetypes 2/.image2 load put/.deviceinfodict mark/Colors null/GrayValues null/RedValues null/GreenValues null
/BlueValues null/ColorValues null
.dicttomark readonly def/deviceinfo{currentdevice//.deviceinfodict .getdeviceparams .dicttomark
dup begin/ColorValues .knownget{0 le{currentdict/ColorValues undef}{Colors 3 eq{1}{GrayValues}ifelse
RedValues mul GreenValues mul BlueValues mul ColorValues ne{currentdict/GrayValues undef
currentdict/RedValues undef
currentdict/GreenValues undef
currentdict/BlueValues undef}if}ifelse}if
currentdict end readonly}odef/.wtdict mark/wtranslation null
.dicttomark readonly def/wtranslation{currentdevice//.wtdict .getdeviceparams exch pop exch pop aload pop}odef
currentdict/.wtdict .undef/rectviewclip{newpath .rectappend viewclip}odef
mark/Clear/Copy/Sover/Sin/Sout/Satop/Dover/Din/Dout/Datop/Xor/PlusD/PlusL/Highlight
counttomark{counttomark 1 sub def}repeat pop/readimage{.sizeimageparams exch{exch pop 1 index{1 add}if
dup 1 eq{pop false}{dup array 4 1 roll 3 add 2 roll astore 3 1 roll true}ifelse}{pop pop false}ifelse
8 -4 roll matrix .sizeimagebox pop 8 4 roll
.currentglobal false .setglobal 9 1 roll
exch{1}{0}ifelse exch
exch 4 1 roll 8 array astore exch .setglobal{dup 3 get 0 eq{pop exit}if
aload 9 1 roll pop exch pop currentdevice 7 1 roll
.sizeimageparams pop pop exch .getbitsrect
3 -1 roll
dup 1 2 copy get 5 index add put
dup 3 2 copy get 6 -1 roll sub put
dup 5 get exch 7 get{0 1 2 index length 1 sub{2 index length 2 index length idiv
dup 2 index mul exch
4 index 3 1 roll getinterval 4 1 roll
2 copy get 4 1 roll pop}for
exch pop length 2 mul .execn}{exec}ifelse}//systemdict/exec get 3 packedarray cvx loop}bind odef
img_utils_dict begin/.alphaimage where{pop
currentglobal true setglobal/alphaimage{//true//.colorimage
stopped{/alphaimage .systemvar $error/errorname get signalerror}if}.bind systemdict begin odef end
setglobal}if
end/sizeimage{.sizeimagebox 5 -2 roll pop pop
.sizeimageparams 3 -1 roll 4 1 roll}bind odef
/EPSBoundingBoxState 5 def/EPSBoundingBoxSetState{//systemdict/EPSBoundingBoxState 3 -1 roll .forceput}.bind odef
/EPSBoundingBoxParse{mark exch
token{exch token{exch token{exch token{exch pop}if}if}if}if
counttomark
4 eq{5 -1 roll pop
true}{cleartomark false}ifelse}bind def/EPSBoundingBoxFitPage{EPSDEBUG{(gs_epsf.ps: Rescaling EPS to fit page\n)print flush}if
clippath pathbbox newpath
3 index 3 index translate
exch 4 -1 roll sub 3 1 roll exch sub
4 2 roll 5 index 5 index 4 2 roll
exch 4 -1 roll sub 3 1 roll exch sub
4 2 roll
exch 4 -1 roll div 3 1 roll exch div
1 index 1 index lt{pop}{exch pop}ifelse
dup scale
exch neg exch neg translate}bind def/EPSBoundingBoxCrop{EPSDEBUG{
(gs_epsf.ps: Setting pagesize from EPS bounding box\n)print flush}if
exch 3 index sub exch 2 index sub
<</PageSize[5 -2 roll]>>setpagedevice
neg exch neg exch translate}bind def/EPSBoundingBoxProcess{//systemdict/EPSBoundingBoxState get 1 index lt{
exch EPSBoundingBoxParse{//systemdict/EPSCrop known{EPSBoundingBoxCrop}{//systemdict/EPSFitPage known{EPSBoundingBoxFitPage}{
clippath pathbbox newpath{5 -1 roll lt{6{pop}repeat true exit}if
4 -1 roll lt{4{pop}repeat true exit}if
3 -1 roll gt{2{pop}repeat true exit}if
exch gt{true exit}if
false exit}loop
QUIET not and/EPSBoundingBoxState .systemvar 1 and 1 eq and{
(\n   **** Warning: Some of the BoundingBox for the EPS file will be clipped.)=
(                 Use -dEPSCrop or -dEPSFitPage to avoid clipping.\n)=
flush
1 add}if}ifelse}ifelse
EPSBoundingBoxSetState}{pop}ifelse}{pop pop}ifelse}bind def/ProcessEPSComment{//systemdict/EPSBoundingBoxState get 3 lt{dup
(%%EndComments)anchorsearch{pop pop
5 EPSBoundingBoxSetState}{(%%BoundingBox:)anchorsearch{pop
EPSDEBUG{(gs_epsf.ps: found %%BoundingBox\n)print flush}if
1 EPSBoundingBoxProcess}{(%%HiResBoundingBox:)anchorsearch{pop
EPSDEBUG{(gs_epsf.ps: found %%HiResBoundingBox\n)print flush}if
3 EPSBoundingBoxProcess}{pop}ifelse}ifelse}ifelse}if}bind def/EPSBoundingBoxInit{systemdict/NOEPS known not{
/ProcessEPSComment load/exec load
currentuserparams/ProcessDSCComment get
dup null eq{pop{pop pop}}if/exec load
4 array astore cvx readonly
<</ProcessDSCComment 3 -1 roll >>setuserparams}if}bind def/.runNoEPS/run load def/.runEPS{/runEPS_save save def
/runEPS_dict_count countdictstack def/runEPS_op_count count 2 sub def/runEPS_page_count currentpagedevice/PageCount get def
0 EPSBoundingBoxSetState
.runNoEPS
currentpagedevice/PageCount get runEPS_page_count sub 0 eq{/showpage load exec}if
count runEPS_op_count sub{pop}repeat
countdictstack runEPS_dict_count sub{end}repeat
runEPS_save restore}bind def/run{dup type/filetype ne{(r)file}if
dup(%!PS-Adobe-).peekstring{(%!PS-Adobe-)eq{dup(%!PS-Adobe-X.X EPSF-X.X).peekstring{(EPSF)search{pop pop pop
EPSDEBUG{(runEPS: Found EPS\n)print flush}if
systemdict/NOEPS known{cvx .runNoEPS}{cvx .runEPS}ifelse}{EPSDEBUG{(runEPS: Normal DSC\n)print flush}if
pop
cvx .runNoEPS}ifelse}{EPSDEBUG{(runEPS: Short DSC\n)print flush}if
pop
cvx .runNoEPS}ifelse}{EPSDEBUG{(runEPS: Not DSC\n)print flush}if
cvx .runNoEPS}ifelse}{EPSDEBUG{(runEPS: Short non-DSC\n)print flush}if
pop
cvx .runNoEPS}ifelse}bind odef/.runnoepsf/run load def/.epsfheader<C5D0D3C6>def/run{dup type/filetype ne{(r)file}if
dup(    ).peekstring{.epsfheader eq{dup(    )readstring exch pop}{false}ifelse}{pop false}ifelse{2{1 0 4
{2 index read not{pop exit}if
2 index mul add exch 256 mul exch}repeat exch pop exch}repeat
dup 4 -1 roll 12 sub()/SubFileDecode filter flushfile
exch()/SubFileDecode filter cvx run}{.runnoepsf}ifelse}odef
userdict begin/.runstdin{{(%stdin)run}execute0}bind def
end
systemdict/.FAPIavailable known{.FAPIavailable}{false}ifelse not{(%END FAPI).skipeof}if
languagelevel 2 .setlanguagelevel
15 dict begin/EmbedFontObjectsQuery mark/.EmbedFontObjects 0
.dicttomark def/is_device_compatible_to_FAPI{currentdevice//EmbedFontObjectsQuery .getdeviceparams
dup mark eq{pop true}{exch pop exch pop 0 eq}ifelse}bind def/Config
<<
systemdict/FAPIconfig known{/FAPIconfig .systemvar}{(FAPIconfig)}ifelse .runlibfile/ServerOptions 2 dict
>>def
systemdict/.FAPIconfig//Config put()systemdict/UFST_SSdir .knownget{(UFST_SSdir=)exch concatstrings concatstrings}if
systemdict/UFST_PlugIn .knownget{1 index length 0 ne{exch .filenamelistseparator concatstrings exch}if
(UFST_PlugIn=)exch concatstrings concatstrings}if
dup length 0 ne{//Config/ServerOptions get exch/UFST exch put}{pop}ifelse/FontEmulationProcs/ProcSet findresource{def}forall
currentdict/super.complete_instance currentdict/complete_instance get put/RefinePath{exch begin//Config exch get/Path exch
Path false .file_name_combine not{exch(Can't combine paths )print print( and )print =
/RefinePath cvx/configurationerror signalerror}if
def
currentdict end}bind def/complete_instance{//super.complete_instance exec
dup/CIDFontName known{/CIDFontPath}{/FontPath}ifelse//RefinePath exec}bind def/IsMyRecord
{dup type/dicttype eq{dup/FAPI known}{false}ifelse}bind def/IsActive{pop//is_device_compatible_to_FAPI exec}bind def
/FontRecordVirtualMethods//RecordVirtualMethodsStub dup length 2 add dict copy begin/IsActive//IsActive def/MakeInstance
{currentglobal 3 1 roll true setglobal//FontOptions//complete_instance exec
2 copy//GetSize exec
4 3 roll setglobal}bind def
currentdict end def/CIDFontRecordVirtualMethods//RecordVirtualMethodsStub dup length 3 add dict copy begin
/GetCSI//TranslateCSI def/IsActive//IsActive def/MakeInstance{currentglobal 3 1 roll true setglobal
//CIDFontOptions//complete_instance exec
2 copy//GetSize exec
4 3 roll setglobal}bind def
currentdict end def/ReadFCOfontmap:{/fontfile exch def{currentfile =string readline not{pop exit}if
dup length 0 ne{0()/SubFileDecode filter
dup token not{closefile}{dup/EndFCOfontmap cvx eq{pop closefile exit}if
exch dup token not{/ReadFCOfontmap: cvx/rangecheck signalerror}if
exch dup token not{/StandardEncoding}{dup type/nametype ne{/ReadFCOfontmap: cvx/rangecheck signalerror}if}ifelse
findencoding
exch dup token not{null}{dup type/nametype ne{/ReadFCOfontmap: cvx/rangecheck signalerror}if/Decoding findresource}ifelse
exch closefile
4 3 roll
<</Path fontfile/FontType 1/FAPI/UFST/SubfontId counttomark 2 add -1 roll/Decoding counttomark 2 add -1 roll
dup null eq{pop pop}if/Encoding counttomark 2 add -1 roll
>>}ifelse}{pop}ifelse}loop
currentdict/fontfile undef}bind def/MappedCategoryRedefiner/ProcSet findresource/Redefine get/Redefine exch def
4 dict begin/CategoryName/Font def/MapFileName systemdict/FAPIfontmap known{/FAPIfontmap .systemvar}{(FAPIfontmap)}ifelse def
/VerifyMap{pop}bind def/PreprocessRecord{//IsMyRecord exec dup{pop dup/RecordVirtualMethods//FontRecordVirtualMethods put
true}if}bind def
currentdict end Redefine
4 dict begin/CategoryName/CIDFont def
/MapFileName systemdict/FAPIcidfmap known{/FAPIcidfmap .systemvar}{(FAPIcidfmap)}ifelse def/VerifyMap{pop}bind def
/PreprocessRecord{//IsMyRecord exec dup{pop dup/RecordVirtualMethods//CIDFontRecordVirtualMethods put
true}if}bind def
currentdict end Redefine/FAPI_hook_debug
FAPIDEBUG{{exec}}{{pop}}ifelse
bind def/FAPI_hook_warn
QUIET{{pop}}{{exec}}ifelse
bind def/FAPI_is_hook_disabled{/FAPI_hook_disable/MappedCategoryRedefiner/ProcSet findresource/execstack_lookup get exec
null ne}bind def/FAPIhook_aux{{(FAPIhook )print 1 index =}//FAPI_hook_debug exec
dup/FAPI known{{//PrintFontRef exec( is mapped to FAPI=)print dup/FAPI get =}//FAPI_hook_warn exec
true//.FAPIrebuildfont//ChooseDecoding exec}{dup/PathLoad known dup{
{(PathLoad known for the font )print//PrintFontRef exec(.)=}//FAPI_hook_debug exec}{pop//FAPI_is_hook_disabled exec dup{pop
{(FAPIhook is in .loadfont context for the font )print//PrintFontRef exec(.)=}//FAPI_hook_debug exec
true}if}ifelse{/HookDiskFonts}{/HookEmbeddedFonts}ifelse//Config exch get
1 index//GetFontType exec//FindInArray exec
{{(Trying to render the font )print//PrintFontRef exec( with FAPI...)=}//FAPI_hook_debug exec//.FAPIpassfont{
{//PrintFontRef exec( is being rendered with FAPI=)print dup/FAPI get =}//FAPI_hook_warn exec
false//.FAPIrebuildfont//ChooseDecoding exec}{
{(Can't render )print//PrintFontRef exec( with FAPI, will do with native GS renderer.)=}//FAPI_hook_warn exec}ifelse}{
{(The font )print//PrintFontRef exec( doesn't need to render with FAPI.)=}//FAPI_hook_debug exec}ifelse}ifelse}bind def
/FAPIhook{//is_device_compatible_to_FAPI exec{//FAPIhook_aux exec}{
{(FAPIhook is disabled for the current device.)=}//FAPI_hook_debug exec}ifelse}bind def/.buildfont1
{//.buildfont1 exec//FAPIhook exec}bind/.buildfont2{//.buildfont2 exec//FAPIhook exec}bind/.buildfont42
{//.buildfont42 exec//FAPIhook exec}bind/.buildfont9{//.buildfont9 exec//FAPIhook exec}bind/.buildfont10
{//.buildfont10 exec//FAPIhook exec}bind/.buildfont11{//.buildfont11 exec//FAPIhook exec}bind
end
odef odef odef odef odef odef
.setlanguagelevel
%END FAPI
/.a2112[2 1 1 2]readonly def/.a1111[1 1 1 1]readonly def/.standardfonts[
/Courier/Courier-Bold/Courier-Oblique/Courier-BoldOblique/Helvetica/Helvetica-Bold/Helvetica-Oblique/Helvetica-BoldOblique
/Times-Roman/Times-Bold/Times-Italic/Times-BoldItalic/Symbol/ZapfDingbats]readonly def/.defaultImageDict mark
/QFactor 0.9/Blend 1/HSamples .a2112/VSamples .a2112
.dicttomark readonly def/.distillercommon mark/AlwaysEmbed[]/AntiAliasColorImages false/AntiAliasGrayImages false
/AntiAliasMonoImages false/ASCII85EncodePages false/AutoFilterColorImages true/AutoFilterGrayImages true
/AutoPositionEPSFiles true/Binding/Left/CalCMYKProfile(None)/CalGrayProfile(None)/CalRGBProfile(None)/ColorImageDepth -1
/ColorImageDict .defaultImageDict/ColorImageDownsampleThreshold 1.5/ColorImageFilter/DCTEncode/CompressPages true
/ConvertImagesToIndexed true/DefaultRenderingIntent/Default/DetectBlends true/DownsampleColorImages true
/DownsampleGrayImages true/DownsampleMonoImages true/EmitDSCWarnings false/EncodeColorImages true/EncodeGrayImages true
/EncodeMonoImages true/EndPage -1/GrayImageDepth -1/GrayImageDict .defaultImageDict/GrayImageDownsampleThreshold 1.5
/GrayImageFilter/DCTEncode/ImageMemory 524288/LockDistillerParams false/MaxSubsetPct 100/MonoImageDepth -1/MonoImageDict mark
/K -1
.dicttomark readonly/MonoImageDownsampleThreshold 1.5/MonoImageFilter/CCITTFaxEncode/OffOptimizations 0/OPM 1/Optimize true
/ParseDSCComments true/ParseDSCCommentsForDocInfo true/PDFXTrimBoxToMediaBoxOffset[0 0 0 0]/PDFXSetBleedBoxToMediaBox true
/PDFXBleedBoxToTrimBoxOffset[0 0 0 0]/PreserveCopyPage true/PreserveHalftoneInfo false/sRGBProfile(None)/StartPage 1
/SubsetFonts true/TransferFunctionInfo/Preserve/UseFlateCompression true/UsePrologue false
.dicttomark readonly def/.distillersettings mark/default mark/AutoRotatePages/PageByPage/CannotEmbedFontPolicy/Warning
/ColorACSImageDict .defaultImageDict/ColorConversionStrategy/LeaveColorUnchanged/CreateJobTicket false/DoThumbnails false
/DownsampleColorImages false/DownsampleGrayImages false/DownsampleMonoImages false/EmbedAllFonts true
/GrayACSImageDict .defaultImageDict/NeverEmbed .standardfonts/Optimize false/PreserveEPSInfo true/PreserveOPIComments true
/PreserveOverprintSettings true/UCRandBGInfo/Preserve
.dicttomark readonly/.screenACSImageDict mark/QFactor 0.76/Blend 1/ColorTransform 1/HSamples .a2112/VSamples .a2112
.dicttomark readonly def/screen mark/AutoRotatePages/PageByPage/CannotEmbedFontPolicy/Warning
/ColorACSImageDict .screenACSImageDict/ColorConversionStrategy/sRGB/ColorImageDownsampleType/Average/ColorImageResolution 72
/CompatibilityLevel 1.3/CreateJobTicket false/DoThumbnails false/EmbedAllFonts true/GrayACSImageDict .screenACSImageDict
/GrayImageDownsampleType/Average/GrayImageResolution 72/MonoImageDownsampleType/Average/MonoImageResolution 300
/NeverEmbed .standardfonts/PreserveEPSInfo false/PreserveOPIComments false/PreserveOverprintSettings false/UCRandBGInfo/Remove
.dicttomark readonly/ebook mark/AutoRotatePages/All/CannotEmbedFontPolicy/Warning/ColorACSImageDict .screenACSImageDict
/ColorConversionStrategy/sRGB/ColorImageDownsampleType/Bicubic/ColorImageResolution 150/CompatibilityLevel 1.4
/CreateJobTicket false/DoThumbnails false/EmbedAllFonts true/GrayACSImageDict .screenACSImageDict
/GrayImageDownsampleType/Bicubic/GrayImageResolution 150/MonoImageDownsampleType/Bicubic/MonoImageResolution 300
/NeverEmbed .standardfonts/PreserveEPSInfo false/PreserveOPIComments false/PreserveOverprintSettings false/UCRandBGInfo/Remove
.dicttomark readonly/.printerACSImageDict mark/QFactor 0.4/Blend 1/ColorTransform 1/HSamples .a1111/VSamples .a1111
.dicttomark readonly def/printer mark/AutoRotatePages/None/CannotEmbedFontPolicy/Warning/ColorACSImageDict .printerACSImageDict
/ColorConversionStrategy/UseDeviceIndependentColor/ColorImageDownsampleType/Bicubic/ColorImageResolution 300
/CompatibilityLevel 1.4/CreateJobTicket true/DoThumbnails false/EmbedAllFonts true/GrayACSImageDict .printerACSImageDict
/GrayImageDownsampleType/Bicubic/GrayImageResolution 300/MonoImageDownsampleType/Bicubic/MonoImageResolution 1200/NeverEmbed[]
/PreserveEPSInfo true/PreserveOPIComments true/PreserveOverprintSettings true/UCRandBGInfo/Preserve
.dicttomark readonly/.prepressACSImageDict mark/QFactor 0.15/Blend 1/ColorTransform 1/HSamples .a1111/VSamples .a1111
.dicttomark readonly def/prepress mark/AutoRotatePages/None/CannotEmbedFontPolicy/Error/ColorACSImageDict .prepressACSImageDict
/ColorConversionStrategy/LeaveColorUnchanged/ColorImageDownsampleType/Bicubic/ColorImageResolution 300/CompatibilityLevel 1.4
/CreateJobTicket true/DoThumbnails true/EmbedAllFonts true/GrayACSImageDict .prepressACSImageDict
/GrayImageDownsampleType/Bicubic/GrayImageResolution 300/MonoImageDownsampleType/Bicubic/MonoImageResolution 1200/NeverEmbed[]
/PreserveEPSInfo true/PreserveOPIComments true/PreserveOverprintSettings true/UCRandBGInfo/Preserve
.dicttomark readonly/PSL2Printer mark/AutoRotatePages/None/CannotEmbedFontPolicy/Error/ColorACSImageDict .prepressACSImageDict
/ColorConversionStrategy/LeaveColorUnchanged/ColorImageDownsampleType/Bicubic/ColorImageResolution 600/CompatibilityLevel 1.2
/DoThumbnails false/EmbedAllFonts true/GrayACSImageDict .prepressACSImageDict/GrayImageDownsampleType/Bicubic
/GrayImageResolution 600/MonoImageDownsampleType/Bicubic/MonoImageResolution 1200/NeverEmbed[]/PreserveEPSInfo true
/PreserveOPIComments true/PreserveOverprintSettings true/UCRandBGInfo/Preserve/PreserveHalftoneInfo true
/TransferFunctionInfo/Preserve/MaxViewerMemorySize 8000000/CompressPages false/CompressFonts false/ASCII85EncodePages true
.dicttomark readonly
.dicttomark readonly def/.setpdfwrite{currentuserparams/VMThreshold get 3000000 .max setvmthreshold}bind def
/.write_small_positive_real{1 index(.)writestring{dup 100000000 mul
dup 10 mul 1 ge{pop exit}if
exch pop
1 index(00000000)writestring}loop{dup 10 mul
dup 10 mul 1 ge{pop exit}if
exch pop
1 index(0)writestring}loop
100000000
dup 10 idiv 3 1 roll mul 0.5 add cvi
2 copy le{pop pop(1)writestring}{2 index(0)writestring
exch{10 idiv dup
2 index exch idiv(0123456789)exch 1 getinterval
3 index exch writestring
dup 3 2 roll exch mod
dup 0 eq{exit}if
exch}loop
pop pop pop}ifelse}bind def/.pdf===dict mark/arraytype{dup xcheck{({)(})}{([)(])}ifelse
4 1 roll 2 index exch writestring()exch{exch 2 index exch writestring
1 index exch pdf===only( )}forall pop exch writestring}bind/packedarraytype 1 index/dicttype{1 index(<<\n)writestring
{2 index 3 -1 roll pdf===only 1 index( )writestring
1 index exch pdf===only dup(\n)writestring}forall(>>)writestring}bind/nametype{
dup .namestring(\000\004\011\012\014\015 %()/<>[]{}).stringbreak null ne{dup .namestring(\000).stringbreak null ne{
/rangecheck signalerror}if
1 index<0000>writestring 1 index exch write===only 0 write}{write===only}ifelse}bind/realtype{dup dup 0 lt{neg}if 0.01 lt{
dup 0 eq{pop(0)writestring}{dup 0 lt{1 index(-)writestring neg}if
.write_small_positive_real}ifelse}{write===only}ifelse}bind
.dicttomark readonly def/pdf===only{.pdf===dict 1 index type .knownget{exec}{write===only}ifelse}bind def
/.pdfcvbuf 30 string def
userdict/.pdfcvstring()put/.pdfcvs{currentglobal exch false .setglobal/.pdfcvstring()store{pop dup length 0 eq{pop}{
/.pdfcvstring .pdfcvstring 3 -1 roll concatstrings store}ifelse//.pdfcvbuf}/NullEncode filter dup 3 -1 roll pdf===only
closefile
.setglobal .pdfcvstring}bind def/.pdfputparams{currentdevice null false counttomark 1 add 3 roll
{.putdeviceparams}.currentpagedevice pop{.setpagedevice}3 .execn}bind def/.pdfcvsloop{matrix currentmatrix .pdfcvs 4 1 roll
counttomark 1 add 2 roll
counttomark .localvmarray astore exch pop
3 1 roll
2 index length 3 sub{2 copy 2 copy get .pdfcvs put pop}for}bind def/.pdfcvsall{0 1 .pdfcvsloop}bind def/.pdfcvseven{
1 2 .pdfcvsloop}bind def/.pdfcvsnone{100000 1 .pdfcvsloop}bind def/.pdfcvsfirst{.pdfcvsnone
dup 0 2 copy get .pdfcvs put}bind def/.pdfmarkparams mark/PUT{counttomark 3 eq{1 index type/dicttype eq{
pop{}forall/.PUTDICT .pdfcvsall}{pop dup type/filetype eq{{dup 64000 string readstring not{exch exit}if
exch}loop closefile}if/.PUTSTREAM .pdfcvsfirst}ifelse}{.pdfcvsall}ifelse}bind/PUTINTERVAL{pop aload pop/.PUTINTERVAL .pdfcvsall
}bind
.dicttomark readonly def/.pdfparamerror{counttomark 4 add 2 roll cleartomark pop pop pop
.systemvar exch signalerror}bind def/pdfmark{dup/SP eq{gsave[1 0 0 1 0 0]setmatrix 0 setlinewidth
newpath -3 -3 moveto closepath stroke
grestore}if
dup/PS eq systemdict/PDFX .knownget not{false}if
systemdict/PDFA .knownget not{false}if or and{pop{dup mark eq{pop exit}if
1 index/DataSource eq{exch pop
cvx exec}{pop pop}ifelse}loop}{counttomark 1 add copy//.pdfmarkparams 1 index .knownget{exec}{.pdfcvsall}ifelse
mark/pdfmark 3 -1 roll .pdfputparams
dup type/booleantype ne{/pdfmark .pdfparamerror}if cleartomark}ifelse}odef
userdict/pdfmark .undef
currentdict/.pdfmarkparams .undef/.pdf_hook_DSC_Creator{currentdevice .devicename/pdfwrite eq{/Creator .knownget{
(PScript5.dll)search{pop pop
systemdict/resourcestatus dup{dup/FontType eq 2 index 32 eq and{pop pop false}{resourcestatus}ifelse
}bind .makeoperator .forceput}if
pop}if}{pop}ifelse}bind def/.pdfdsc_dict 2 dict def/.pdfdsc{
0 get dup null ne{4 copy exch pop exec pop}{pop}ifelse 3 -1 roll pop
20 .localvmdict 1 index{3 copy put pop pop}forall
3 -1 roll .parse_dsc_comments
1 index//.pdf_hook_DSC_Creator exec
dup/NOP ne 2 index length 1 gt or{PDFWRDEBUG{(**** DSC comment: )print dup == 1 index === flush}if
exch mark 4 1 roll{3 index 2 index known{pop pop}{.pdfcvs 4 -2 roll}ifelse}forall exch pop counttomark .localvmarray astore
mark/DSC 3 -1 roll .pdfputparams
dup type/booleantype ne{/DSC .pdfparamerror}{cleartomark}ifelse}{pop pop pop}ifelse}bind def
currentdict/.pdf_hook_DSC_Creator undef/.initialize_dsc_parser where{pop
3000{currentglobal true setglobal
2 dict dup .initialize_dsc_parser readonly
currentuserparams/ProcessDSCComment get
1 array astore//.pdfdsc/exec load 4 array astore cvx readonly
<</ProcessDSCComment 3 -1 roll >>setuserparams
setglobal}bind .schedule_init}if/.distillerparamkeys mark/ASCII85EncodePages{}/AutoRotatePages{}/Binding{}/CompressPages{}
/DefaultRenderingIntent{}/DetectBlends{}/DoThumbnails{}/ImageMemory{}/LockDistillerParams{}/LZWEncodePages{}/OPM{}
/PreserveHalftoneInfo{}/PreserveOPIComments{}/PreserveOverprintSettings{}/TransferFunctionInfo{}/UCRandBGInfo{}
/UseFlateCompression{}/CoreDistVersion{}/CompatibilityLevel{}/PDFEndPage{pop pop}/PDFStartPage{pop pop}/Optimize{}
/ParseDSCCommentsForDocInfo{}/ParseDSCComments{}/EmitDSCWarnings{}/CreateJobTicket{}/PreserveEPSInfo{}/AutoPositionEPSFiles{}
/PreserveCopyPage{}/UsePrologue{}/OffOptimizations{}/PDFXTrimBoxToMediaBoxOffset{}/PDFXSetBleedBoxToMediaBox{}
/PDFXBleedBoxToTrimBoxOffset{}/ColorACSImageDict{}/AntiAliasColorImages{}/AutoFilterColorImages{}/ColorImageDepth{}
/ColorImageDict{}/DownsampleColorImages{}/ColorImageDownsampleThreshold{}/ColorImageDownsampleType{}/EncodeColorImages{}
/ColorImageFilter{}/ColorImageResolution{}/CalCMYKProfile{}/CalGrayProfile{}/CalRGBProfile{}/sRGBProfile{}
/ColorConversionStrategy{}/ConvertCMYKImagesToRGB{}/ConvertImagesToIndexed{}/GrayACSImageDict{}/AntiAliasGrayImages{}
/AutoFilterGrayImages{}/GrayImageDepth{}/GrayImageDict{}/DownsampleGrayImages{}/GrayImageDownsampleThreshold{}
/GrayImageDownsampleType{}/EncodeGrayImages{}/GrayImageFilter{}/GrayImageResolution{}/AntiAliasMonoImages{}/MonoImageDepth{}
/MonoImageDict{}/DownsampleMonoImages{}/MonoImageDownsampleThreshold{}/MonoImageDownsampleType{}/EncodeMonoImages{}
/MonoImageFilter{}/MonoImageResolution{}/AlwaysEmbed{dup length 0 gt{dup 0 get false eq
{dup length 1 sub 1 exch getinterval exch pop/~AlwaysEmbed exch}if}if}/NeverEmbed{dup length 0 gt{dup 0 get false eq
{dup length 1 sub 1 exch getinterval exch pop/~NeverEmbed exch}if}if}/CannotEmbedFontPolicy{}/EmbedAllFonts{}/MaxSubsetPct{}
/SubsetFonts{}/DSCEncodingToUnicode{}.dicttomark readonly def/.distillerdevice
{currentdevice .devicename dup/pdfwrite eq exch/ps2write eq or{currentdevice}{/pdfwrite finddevice}ifelse}bind def
/.setdistillerparams{.distillerdevice//null false mark 4 index{//.distillerparamkeys 2 index .knownget{exec}{pop pop}ifelse
}forall .putdeviceparamsonly
dup type/booleantype ne{/setdistillerparams .pdfparamerror}{pop pop pop}ifelse}odef/.currentdistillerparams{
.distillerdevice//.distillerparamkeys .getdeviceparams .dicttomark}odef/setdistillerparams{
currentdevice .devicename dup/pdfwrite ne exch/ps2write ne and{/setdistillerparams/undefined signalerror}if
.setdistillerparams}bind odef/currentdistillerparams{currentdevice .devicename dup/pdfwrite ne exch/ps2write ne and{
/currentdistillerparams/undefined signalerror}if
.currentdistillerparams}bind odef{currentdevice .devicename dup/pdfwrite eq exch/ps2write eq or{.where}{
.where pop dup//systemdict eq{pop false}{true}ifelse}ifelse}bind{/currentdistillerparams/setdistillerparams/pdfmark}
{.wheredict exch 2 index put}forall pop/known{/currentdistillerparams 1 index eq/setdistillerparams 2 index eq or
/pdfmark 2 index eq or{systemdict 2 index eq{known currentdevice .devicename dup/pdfwrite ne exch/ps2write ne and{pop false}if
}{known}ifelse}{known}ifelse}.bind odef/.make_DSC_translation_table{dup type/stringtype eq{cvn}if
dup type/nametype eq{/Encoding findresource}if
dup length array exch
0 1 2 index length 1 sub{dup 2 index exch get
dup dup null eq exch/.notdef eq or{pop -1}{dup//AdobeGlyphList exch .knownget{
dup type dup/arraytype eq exch/packedarraytype eq or{0 get}if
exch pop}{(DSCEncoding defines a character that is not in AdobeGlyphList : )exch .namestring concatstrings =
/.make_DSC_translation_table cvx/undefined signalerror}ifelse}ifelse
3 index
3 1 roll put}for
pop}bind def
1000{currentdevice .devicename/pdfwrite eq
systemdict/ProvideUnicode .knownget not{false}if or{currentglobal true setglobal
systemdict/.setupUnicodeDecoder known{/Unicode/Decoding resourcestatus{pop pop/Unicode/Decoding findresource
.setupUnicodeDecoder}{QUIET not{
(WARNING: /Unicode /Decoding resource is not accessible but it is useful for generating ToUnicode CMap.)=}if}ifelse}if
setglobal}if}bind .schedule_init
1010{/PDFSETTINGS where{pop/PDFSETTINGS load}{currentdevice .devicename/ps2write eq{/PSL2Printer}{/default}ifelse}ifelse
.distillersettings exch get
dup length .distillercommon length add dict begin
.distillercommon 2{{systemdict 2 index known{pop pop}{def}ifelse}forall}repeat
currentdevice .devicename/pdfwrite eq{systemdict/PDFX known systemdict/PDFA known or{/DSCEncoding where{
/DSCEncoding get .make_DSC_translation_table/DSCEncodingToUnicode exch def}if}if}if
currentdict end .setdistillerparams
.distillerdevice//null false mark .putdeviceparams
dup type/booleantype eq not{cleartomark pop}if pop pop}bind .schedule_init
.defaultdevicename/ps2write eq{mark/OPDFReadProcsetPath
systemdict/OPDFReadProcsetPath .knownget dup{1 index()eq{
(Configuration warning : empty OPDFReadProcsetPath, will use defaults.)=
systemdict/OPDFReadProcsetPath undef
pop pop false}if}if
not{mark(gs_mgl_e.ps)(gs_mro_e.ps)(gs_agl.ps)(opdfread.ps)()counttomark 1 sub{exch
.libfile{.filename}{false}ifelse not{(Configuration error : library file opdfread.ps not found !)=
(opdfread.ps)/undefinedfilename signalerror}if
.filenamelistseparator concatstrings concatstrings}repeat
exch pop}if/ps2write finddevice putdeviceprops pop}if
2000{currentdevice .devicename dup/pdfwrite eq exch/ps2write eq or{newpath fill}if}bind .schedule_init
/.setlanguagelevel where{pop 2 .setlanguagelevel/.fixresources where{pop .fixresources}if}if/ll3dict where{
pop 3 .setlanguagelevel}if(END INITFILES)VMDEBUG
8 dict dup begin/FontMatrix[1 0 0 1 0 0]readonly def/FontType 3 def/FontName()def/Encoding StandardEncoding def
/FontBBox{0 0 0 0}readonly def/BuildChar{pop pop 0 0 setcharwidth}bind def/PaintType 0 def
end/NullFont exch definefont setfont/NullFont currentfont def
.loadinitialfonts/undefinefont where{pop/NullFont undefinefont}{FontDirectory/NullFont .undef}ifelse(END FONTS)VMDEBUG
/runlibfile/.runlibfile load def
currentdict/.runlibfile .undef/.bindoperators{errordict/typecheck 2 copy get
errordict/typecheck{pop}put
currentdict{dup type/operatortype eq{.bind}if pop pop}forall
put}def
NOBIND DELAYBIND or not{.bindoperators}if
defaultdevice
systemdict/DEFAULTPAPERSIZE known
systemdict/PAPERSIZE known not and
systemdict/DEVICEWIDTH known not and
systemdict/DEVICEHEIGHT known not and
systemdict/DEVICEWIDTHPOINTS known not and
systemdict/DEVICEHEIGHTPOINTS known not and{defaultdevice mark/PageSize//null .dicttomark .getdeviceparams
.dicttomark/PageSize get
dup 0 get 0.5 add cvi 612 eq 1 index 1 get 0.5 add cvi 792 eq and
1 index 0 get 0.5 add cvi 595 eq 2 index 1 get 0.5 add cvi 842 eq and
or exch pop{/PAPERSIZE DEFAULTPAPERSIZE def}if}if
systemdict/DEVICEWIDTH known
systemdict/DEVICEHEIGHT known or
systemdict/DEVICEWIDTHPOINTS known or
systemdict/DEVICEHEIGHTPOINTS known or
systemdict/DEVICEXRESOLUTION known or
systemdict/DEVICEYRESOLUTION known or
systemdict/PAPERSIZE known or
not{(%END DEVICE).skipeof}if
systemdict/PAPERSIZE known
systemdict/DEVICEWIDTH known not and
systemdict/DEVICEHEIGHT known not and
systemdict/DEVICEWIDTHPOINTS known not and
systemdict/DEVICEHEIGHTPOINTS known not and{true statusdict/.pagetypenames get{PAPERSIZE eq{PAPERSIZE load
dup 0 get/DEVICEWIDTHPOINTS exch def
1 get/DEVICEHEIGHTPOINTS exch def
pop false exit}if}forall{(Unknown paper size: )print PAPERSIZE ==only(.)=}if}if
mark/HWResolution//null/HWSize//null/PageSize//null .dicttomark
.getdeviceparams .dicttomark begin
mark/DEVICEXRESOLUTION where dup{exch pop HWResolution 0 DEVICEXRESOLUTION put}if/DEVICEYRESOLUTION where dup
{exch pop HWResolution 1 DEVICEYRESOLUTION put}if
or{/HWResolution HWResolution}if/DEVICEWIDTH where dup{exch pop HWSize 0 DEVICEWIDTH put}if/DEVICEHEIGHT where dup
{exch pop HWSize 1 DEVICEHEIGHT put}if
or{/HWSize HWSize}if/DEVICEWIDTHPOINTS where dup{exch pop PageSize 0 DEVICEWIDTHPOINTS put}if/DEVICEHEIGHTPOINTS where dup
{exch pop PageSize 1 DEVICEHEIGHTPOINTS put}if
or{/PageSize PageSize}if
dup mark eq{pop}{defaultdevice putdeviceprops}ifelse
end
%END DEVICE
systemdict/BufferSpace known
systemdict/MaxBitmap known not and{systemdict/MaxBitmap BufferSpace put}if
dup getdeviceprops
counttomark 2 idiv{systemdict 2 index known{pop dup load counttomark 2 roll}{pop pop}ifelse}repeat
counttomark dup 0 ne{2 add -1 roll putdeviceprops}{pop pop}ifelse{setdevice}INITDEBUG{exec false}{.internalstopped}ifelse{
(**** Unable to open the initial device, quitting.)= flush 1 .quit}if
FIXEDMEDIA
dup{pop systemdict/.currentpagedevice known}if
dup{pop .currentpagedevice exch pop}if
not{(%END MEDIA).skipeof}if
currentpagedevice dup length dict .copydict
dup/Policies
1 index/InputAttributes
2 copy get dup length dict .copydict
dup 0 2 copy get dup length dict .copydict
dup/PageSize 7 index/PageSize get
put
put
put
2 copy get dup length dict .copydict
dup/PageSize 7 put
put
.setpagedevice
%END MEDIA
/setpagedevice where{pop systemdict/UseCIEColor known{mark/UseCIEColor UseCIEColor .dicttomark setpagedevice}if}if
%END DISPLAYING
(END DEVICE)VMDEBUG
mark
18 dup dtransform
exch abs cvi 31 add 32 idiv 4 mul
exch abs cvi mul
cachestatus pop pop pop pop pop exch pop 0.01 mul cvi
.max dup 10 idiv exch
setcacheparams
NOCACHE{0 setcachelimit}if(END CONFIG)VMDEBUG
.setdefaultscreen
initgraphics
gsave
<04>cvn JOBSERVER{{{clear cleardictstack//false 0 .startnewjob}2 .stop}bind}{{}}ifelse def
<1b>cvn{currentfile(%-12345X).peekstring pop(%-12345X)eq<04>cvn load if}bind def
<1b45>cvn{}def
<1b451b>cvn<1b>cvn load def(\001M)cvn{currentfile/TBCPDecode filter cvx exec}bind def/@PJL{count 3 ge{dup mark eq{
2 index countdictstack eq{1 index/lucas where{/lucas get eq}{pop false}ifelse{stop}if}if}if}if
currentfile//=string readline pop pop}bind def
systemdict/EPSBoundingBoxInit known{EPSBoundingBoxInit}if
.currentglobal true .setglobal/SAFETY 2 dict
dup/safe false put
dup/tempfiles 10 dict readonly put
readonly def
.setglobal/.locksafe{SAFETY/safe get not{<</PermitFileReading[currentuserparams/PermitFileReading get aload pop
/FONTPATH .systemvar(*).generate_dir_list_templates/LIBPATH .systemvar(*).generate_dir_list_templates
/LIBPATH .systemvar(*).file_name_separator(*)concatstrings concatstrings .generate_dir_list_templates
.languagelevel 2 ge{[currentsystemparams/GenericResourceDir get](*).generate_dir_list_templates
[currentsystemparams/GenericResourceDir get](*).file_name_separator(*)concatstrings concatstrings .generate_dir_list_templates
}if]/LockFilePermissions true
>>setuserparams}if
currentglobal currentpagedevice gcheck setglobal
<</.LockSafetyParams true >>setpagedevice
setglobal//SAFETY/safe//true .forceput}.bind executeonly odef/.setsafe{SAFETY/safe get not{<</PermitFileReading[]
/PermitFileWriting[]/PermitFileControl[]>>setuserparams}if
.locksafe}.bind executeonly odef/deletefile{dup{deletefile}stopped{pop//deletefile $error/errorname get signalerror}{
//SAFETY/tempfiles get exch cvn 2 copy known{.forceundef}{pop pop}ifelse}ifelse}.bind executeonly odef/.tempfile{.tempfile
//SAFETY/tempfiles get 2 .argindex true .forceput}.bind executeonly odef
SAFER{.setsafe}if/.bindnow{currentuserparams/IdiomRecognition .knownget{1 dict dup/IdiomRecognition//false put setuserparams}if
//systemdict begin .bindoperators end
errordict/typecheck 2 copy get
errordict/typecheck{pop}put
0 1 .delaycount 1 sub{.delaybind exch get .bind pop}for//systemdict/.delaybind{}.forceput//systemdict/.bindnow .forceundef
put//systemdict/.forcecopynew .forceundef//systemdict/.forcedef .forceundef//systemdict/.forceput .forceundef
//systemdict/.forceundef .forceundef
currentuserparams/IdiomRecognition known{1 dict dup/IdiomRecognition 4 -1 roll put setuserparams}if}.bind odef
false setpacking(END INIT)VMDEBUG/.currentuserparams where{pop
mark .currentuserparams counttomark 2 idiv{pop psuserparams exch undef}repeat pop
mark .currentuserparams counttomark 2 idiv{userparams 3 1 roll .forceput}repeat pop
currentuserparams/IdiomRecognition known{/IdiomRecognition true .definepsuserparam}if
psuserparams readonly pop
systemdict/.definepsuserparam undef
.currentglobal false .setglobal
mark userparams{}forall .dicttomark readonly/userparams exch .forcedef
.setglobal}if/.currentsystemparams where{pop
mark .currentsystemparams counttomark 2 idiv{pop pssystemparams exch .forceundef}repeat pop}if/AlignToPixels where{
mark/AlignToPixels 2 index/AlignToPixels get .dicttomark setuserparams/AlignToPixels undef}if/GridFitTT where{
mark/GridFitTT 2 index/GridFitTT get .dicttomark setuserparams/GridFitTT undef}if
false/setglobal where{pop setglobal}{.setglobal}ifelse
$error/.nosetlocal false put(END GLOBAL)VMDEBUG/.savelocalstate where{pop .savelocalstate}{.definefakefonts}ifelse
//.execute_scheduled_inits exec
currentdict/.execute_scheduled_inits undef
currentdict/.delayed_init_queue undef
FontDirectory readonly pop/GlobalFontDirectory where{pop GlobalFontDirectory readonly pop}if
currentdict/filterdict .undef
currentdict/.cidfonttypes .undef
currentdict/.colorrenderingtypes .undef
currentdict/.formtypes .undef
currentdict/.halftonetypes .undef
currentdict/.imagetypes .undef
currentdict/.imagemasktypes .undef
currentdict/.patterntypes .undef
currentdict/.shadingtypes .undef
currentdict/.wheredict .undef
currentdict/.renderingintentdict .undef
end/vmreclaim where{pop NOGC not{2 vmreclaim 0 vmreclaim}if}if
DELAYBIND not{systemdict/.forcecopynew .undef
systemdict/.forcedef .undef
systemdict/.forceput .undef
systemdict/.forceundef .undef}if
currentdict/superexec .knownget{1183615869 internaldict/superexec 3 -1 roll put
currentdict/superexec .undef}if
WRITESYSTEMDICT not{systemdict readonly pop}if(END GC)VMDEBUG
userdict/AGM_preserve_spots false put
